Description: add autogenerated sources to cpa/jdo module
 These classes were generated with castor-maven-plugin.
 The reason why they are not generated at build time is because
 castor-maven-plugin is not available in Debian since it depends on this
 package. When castor gets accepted in the archive, castor-maven-plugin will be
 packaged and when it gets accepted in the archive, this package will re rebuilt
 with that plugin and this patch will be removed.
Author: Miguel Landaeta <miguel@miguel.cc>
Forwarded: no
Last-Update: 2012-01-21

--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/.castor.cdr
@@ -0,0 +1,13 @@
+#Sun Jan 22 02:12:12 UTC 2012
+org.castor.jdo.conf.ClassMapping=org.castor.jdo.conf.descriptors.ClassMappingDescriptor
+org.castor.jdo.conf.Jndi=org.castor.jdo.conf.descriptors.JndiDescriptor
+org.castor.jdo.conf.TransactionManager=org.castor.jdo.conf.descriptors.TransactionManagerDescriptor
+org.castor.jdo.conf.TransactionDemarcation=org.castor.jdo.conf.descriptors.TransactionDemarcationDescriptor
+org.castor.jdo.conf.JdoConf=org.castor.jdo.conf.descriptors.JdoConfDescriptor
+org.castor.jdo.conf.Param=org.castor.jdo.conf.descriptors.ParamDescriptor
+org.castor.jdo.conf.DataSource=org.castor.jdo.conf.descriptors.DataSourceDescriptor
+org.castor.jdo.conf.DatabaseChoice=org.castor.jdo.conf.descriptors.DatabaseChoiceDescriptor
+org.castor.jdo.conf.PackageMapping=org.castor.jdo.conf.descriptors.PackageMappingDescriptor
+org.castor.jdo.conf.Driver=org.castor.jdo.conf.descriptors.DriverDescriptor
+org.castor.jdo.conf.Database=org.castor.jdo.conf.descriptors.DatabaseDescriptor
+org.castor.jdo.conf.Mapping=org.castor.jdo.conf.descriptors.MappingDescriptor
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/Mapping.java
@@ -0,0 +1,138 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class Mapping.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Mapping implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _href.
+     */
+    private java.lang.String _href;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Mapping() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'href'.
+     * 
+     * @return the value of field 'Href'.
+     */
+    public java.lang.String getHref(
+    ) {
+        return this._href;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'href'.
+     * 
+     * @param href the value of field 'href'.
+     */
+    public void setHref(
+            final java.lang.String href) {
+        this._href = href;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.Mapping
+     */
+    public static org.castor.jdo.conf.Mapping unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.Mapping) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.Mapping.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/JdoConf.java
@@ -0,0 +1,332 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class JdoConf.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class JdoConf implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name = "jdo-conf";
+
+    /**
+     * Field _databaseList.
+     */
+    private java.util.List<org.castor.jdo.conf.Database> _databaseList;
+
+    /**
+     * Field _transactionDemarcation.
+     */
+    private org.castor.jdo.conf.TransactionDemarcation _transactionDemarcation;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public JdoConf() {
+        super();
+        setName("jdo-conf");
+        this._databaseList = new java.util.ArrayList<org.castor.jdo.conf.Database>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vDatabase
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addDatabase(
+            final org.castor.jdo.conf.Database vDatabase)
+    throws java.lang.IndexOutOfBoundsException {
+        this._databaseList.add(vDatabase);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vDatabase
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addDatabase(
+            final int index,
+            final org.castor.jdo.conf.Database vDatabase)
+    throws java.lang.IndexOutOfBoundsException {
+        this._databaseList.add(index, vDatabase);
+    }
+
+    /**
+     * Method enumerateDatabase.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.castor.jdo.conf.Database> enumerateDatabase(
+    ) {
+        return java.util.Collections.enumeration(this._databaseList);
+    }
+
+    /**
+     * Method getDatabase.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.castor.jdo.conf.Database at the
+     * given index
+     */
+    public org.castor.jdo.conf.Database getDatabase(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._databaseList.size()) {
+            throw new IndexOutOfBoundsException("getDatabase: Index value '" + index + "' not in range [0.." + (this._databaseList.size() - 1) + "]");
+        }
+
+        return (org.castor.jdo.conf.Database) _databaseList.get(index);
+    }
+
+    /**
+     * Method getDatabase.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.castor.jdo.conf.Database[] getDatabase(
+    ) {
+        org.castor.jdo.conf.Database[] array = new org.castor.jdo.conf.Database[0];
+        return (org.castor.jdo.conf.Database[]) this._databaseList.toArray(array);
+    }
+
+    /**
+     * Method getDatabaseCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getDatabaseCount(
+    ) {
+        return this._databaseList.size();
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'transactionDemarcation'.
+     * 
+     * @return the value of field 'TransactionDemarcation'.
+     */
+    public org.castor.jdo.conf.TransactionDemarcation getTransactionDemarcation(
+    ) {
+        return this._transactionDemarcation;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateDatabase.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.castor.jdo.conf.Database> iterateDatabase(
+    ) {
+        return this._databaseList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllDatabase(
+    ) {
+        this._databaseList.clear();
+    }
+
+    /**
+     * Method removeDatabase.
+     * 
+     * @param vDatabase
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeDatabase(
+            final org.castor.jdo.conf.Database vDatabase) {
+        boolean removed = _databaseList.remove(vDatabase);
+        return removed;
+    }
+
+    /**
+     * Method removeDatabaseAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.castor.jdo.conf.Database removeDatabaseAt(
+            final int index) {
+        java.lang.Object obj = this._databaseList.remove(index);
+        return (org.castor.jdo.conf.Database) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vDatabase
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setDatabase(
+            final int index,
+            final org.castor.jdo.conf.Database vDatabase)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._databaseList.size()) {
+            throw new IndexOutOfBoundsException("setDatabase: Index value '" + index + "' not in range [0.." + (this._databaseList.size() - 1) + "]");
+        }
+
+        this._databaseList.set(index, vDatabase);
+    }
+
+    /**
+     * 
+     * 
+     * @param vDatabaseArray
+     */
+    public void setDatabase(
+            final org.castor.jdo.conf.Database[] vDatabaseArray) {
+        //-- copy array
+        _databaseList.clear();
+
+        for (int i = 0; i < vDatabaseArray.length; i++) {
+                this._databaseList.add(vDatabaseArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'transactionDemarcation'.
+     * 
+     * @param transactionDemarcation the value of field
+     * 'transactionDemarcation'.
+     */
+    public void setTransactionDemarcation(
+            final org.castor.jdo.conf.TransactionDemarcation transactionDemarcation) {
+        this._transactionDemarcation = transactionDemarcation;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.JdoConf
+     */
+    public static org.castor.jdo.conf.JdoConf unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.JdoConf) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.JdoConf.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/DatabaseChoice.java
@@ -0,0 +1,188 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class DatabaseChoice.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class DatabaseChoice implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _driver.
+     */
+    private org.castor.jdo.conf.Driver _driver;
+
+    /**
+     * Field _dataSource.
+     */
+    private org.castor.jdo.conf.DataSource _dataSource;
+
+    /**
+     * Field _jndi.
+     */
+    private org.castor.jdo.conf.Jndi _jndi;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public DatabaseChoice() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'dataSource'.
+     * 
+     * @return the value of field 'DataSource'.
+     */
+    public org.castor.jdo.conf.DataSource getDataSource(
+    ) {
+        return this._dataSource;
+    }
+
+    /**
+     * Returns the value of field 'driver'.
+     * 
+     * @return the value of field 'Driver'.
+     */
+    public org.castor.jdo.conf.Driver getDriver(
+    ) {
+        return this._driver;
+    }
+
+    /**
+     * Returns the value of field 'jndi'.
+     * 
+     * @return the value of field 'Jndi'.
+     */
+    public org.castor.jdo.conf.Jndi getJndi(
+    ) {
+        return this._jndi;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'dataSource'.
+     * 
+     * @param dataSource the value of field 'dataSource'.
+     */
+    public void setDataSource(
+            final org.castor.jdo.conf.DataSource dataSource) {
+        this._dataSource = dataSource;
+    }
+
+    /**
+     * Sets the value of field 'driver'.
+     * 
+     * @param driver the value of field 'driver'.
+     */
+    public void setDriver(
+            final org.castor.jdo.conf.Driver driver) {
+        this._driver = driver;
+    }
+
+    /**
+     * Sets the value of field 'jndi'.
+     * 
+     * @param jndi the value of field 'jndi'.
+     */
+    public void setJndi(
+            final org.castor.jdo.conf.Jndi jndi) {
+        this._jndi = jndi;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.DatabaseChoice
+     */
+    public static org.castor.jdo.conf.DatabaseChoice unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.DatabaseChoice) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.DatabaseChoice.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/Param.java
@@ -0,0 +1,163 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class Param.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Param implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _value.
+     */
+    private java.lang.String _value;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Param() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'value'.
+     * 
+     * @return the value of field 'Value'.
+     */
+    public java.lang.String getValue(
+    ) {
+        return this._value;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'value'.
+     * 
+     * @param value the value of field 'value'.
+     */
+    public void setValue(
+            final java.lang.String value) {
+        this._value = value;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.Param
+     */
+    public static org.castor.jdo.conf.Param unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.Param) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.Param.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/ClassMapping.java
@@ -0,0 +1,138 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class ClassMapping.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class ClassMapping implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassMapping() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.ClassMapping
+     */
+    public static org.castor.jdo.conf.ClassMapping unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.ClassMapping) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.ClassMapping.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/TransactionDemarcation.java
@@ -0,0 +1,165 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class TransactionDemarcation.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class TransactionDemarcation implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _mode.
+     */
+    private java.lang.String _mode;
+
+    /**
+     * Field _transactionManager.
+     */
+    private org.castor.jdo.conf.TransactionManager _transactionManager;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public TransactionDemarcation() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'mode'.
+     * 
+     * @return the value of field 'Mode'.
+     */
+    public java.lang.String getMode(
+    ) {
+        return this._mode;
+    }
+
+    /**
+     * Returns the value of field 'transactionManager'.
+     * 
+     * @return the value of field 'TransactionManager'.
+     */
+    public org.castor.jdo.conf.TransactionManager getTransactionManager(
+    ) {
+        return this._transactionManager;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'mode'.
+     * 
+     * @param mode the value of field 'mode'.
+     */
+    public void setMode(
+            final java.lang.String mode) {
+        this._mode = mode;
+    }
+
+    /**
+     * Sets the value of field 'transactionManager'.
+     * 
+     * @param transactionManager the value of field
+     * 'transactionManager'.
+     */
+    public void setTransactionManager(
+            final org.castor.jdo.conf.TransactionManager transactionManager) {
+        this._transactionManager = transactionManager;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.castor.jdo.conf.TransactionDemarcation
+     */
+    public static org.castor.jdo.conf.TransactionDemarcation unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.TransactionDemarcation) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.TransactionDemarcation.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/PackageMapping.java
@@ -0,0 +1,138 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class PackageMapping.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class PackageMapping implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PackageMapping() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.PackageMapping
+     */
+    public static org.castor.jdo.conf.PackageMapping unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.PackageMapping) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.PackageMapping.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/DataSource.java
@@ -0,0 +1,305 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class DataSource.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class DataSource implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _className.
+     */
+    private java.lang.String _className;
+
+    /**
+     * Field _paramList.
+     */
+    private java.util.List<org.castor.jdo.conf.Param> _paramList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public DataSource() {
+        super();
+        this._paramList = new java.util.ArrayList<org.castor.jdo.conf.Param>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final int index,
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(index, vParam);
+    }
+
+    /**
+     * Method enumerateParam.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.castor.jdo.conf.Param> enumerateParam(
+    ) {
+        return java.util.Collections.enumeration(this._paramList);
+    }
+
+    /**
+     * Returns the value of field 'className'.
+     * 
+     * @return the value of field 'ClassName'.
+     */
+    public java.lang.String getClassName(
+    ) {
+        return this._className;
+    }
+
+    /**
+     * Method getParam.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.castor.jdo.conf.Param at the
+     * given index
+     */
+    public org.castor.jdo.conf.Param getParam(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("getParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        return (org.castor.jdo.conf.Param) _paramList.get(index);
+    }
+
+    /**
+     * Method getParam.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.castor.jdo.conf.Param[] getParam(
+    ) {
+        org.castor.jdo.conf.Param[] array = new org.castor.jdo.conf.Param[0];
+        return (org.castor.jdo.conf.Param[]) this._paramList.toArray(array);
+    }
+
+    /**
+     * Method getParamCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getParamCount(
+    ) {
+        return this._paramList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateParam.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.castor.jdo.conf.Param> iterateParam(
+    ) {
+        return this._paramList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllParam(
+    ) {
+        this._paramList.clear();
+    }
+
+    /**
+     * Method removeParam.
+     * 
+     * @param vParam
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeParam(
+            final org.castor.jdo.conf.Param vParam) {
+        boolean removed = _paramList.remove(vParam);
+        return removed;
+    }
+
+    /**
+     * Method removeParamAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.castor.jdo.conf.Param removeParamAt(
+            final int index) {
+        java.lang.Object obj = this._paramList.remove(index);
+        return (org.castor.jdo.conf.Param) obj;
+    }
+
+    /**
+     * Sets the value of field 'className'.
+     * 
+     * @param className the value of field 'className'.
+     */
+    public void setClassName(
+            final java.lang.String className) {
+        this._className = className;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setParam(
+            final int index,
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("setParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        this._paramList.set(index, vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param vParamArray
+     */
+    public void setParam(
+            final org.castor.jdo.conf.Param[] vParamArray) {
+        //-- copy array
+        _paramList.clear();
+
+        for (int i = 0; i < vParamArray.length; i++) {
+                this._paramList.add(vParamArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.DataSource
+     */
+    public static org.castor.jdo.conf.DataSource unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.DataSource) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.DataSource.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/Jndi.java
@@ -0,0 +1,138 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class Jndi.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Jndi implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Jndi() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.Jndi
+     */
+    public static org.castor.jdo.conf.Jndi unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.Jndi) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.Jndi.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/TransactionManager.java
@@ -0,0 +1,306 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class TransactionManager.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class TransactionManager implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name = "local";
+
+    /**
+     * Field _paramList.
+     */
+    private java.util.List<org.castor.jdo.conf.Param> _paramList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public TransactionManager() {
+        super();
+        setName("local");
+        this._paramList = new java.util.ArrayList<org.castor.jdo.conf.Param>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final int index,
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(index, vParam);
+    }
+
+    /**
+     * Method enumerateParam.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.castor.jdo.conf.Param> enumerateParam(
+    ) {
+        return java.util.Collections.enumeration(this._paramList);
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method getParam.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.castor.jdo.conf.Param at the
+     * given index
+     */
+    public org.castor.jdo.conf.Param getParam(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("getParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        return (org.castor.jdo.conf.Param) _paramList.get(index);
+    }
+
+    /**
+     * Method getParam.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.castor.jdo.conf.Param[] getParam(
+    ) {
+        org.castor.jdo.conf.Param[] array = new org.castor.jdo.conf.Param[0];
+        return (org.castor.jdo.conf.Param[]) this._paramList.toArray(array);
+    }
+
+    /**
+     * Method getParamCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getParamCount(
+    ) {
+        return this._paramList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateParam.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.castor.jdo.conf.Param> iterateParam(
+    ) {
+        return this._paramList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllParam(
+    ) {
+        this._paramList.clear();
+    }
+
+    /**
+     * Method removeParam.
+     * 
+     * @param vParam
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeParam(
+            final org.castor.jdo.conf.Param vParam) {
+        boolean removed = _paramList.remove(vParam);
+        return removed;
+    }
+
+    /**
+     * Method removeParamAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.castor.jdo.conf.Param removeParamAt(
+            final int index) {
+        java.lang.Object obj = this._paramList.remove(index);
+        return (org.castor.jdo.conf.Param) obj;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setParam(
+            final int index,
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("setParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        this._paramList.set(index, vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param vParamArray
+     */
+    public void setParam(
+            final org.castor.jdo.conf.Param[] vParamArray) {
+        //-- copy array
+        _paramList.clear();
+
+        for (int i = 0; i < vParamArray.length; i++) {
+                this._paramList.add(vParamArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.TransactionManage
+     */
+    public static org.castor.jdo.conf.TransactionManager unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.TransactionManager) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.TransactionManager.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/Database.java
@@ -0,0 +1,692 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class Database.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Database implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _engine.
+     */
+    private java.lang.String _engine = "generic";
+
+    /**
+     * Field _databaseChoice.
+     */
+    private org.castor.jdo.conf.DatabaseChoice _databaseChoice;
+
+    /**
+     * Field _mappingList.
+     */
+    private java.util.List<org.castor.jdo.conf.Mapping> _mappingList;
+
+    /**
+     * Field _packageMappingList.
+     */
+    private java.util.List<org.castor.jdo.conf.PackageMapping> _packageMappingList;
+
+    /**
+     * Field _classMappingList.
+     */
+    private java.util.List<org.castor.jdo.conf.ClassMapping> _classMappingList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Database() {
+        super();
+        setEngine("generic");
+        this._mappingList = new java.util.ArrayList<org.castor.jdo.conf.Mapping>();
+        this._packageMappingList = new java.util.ArrayList<org.castor.jdo.conf.PackageMapping>();
+        this._classMappingList = new java.util.ArrayList<org.castor.jdo.conf.ClassMapping>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vClassMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addClassMapping(
+            final org.castor.jdo.conf.ClassMapping vClassMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._classMappingList.add(vClassMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vClassMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addClassMapping(
+            final int index,
+            final org.castor.jdo.conf.ClassMapping vClassMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._classMappingList.add(index, vClassMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param vMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addMapping(
+            final org.castor.jdo.conf.Mapping vMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._mappingList.add(vMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addMapping(
+            final int index,
+            final org.castor.jdo.conf.Mapping vMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._mappingList.add(index, vMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param vPackageMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addPackageMapping(
+            final org.castor.jdo.conf.PackageMapping vPackageMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._packageMappingList.add(vPackageMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vPackageMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addPackageMapping(
+            final int index,
+            final org.castor.jdo.conf.PackageMapping vPackageMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._packageMappingList.add(index, vPackageMapping);
+    }
+
+    /**
+     * Method enumerateClassMapping.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.castor.jdo.conf.ClassMapping> enumerateClassMapping(
+    ) {
+        return java.util.Collections.enumeration(this._classMappingList);
+    }
+
+    /**
+     * Method enumerateMapping.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.castor.jdo.conf.Mapping> enumerateMapping(
+    ) {
+        return java.util.Collections.enumeration(this._mappingList);
+    }
+
+    /**
+     * Method enumeratePackageMapping.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.castor.jdo.conf.PackageMapping> enumeratePackageMapping(
+    ) {
+        return java.util.Collections.enumeration(this._packageMappingList);
+    }
+
+    /**
+     * Method getClassMapping.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.castor.jdo.conf.ClassMapping at
+     * the given index
+     */
+    public org.castor.jdo.conf.ClassMapping getClassMapping(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._classMappingList.size()) {
+            throw new IndexOutOfBoundsException("getClassMapping: Index value '" + index + "' not in range [0.." + (this._classMappingList.size() - 1) + "]");
+        }
+
+        return (org.castor.jdo.conf.ClassMapping) _classMappingList.get(index);
+    }
+
+    /**
+     * Method getClassMapping.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.castor.jdo.conf.ClassMapping[] getClassMapping(
+    ) {
+        org.castor.jdo.conf.ClassMapping[] array = new org.castor.jdo.conf.ClassMapping[0];
+        return (org.castor.jdo.conf.ClassMapping[]) this._classMappingList.toArray(array);
+    }
+
+    /**
+     * Method getClassMappingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getClassMappingCount(
+    ) {
+        return this._classMappingList.size();
+    }
+
+    /**
+     * Returns the value of field 'databaseChoice'.
+     * 
+     * @return the value of field 'DatabaseChoice'.
+     */
+    public org.castor.jdo.conf.DatabaseChoice getDatabaseChoice(
+    ) {
+        return this._databaseChoice;
+    }
+
+    /**
+     * Returns the value of field 'engine'.
+     * 
+     * @return the value of field 'Engine'.
+     */
+    public java.lang.String getEngine(
+    ) {
+        return this._engine;
+    }
+
+    /**
+     * Method getMapping.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.castor.jdo.conf.Mapping at the
+     * given index
+     */
+    public org.castor.jdo.conf.Mapping getMapping(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._mappingList.size()) {
+            throw new IndexOutOfBoundsException("getMapping: Index value '" + index + "' not in range [0.." + (this._mappingList.size() - 1) + "]");
+        }
+
+        return (org.castor.jdo.conf.Mapping) _mappingList.get(index);
+    }
+
+    /**
+     * Method getMapping.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.castor.jdo.conf.Mapping[] getMapping(
+    ) {
+        org.castor.jdo.conf.Mapping[] array = new org.castor.jdo.conf.Mapping[0];
+        return (org.castor.jdo.conf.Mapping[]) this._mappingList.toArray(array);
+    }
+
+    /**
+     * Method getMappingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getMappingCount(
+    ) {
+        return this._mappingList.size();
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method getPackageMapping.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.castor.jdo.conf.PackageMapping
+     * at the given index
+     */
+    public org.castor.jdo.conf.PackageMapping getPackageMapping(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._packageMappingList.size()) {
+            throw new IndexOutOfBoundsException("getPackageMapping: Index value '" + index + "' not in range [0.." + (this._packageMappingList.size() - 1) + "]");
+        }
+
+        return (org.castor.jdo.conf.PackageMapping) _packageMappingList.get(index);
+    }
+
+    /**
+     * Method getPackageMapping.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.castor.jdo.conf.PackageMapping[] getPackageMapping(
+    ) {
+        org.castor.jdo.conf.PackageMapping[] array = new org.castor.jdo.conf.PackageMapping[0];
+        return (org.castor.jdo.conf.PackageMapping[]) this._packageMappingList.toArray(array);
+    }
+
+    /**
+     * Method getPackageMappingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getPackageMappingCount(
+    ) {
+        return this._packageMappingList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateClassMapping.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.castor.jdo.conf.ClassMapping> iterateClassMapping(
+    ) {
+        return this._classMappingList.iterator();
+    }
+
+    /**
+     * Method iterateMapping.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.castor.jdo.conf.Mapping> iterateMapping(
+    ) {
+        return this._mappingList.iterator();
+    }
+
+    /**
+     * Method iteratePackageMapping.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.castor.jdo.conf.PackageMapping> iteratePackageMapping(
+    ) {
+        return this._packageMappingList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllClassMapping(
+    ) {
+        this._classMappingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllMapping(
+    ) {
+        this._mappingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllPackageMapping(
+    ) {
+        this._packageMappingList.clear();
+    }
+
+    /**
+     * Method removeClassMapping.
+     * 
+     * @param vClassMapping
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeClassMapping(
+            final org.castor.jdo.conf.ClassMapping vClassMapping) {
+        boolean removed = _classMappingList.remove(vClassMapping);
+        return removed;
+    }
+
+    /**
+     * Method removeClassMappingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.castor.jdo.conf.ClassMapping removeClassMappingAt(
+            final int index) {
+        java.lang.Object obj = this._classMappingList.remove(index);
+        return (org.castor.jdo.conf.ClassMapping) obj;
+    }
+
+    /**
+     * Method removeMapping.
+     * 
+     * @param vMapping
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeMapping(
+            final org.castor.jdo.conf.Mapping vMapping) {
+        boolean removed = _mappingList.remove(vMapping);
+        return removed;
+    }
+
+    /**
+     * Method removeMappingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.castor.jdo.conf.Mapping removeMappingAt(
+            final int index) {
+        java.lang.Object obj = this._mappingList.remove(index);
+        return (org.castor.jdo.conf.Mapping) obj;
+    }
+
+    /**
+     * Method removePackageMapping.
+     * 
+     * @param vPackageMapping
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removePackageMapping(
+            final org.castor.jdo.conf.PackageMapping vPackageMapping) {
+        boolean removed = _packageMappingList.remove(vPackageMapping);
+        return removed;
+    }
+
+    /**
+     * Method removePackageMappingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.castor.jdo.conf.PackageMapping removePackageMappingAt(
+            final int index) {
+        java.lang.Object obj = this._packageMappingList.remove(index);
+        return (org.castor.jdo.conf.PackageMapping) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vClassMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setClassMapping(
+            final int index,
+            final org.castor.jdo.conf.ClassMapping vClassMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._classMappingList.size()) {
+            throw new IndexOutOfBoundsException("setClassMapping: Index value '" + index + "' not in range [0.." + (this._classMappingList.size() - 1) + "]");
+        }
+
+        this._classMappingList.set(index, vClassMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param vClassMappingArray
+     */
+    public void setClassMapping(
+            final org.castor.jdo.conf.ClassMapping[] vClassMappingArray) {
+        //-- copy array
+        _classMappingList.clear();
+
+        for (int i = 0; i < vClassMappingArray.length; i++) {
+                this._classMappingList.add(vClassMappingArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'databaseChoice'.
+     * 
+     * @param databaseChoice the value of field 'databaseChoice'.
+     */
+    public void setDatabaseChoice(
+            final org.castor.jdo.conf.DatabaseChoice databaseChoice) {
+        this._databaseChoice = databaseChoice;
+    }
+
+    /**
+     * Sets the value of field 'engine'.
+     * 
+     * @param engine the value of field 'engine'.
+     */
+    public void setEngine(
+            final java.lang.String engine) {
+        this._engine = engine;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setMapping(
+            final int index,
+            final org.castor.jdo.conf.Mapping vMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._mappingList.size()) {
+            throw new IndexOutOfBoundsException("setMapping: Index value '" + index + "' not in range [0.." + (this._mappingList.size() - 1) + "]");
+        }
+
+        this._mappingList.set(index, vMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param vMappingArray
+     */
+    public void setMapping(
+            final org.castor.jdo.conf.Mapping[] vMappingArray) {
+        //-- copy array
+        _mappingList.clear();
+
+        for (int i = 0; i < vMappingArray.length; i++) {
+                this._mappingList.add(vMappingArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vPackageMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setPackageMapping(
+            final int index,
+            final org.castor.jdo.conf.PackageMapping vPackageMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._packageMappingList.size()) {
+            throw new IndexOutOfBoundsException("setPackageMapping: Index value '" + index + "' not in range [0.." + (this._packageMappingList.size() - 1) + "]");
+        }
+
+        this._packageMappingList.set(index, vPackageMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param vPackageMappingArray
+     */
+    public void setPackageMapping(
+            final org.castor.jdo.conf.PackageMapping[] vPackageMappingArray) {
+        //-- copy array
+        _packageMappingList.clear();
+
+        for (int i = 0; i < vPackageMappingArray.length; i++) {
+                this._packageMappingList.add(vPackageMappingArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.Database
+     */
+    public static org.castor.jdo.conf.Database unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.Database) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.Database.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/Driver.java
@@ -0,0 +1,330 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf;
+
+/**
+ * Class Driver.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Driver implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _url.
+     */
+    private java.lang.String _url;
+
+    /**
+     * Field _className.
+     */
+    private java.lang.String _className;
+
+    /**
+     * Field _paramList.
+     */
+    private java.util.List<org.castor.jdo.conf.Param> _paramList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Driver() {
+        super();
+        this._paramList = new java.util.ArrayList<org.castor.jdo.conf.Param>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final int index,
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(index, vParam);
+    }
+
+    /**
+     * Method enumerateParam.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.castor.jdo.conf.Param> enumerateParam(
+    ) {
+        return java.util.Collections.enumeration(this._paramList);
+    }
+
+    /**
+     * Returns the value of field 'className'.
+     * 
+     * @return the value of field 'ClassName'.
+     */
+    public java.lang.String getClassName(
+    ) {
+        return this._className;
+    }
+
+    /**
+     * Method getParam.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.castor.jdo.conf.Param at the
+     * given index
+     */
+    public org.castor.jdo.conf.Param getParam(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("getParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        return (org.castor.jdo.conf.Param) _paramList.get(index);
+    }
+
+    /**
+     * Method getParam.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.castor.jdo.conf.Param[] getParam(
+    ) {
+        org.castor.jdo.conf.Param[] array = new org.castor.jdo.conf.Param[0];
+        return (org.castor.jdo.conf.Param[]) this._paramList.toArray(array);
+    }
+
+    /**
+     * Method getParamCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getParamCount(
+    ) {
+        return this._paramList.size();
+    }
+
+    /**
+     * Returns the value of field 'url'.
+     * 
+     * @return the value of field 'Url'.
+     */
+    public java.lang.String getUrl(
+    ) {
+        return this._url;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateParam.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.castor.jdo.conf.Param> iterateParam(
+    ) {
+        return this._paramList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllParam(
+    ) {
+        this._paramList.clear();
+    }
+
+    /**
+     * Method removeParam.
+     * 
+     * @param vParam
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeParam(
+            final org.castor.jdo.conf.Param vParam) {
+        boolean removed = _paramList.remove(vParam);
+        return removed;
+    }
+
+    /**
+     * Method removeParamAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.castor.jdo.conf.Param removeParamAt(
+            final int index) {
+        java.lang.Object obj = this._paramList.remove(index);
+        return (org.castor.jdo.conf.Param) obj;
+    }
+
+    /**
+     * Sets the value of field 'className'.
+     * 
+     * @param className the value of field 'className'.
+     */
+    public void setClassName(
+            final java.lang.String className) {
+        this._className = className;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setParam(
+            final int index,
+            final org.castor.jdo.conf.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("setParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        this._paramList.set(index, vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param vParamArray
+     */
+    public void setParam(
+            final org.castor.jdo.conf.Param[] vParamArray) {
+        //-- copy array
+        _paramList.clear();
+
+        for (int i = 0; i < vParamArray.length; i++) {
+                this._paramList.add(vParamArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'url'.
+     * 
+     * @param url the value of field 'url'.
+     */
+    public void setUrl(
+            final java.lang.String url) {
+        this._url = url;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.castor.jdo.conf.Driver
+     */
+    public static org.castor.jdo.conf.Driver unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.castor.jdo.conf.Driver) org.exolab.castor.xml.Unmarshaller.unmarshal(org.castor.jdo.conf.Driver.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/MappingDescriptor.java
@@ -0,0 +1,213 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.Mapping;
+
+/**
+ * Class MappingDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class MappingDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MappingDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "mapping";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _href
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_href", "href", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Mapping target = (Mapping) object;
+                return target.getHref();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Mapping target = (Mapping) object;
+                    target.setHref( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _href
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.Mapping.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/PackageMappingDescriptor.java
@@ -0,0 +1,213 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.PackageMapping;
+
+/**
+ * Class PackageMappingDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PackageMappingDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PackageMappingDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "package";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                PackageMapping target = (PackageMapping) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    PackageMapping target = (PackageMapping) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.PackageMapping.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/TransactionDemarcationDescriptor.java
@@ -0,0 +1,255 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.TransactionDemarcation;
+
+/**
+ * Class TransactionDemarcationDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class TransactionDemarcationDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public TransactionDemarcationDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "transaction-demarcation";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _mode
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_mode", "mode", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                TransactionDemarcation target = (TransactionDemarcation) object;
+                return target.getMode();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    TransactionDemarcation target = (TransactionDemarcation) object;
+                    target.setMode( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _mode
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _transactionManager
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.TransactionManager.class, "_transactionManager", "transaction-manager", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                TransactionDemarcation target = (TransactionDemarcation) object;
+                return target.getTransactionManager();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    TransactionDemarcation target = (TransactionDemarcation) object;
+                    target.setTransactionManager( (org.castor.jdo.conf.TransactionManager) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.castor.jdo.conf.TransactionManager");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _transactionManager
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.TransactionDemarcation.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/DatabaseChoiceDescriptor.java
@@ -0,0 +1,294 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.DatabaseChoice;
+
+/**
+ * Class DatabaseChoiceDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class DatabaseChoiceDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public DatabaseChoiceDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsChoice();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _driver
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.Driver.class, "_driver", "driver", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                DatabaseChoice target = (DatabaseChoice) object;
+                return target.getDriver();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    DatabaseChoice target = (DatabaseChoice) object;
+                    target.setDriver( (org.castor.jdo.conf.Driver) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.castor.jdo.conf.Driver");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _driver
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _dataSource
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.DataSource.class, "_dataSource", "data-source", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                DatabaseChoice target = (DatabaseChoice) object;
+                return target.getDataSource();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    DatabaseChoice target = (DatabaseChoice) object;
+                    target.setDataSource( (org.castor.jdo.conf.DataSource) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.castor.jdo.conf.DataSource");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _dataSource
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _jndi
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.Jndi.class, "_jndi", "jndi", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                DatabaseChoice target = (DatabaseChoice) object;
+                return target.getJndi();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    DatabaseChoice target = (DatabaseChoice) object;
+                    target.setJndi( (org.castor.jdo.conf.Jndi) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.castor.jdo.conf.Jndi");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _jndi
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.DatabaseChoice.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/DataSourceDescriptor.java
@@ -0,0 +1,265 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.DataSource;
+
+/**
+ * Class DataSourceDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class DataSourceDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public DataSourceDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "data-source";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _className
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_className", "class-name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                DataSource target = (DataSource) object;
+                return target.getClassName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    DataSource target = (DataSource) object;
+                    target.setClassName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _className
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _paramList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.Param.class, "_paramList", "param", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                DataSource target = (DataSource) object;
+                return target.getParam();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    DataSource target = (DataSource) object;
+                    target.addParam( (org.castor.jdo.conf.Param) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    DataSource target = (DataSource) object;
+                    target.removeAllParam();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.castor.jdo.conf.Param");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _paramList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.DataSource.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/ParamDescriptor.java
@@ -0,0 +1,257 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.Param;
+
+/**
+ * Class ParamDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ParamDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ParamDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "param";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Param target = (Param) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Param target = (Param) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _value
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_value", "value", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Param target = (Param) object;
+                return target.getValue();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Param target = (Param) object;
+                    target.setValue( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _value
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.Param.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/ClassMappingDescriptor.java
@@ -0,0 +1,213 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.ClassMapping;
+
+/**
+ * Class ClassMappingDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ClassMappingDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassMappingDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "class";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.ClassMapping.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/DatabaseDescriptor.java
@@ -0,0 +1,447 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.Database;
+
+/**
+ * Class DatabaseDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class DatabaseDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public DatabaseDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "database";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        this._identity = desc;
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Database target = (Database) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Database target = (Database) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("ID");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.IdValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.IdValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _engine
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_engine", "engine", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Database target = (Database) object;
+                return target.getEngine();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Database target = (Database) object;
+                    target.setEngine( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _engine
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _databaseChoice
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.DatabaseChoice.class, "_databaseChoice", "-error-if-this-is-used-", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Database target = (Database) object;
+                return target.getDatabaseChoice();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Database target = (Database) object;
+                    target.setDatabaseChoice( (org.castor.jdo.conf.DatabaseChoice) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.castor.jdo.conf.DatabaseChoice();
+            }
+        };
+        desc.setSchemaType("org.castor.jdo.conf.DatabaseChoice");
+        desc.setHandler(handler);
+        desc.setContainer(true);
+        desc.setClassDescriptor(new org.castor.jdo.conf.descriptors.DatabaseChoiceDescriptor());
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _databaseChoice
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _mappingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.Mapping.class, "_mappingList", "mapping", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Database target = (Database) object;
+                return target.getMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Database target = (Database) object;
+                    target.addMapping( (org.castor.jdo.conf.Mapping) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Database target = (Database) object;
+                    target.removeAllMapping();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.castor.jdo.conf.Mapping");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _mappingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _packageMappingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.PackageMapping.class, "_packageMappingList", "package", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Database target = (Database) object;
+                return target.getPackageMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Database target = (Database) object;
+                    target.addPackageMapping( (org.castor.jdo.conf.PackageMapping) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Database target = (Database) object;
+                    target.removeAllPackageMapping();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.castor.jdo.conf.PackageMapping");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _packageMappingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _classMappingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.ClassMapping.class, "_classMappingList", "class", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Database target = (Database) object;
+                return target.getClassMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Database target = (Database) object;
+                    target.addClassMapping( (org.castor.jdo.conf.ClassMapping) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Database target = (Database) object;
+                    target.removeAllClassMapping();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.castor.jdo.conf.ClassMapping");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _classMappingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.Database.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/TransactionManagerDescriptor.java
@@ -0,0 +1,263 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.TransactionManager;
+
+/**
+ * Class TransactionManagerDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class TransactionManagerDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public TransactionManagerDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "transaction-manager";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                TransactionManager target = (TransactionManager) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    TransactionManager target = (TransactionManager) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _paramList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.Param.class, "_paramList", "param", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                TransactionManager target = (TransactionManager) object;
+                return target.getParam();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    TransactionManager target = (TransactionManager) object;
+                    target.addParam( (org.castor.jdo.conf.Param) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    TransactionManager target = (TransactionManager) object;
+                    target.removeAllParam();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.castor.jdo.conf.Param");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _paramList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.TransactionManager.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/DriverDescriptor.java
@@ -0,0 +1,309 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.Driver;
+
+/**
+ * Class DriverDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class DriverDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public DriverDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "driver";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _url
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_url", "url", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Driver target = (Driver) object;
+                return target.getUrl();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Driver target = (Driver) object;
+                    target.setUrl( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _url
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _className
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_className", "class-name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Driver target = (Driver) object;
+                return target.getClassName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Driver target = (Driver) object;
+                    target.setClassName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _className
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _paramList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.Param.class, "_paramList", "param", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Driver target = (Driver) object;
+                return target.getParam();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Driver target = (Driver) object;
+                    target.addParam( (org.castor.jdo.conf.Param) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Driver target = (Driver) object;
+                    target.removeAllParam();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.castor.jdo.conf.Param");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _paramList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.Driver.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/JndiDescriptor.java
@@ -0,0 +1,213 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.Jndi;
+
+/**
+ * Class JndiDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class JndiDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public JndiDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "jndi";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Jndi target = (Jndi) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Jndi target = (Jndi) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.Jndi.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/cpa/target/generated-sources/castor/org/castor/jdo/conf/descriptors/JdoConfDescriptor.java
@@ -0,0 +1,303 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.castor.jdo.conf.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.castor.jdo.conf.JdoConf;
+
+/**
+ * Class JdoConfDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class JdoConfDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public JdoConfDescriptor() {
+        super();
+        _nsURI = "http://castor.org/JDO";
+        _xmlName = "jdo-conf";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                JdoConf target = (JdoConf) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    JdoConf target = (JdoConf) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _databaseList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.Database.class, "_databaseList", "database", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                JdoConf target = (JdoConf) object;
+                return target.getDatabase();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    JdoConf target = (JdoConf) object;
+                    target.addDatabase( (org.castor.jdo.conf.Database) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    JdoConf target = (JdoConf) object;
+                    target.removeAllDatabase();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.castor.jdo.conf.Database");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setRequired(true);
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _databaseList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _transactionDemarcation
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.castor.jdo.conf.TransactionDemarcation.class, "_transactionDemarcation", "transaction-demarcation", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                JdoConf target = (JdoConf) object;
+                return target.getTransactionDemarcation();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    JdoConf target = (JdoConf) object;
+                    target.setTransactionDemarcation( (org.castor.jdo.conf.TransactionDemarcation) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.castor.jdo.conf.TransactionDemarcation");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.org/JDO");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _transactionDemarcation
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.castor.jdo.conf.JdoConf.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
