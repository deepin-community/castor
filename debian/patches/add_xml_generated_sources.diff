Description: add autogenerated sources to xml module
 These classes were generated with castor-maven-plugin.
 The reason why they are not generated at build time is because
 castor-maven-plugin is not available in Debian since it depends on this
 package. When castor gets accepted in the archive, castor-maven-plugin will be
 packaged and when it gets accepted in the archive, this package will re rebuilt
 with that plugin and this patch will be removed.
Author: Miguel Landaeta <miguel@miguel.cc>
Forwarded: no
Last-Update: 2012-01-21

--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/FieldHandlerDef.java
@@ -0,0 +1,331 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class FieldHandlerDef.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class FieldHandlerDef implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _clazz.
+     */
+    private java.lang.String _clazz;
+
+    /**
+     * Field _paramList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.Param> _paramList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldHandlerDef() {
+        super();
+        this._paramList = new java.util.ArrayList<org.exolab.castor.mapping.xml.Param>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final int index,
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(index, vParam);
+    }
+
+    /**
+     * Method enumerateParam.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.Param> enumerateParam(
+    ) {
+        return java.util.Collections.enumeration(this._paramList);
+    }
+
+    /**
+     * Returns the value of field 'clazz'.
+     * 
+     * @return the value of field 'Clazz'.
+     */
+    public java.lang.String getClazz(
+    ) {
+        return this._clazz;
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method getParam.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.exolab.castor.mapping.xml.Param
+     * at the given index
+     */
+    public org.exolab.castor.mapping.xml.Param getParam(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("getParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.Param) _paramList.get(index);
+    }
+
+    /**
+     * Method getParam.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.Param[] getParam(
+    ) {
+        org.exolab.castor.mapping.xml.Param[] array = new org.exolab.castor.mapping.xml.Param[0];
+        return (org.exolab.castor.mapping.xml.Param[]) this._paramList.toArray(array);
+    }
+
+    /**
+     * Method getParamCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getParamCount(
+    ) {
+        return this._paramList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateParam.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.Param> iterateParam(
+    ) {
+        return this._paramList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllParam(
+    ) {
+        this._paramList.clear();
+    }
+
+    /**
+     * Method removeParam.
+     * 
+     * @param vParam
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeParam(
+            final org.exolab.castor.mapping.xml.Param vParam) {
+        boolean removed = _paramList.remove(vParam);
+        return removed;
+    }
+
+    /**
+     * Method removeParamAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.Param removeParamAt(
+            final int index) {
+        java.lang.Object obj = this._paramList.remove(index);
+        return (org.exolab.castor.mapping.xml.Param) obj;
+    }
+
+    /**
+     * Sets the value of field 'clazz'.
+     * 
+     * @param clazz the value of field 'clazz'.
+     */
+    public void setClazz(
+            final java.lang.String clazz) {
+        this._clazz = clazz;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setParam(
+            final int index,
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("setParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        this._paramList.set(index, vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param vParamArray
+     */
+    public void setParam(
+            final org.exolab.castor.mapping.xml.Param[] vParamArray) {
+        //-- copy array
+        _paramList.clear();
+
+        for (int i = 0; i < vParamArray.length; i++) {
+                this._paramList.add(vParamArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.FieldHandlerDef
+     */
+    public static org.exolab.castor.mapping.xml.FieldHandlerDef unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.FieldHandlerDef) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.FieldHandlerDef.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/.castor.cdr
@@ -0,0 +1,20 @@
+#Sun Jan 22 02:11:58 UTC 2012
+org.exolab.castor.mapping.xml.BindXml=org.exolab.castor.mapping.xml.descriptors.BindXmlDescriptor
+org.exolab.castor.mapping.xml.FieldHandlerDef=org.exolab.castor.mapping.xml.descriptors.FieldHandlerDefDescriptor
+org.exolab.castor.mapping.xml.Container=org.exolab.castor.mapping.xml.descriptors.ContainerDescriptor
+org.exolab.castor.mapping.xml.Include=org.exolab.castor.mapping.xml.descriptors.IncludeDescriptor
+org.exolab.castor.mapping.xml.Param=org.exolab.castor.mapping.xml.descriptors.ParamDescriptor
+org.exolab.castor.mapping.xml.Ldap=org.exolab.castor.mapping.xml.descriptors.LdapDescriptor
+org.exolab.castor.mapping.xml.ClassChoice=org.exolab.castor.mapping.xml.descriptors.ClassChoiceDescriptor
+org.exolab.castor.mapping.xml.NamedQuery=org.exolab.castor.mapping.xml.descriptors.NamedQueryDescriptor
+org.exolab.castor.mapping.xml.ClassMapping=org.exolab.castor.mapping.xml.descriptors.ClassMappingDescriptor
+org.exolab.castor.mapping.xml.CacheTypeMapping=org.exolab.castor.mapping.xml.descriptors.CacheTypeMappingDescriptor
+org.exolab.castor.mapping.xml.FieldMapping=org.exolab.castor.mapping.xml.descriptors.FieldMappingDescriptor
+org.exolab.castor.mapping.xml.MappingRoot=org.exolab.castor.mapping.xml.descriptors.MappingRootDescriptor
+org.exolab.castor.mapping.xml.Sql=org.exolab.castor.mapping.xml.descriptors.SqlDescriptor
+org.exolab.castor.mapping.xml.KeyGeneratorDef=org.exolab.castor.mapping.xml.descriptors.KeyGeneratorDefDescriptor
+org.exolab.castor.mapping.xml.MapTo=org.exolab.castor.mapping.xml.descriptors.MapToDescriptor
+org.exolab.castor.mapping.xml.Property=org.exolab.castor.mapping.xml.descriptors.PropertyDescriptor
+org.exolab.castor.mapping.xml.PropertyType=org.exolab.castor.mapping.xml.descriptors.PropertyTypeDescriptor
+org.exolab.castor.mapping.xml.QueryHint=org.exolab.castor.mapping.xml.descriptors.QueryHintDescriptor
+org.exolab.castor.mapping.xml.NamedNativeQuery=org.exolab.castor.mapping.xml.descriptors.NamedNativeQueryDescriptor
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/MapTo.java
@@ -0,0 +1,335 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * The 'map-to' element is used for specifying the name of the item
+ * 
+ *  that should be associated with the given Java object.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class MapTo implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * An optional attribute used to specify the name of the table 
+     *  to which the given Java object is associated.
+     *  
+     */
+    private java.lang.String _table;
+
+    /**
+     * Field _xml.
+     */
+    private java.lang.String _xml;
+
+    /**
+     * Field _nsUri.
+     */
+    private java.lang.String _nsUri;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition = false;
+
+    /**
+     * keeps track of state for field: _elementDefinition
+     */
+    private boolean _has_elementDefinition;
+
+    /**
+     * Field _ldapDn.
+     */
+    private java.lang.String _ldapDn;
+
+    /**
+     * Field _ldapOc.
+     */
+    private java.lang.String _ldapOc;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MapTo() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     */
+    public void deleteElementDefinition(
+    ) {
+        this._has_elementDefinition= false;
+    }
+
+    /**
+     * Returns the value of field 'elementDefinition'.
+     * 
+     * @return the value of field 'ElementDefinition'.
+     */
+    public boolean getElementDefinition(
+    ) {
+        return this._elementDefinition;
+    }
+
+    /**
+     * Returns the value of field 'ldapDn'.
+     * 
+     * @return the value of field 'LdapDn'.
+     */
+    public java.lang.String getLdapDn(
+    ) {
+        return this._ldapDn;
+    }
+
+    /**
+     * Returns the value of field 'ldapOc'.
+     * 
+     * @return the value of field 'LdapOc'.
+     */
+    public java.lang.String getLdapOc(
+    ) {
+        return this._ldapOc;
+    }
+
+    /**
+     * Returns the value of field 'nsPrefix'.
+     * 
+     * @return the value of field 'NsPrefix'.
+     */
+    public java.lang.String getNsPrefix(
+    ) {
+        return this._nsPrefix;
+    }
+
+    /**
+     * Returns the value of field 'nsUri'.
+     * 
+     * @return the value of field 'NsUri'.
+     */
+    public java.lang.String getNsUri(
+    ) {
+        return this._nsUri;
+    }
+
+    /**
+     * Returns the value of field 'table'. The field 'table' has
+     * the following description: An optional attribute used to
+     * specify the name of the table 
+     *  to which the given Java object is associated.
+     *  
+     * 
+     * @return the value of field 'Table'.
+     */
+    public java.lang.String getTable(
+    ) {
+        return this._table;
+    }
+
+    /**
+     * Returns the value of field 'xml'.
+     * 
+     * @return the value of field 'Xml'.
+     */
+    public java.lang.String getXml(
+    ) {
+        return this._xml;
+    }
+
+    /**
+     * Method hasElementDefinition.
+     * 
+     * @return true if at least one ElementDefinition has been added
+     */
+    public boolean hasElementDefinition(
+    ) {
+        return this._has_elementDefinition;
+    }
+
+    /**
+     * Returns the value of field 'elementDefinition'.
+     * 
+     * @return the value of field 'ElementDefinition'.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return this._elementDefinition;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'elementDefinition'.
+     * 
+     * @param elementDefinition the value of field
+     * 'elementDefinition'.
+     */
+    public void setElementDefinition(
+            final boolean elementDefinition) {
+        this._elementDefinition = elementDefinition;
+        this._has_elementDefinition = true;
+    }
+
+    /**
+     * Sets the value of field 'ldapDn'.
+     * 
+     * @param ldapDn the value of field 'ldapDn'.
+     */
+    public void setLdapDn(
+            final java.lang.String ldapDn) {
+        this._ldapDn = ldapDn;
+    }
+
+    /**
+     * Sets the value of field 'ldapOc'.
+     * 
+     * @param ldapOc the value of field 'ldapOc'.
+     */
+    public void setLdapOc(
+            final java.lang.String ldapOc) {
+        this._ldapOc = ldapOc;
+    }
+
+    /**
+     * Sets the value of field 'nsPrefix'.
+     * 
+     * @param nsPrefix the value of field 'nsPrefix'.
+     */
+    public void setNsPrefix(
+            final java.lang.String nsPrefix) {
+        this._nsPrefix = nsPrefix;
+    }
+
+    /**
+     * Sets the value of field 'nsUri'.
+     * 
+     * @param nsUri the value of field 'nsUri'.
+     */
+    public void setNsUri(
+            final java.lang.String nsUri) {
+        this._nsUri = nsUri;
+    }
+
+    /**
+     * Sets the value of field 'table'. The field 'table' has the
+     * following description: An optional attribute used to specify
+     * the name of the table 
+     *  to which the given Java object is associated.
+     *  
+     * 
+     * @param table the value of field 'table'.
+     */
+    public void setTable(
+            final java.lang.String table) {
+        this._table = table;
+    }
+
+    /**
+     * Sets the value of field 'xml'.
+     * 
+     * @param xml the value of field 'xml'.
+     */
+    public void setXml(
+            final java.lang.String xml) {
+        this._xml = xml;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.exolab.castor.mapping.xml.MapTo
+     */
+    public static org.exolab.castor.mapping.xml.MapTo unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.MapTo) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.MapTo.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/BindXml.java
@@ -0,0 +1,670 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * The 'bind-xml' element is used for specifying XML specific
+ * databinding
+ *  properties and behavior for a specific field. 'bind-xml' may
+ * only appear
+ *  as a child of a 'field' element.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class BindXml implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * An optional attribute used for specifying the XML name for
+     * the
+     *  field associated with the 'bind-xml' element.
+     *  
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _type.
+     */
+    private java.lang.String _type;
+
+    /**
+     * Allows specifying how Castor should automatically determines
+     *  the XML name of this field when no name has been specified.
+     *  In most cases the XML name is determined by using the field
+     * name,
+     *  but in some cases the user may want to use the Class name
+     * of
+     *  the field type. This attribute allows choosing between the
+     *  two approaches. If this attribute is not specified, the
+     * field
+     *  name is used as the XML name.
+     *  
+     */
+    private org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType _autoNaming;
+
+    /**
+     * Allows specifying a nested location path for this field,
+     *  the value should just be a simplified XPath like value
+     *  where names are separated by "/".
+     *  
+     */
+    private java.lang.String _location;
+
+    /**
+     * Field _matches.
+     */
+    private java.lang.String _matches;
+
+    /**
+     * Field _reference.
+     */
+    private boolean _reference;
+
+    /**
+     * keeps track of state for field: _reference
+     */
+    private boolean _has_reference;
+
+    /**
+     * Field _node.
+     */
+    private org.exolab.castor.mapping.xml.types.BindXmlNodeType _node;
+
+    /**
+     * Field _QNamePrefix.
+     */
+    private java.lang.String _QNamePrefix;
+
+    /**
+     * Field _transient.
+     */
+    private boolean _transient;
+
+    /**
+     * keeps track of state for field: _transient
+     */
+    private boolean _has_transient;
+
+    /**
+     * The 'class' element is used to store information about
+     * mapping of a class.
+     *  
+     */
+    private org.exolab.castor.mapping.xml.ClassMapping _classMapping;
+
+    /**
+     * Field _propertyList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.Property> _propertyList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public BindXml() {
+        super();
+        this._propertyList = new java.util.ArrayList<org.exolab.castor.mapping.xml.Property>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vProperty
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addProperty(
+            final org.exolab.castor.mapping.xml.Property vProperty)
+    throws java.lang.IndexOutOfBoundsException {
+        this._propertyList.add(vProperty);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vProperty
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addProperty(
+            final int index,
+            final org.exolab.castor.mapping.xml.Property vProperty)
+    throws java.lang.IndexOutOfBoundsException {
+        this._propertyList.add(index, vProperty);
+    }
+
+    /**
+     */
+    public void deleteReference(
+    ) {
+        this._has_reference= false;
+    }
+
+    /**
+     */
+    public void deleteTransient(
+    ) {
+        this._has_transient= false;
+    }
+
+    /**
+     * Method enumerateProperty.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.Property> enumerateProperty(
+    ) {
+        return java.util.Collections.enumeration(this._propertyList);
+    }
+
+    /**
+     * Returns the value of field 'autoNaming'. The field
+     * 'autoNaming' has the following description: Allows
+     * specifying how Castor should automatically determines
+     *  the XML name of this field when no name has been specified.
+     *  In most cases the XML name is determined by using the field
+     * name,
+     *  but in some cases the user may want to use the Class name
+     * of
+     *  the field type. This attribute allows choosing between the
+     *  two approaches. If this attribute is not specified, the
+     * field
+     *  name is used as the XML name.
+     *  
+     * 
+     * @return the value of field 'AutoNaming'.
+     */
+    public org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType getAutoNaming(
+    ) {
+        return this._autoNaming;
+    }
+
+    /**
+     * Returns the value of field 'classMapping'. The field
+     * 'classMapping' has the following description: The 'class'
+     * element is used to store information about mapping of a
+     * class.
+     *  
+     * 
+     * @return the value of field 'ClassMapping'.
+     */
+    public org.exolab.castor.mapping.xml.ClassMapping getClassMapping(
+    ) {
+        return this._classMapping;
+    }
+
+    /**
+     * Returns the value of field 'location'. The field 'location'
+     * has the following description: Allows specifying a nested
+     * location path for this field,
+     *  the value should just be a simplified XPath like value
+     *  where names are separated by "/".
+     *  
+     * 
+     * @return the value of field 'Location'.
+     */
+    public java.lang.String getLocation(
+    ) {
+        return this._location;
+    }
+
+    /**
+     * Returns the value of field 'matches'.
+     * 
+     * @return the value of field 'Matches'.
+     */
+    public java.lang.String getMatches(
+    ) {
+        return this._matches;
+    }
+
+    /**
+     * Returns the value of field 'name'. The field 'name' has the
+     * following description: An optional attribute used for
+     * specifying the XML name for the
+     *  field associated with the 'bind-xml' element.
+     *  
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'node'.
+     * 
+     * @return the value of field 'Node'.
+     */
+    public org.exolab.castor.mapping.xml.types.BindXmlNodeType getNode(
+    ) {
+        return this._node;
+    }
+
+    /**
+     * Method getProperty.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.Property at the given index
+     */
+    public org.exolab.castor.mapping.xml.Property getProperty(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._propertyList.size()) {
+            throw new IndexOutOfBoundsException("getProperty: Index value '" + index + "' not in range [0.." + (this._propertyList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.Property) _propertyList.get(index);
+    }
+
+    /**
+     * Method getProperty.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.Property[] getProperty(
+    ) {
+        org.exolab.castor.mapping.xml.Property[] array = new org.exolab.castor.mapping.xml.Property[0];
+        return (org.exolab.castor.mapping.xml.Property[]) this._propertyList.toArray(array);
+    }
+
+    /**
+     * Method getPropertyCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getPropertyCount(
+    ) {
+        return this._propertyList.size();
+    }
+
+    /**
+     * Returns the value of field 'QNamePrefix'.
+     * 
+     * @return the value of field 'QNamePrefix'.
+     */
+    public java.lang.String getQNamePrefix(
+    ) {
+        return this._QNamePrefix;
+    }
+
+    /**
+     * Returns the value of field 'reference'.
+     * 
+     * @return the value of field 'Reference'.
+     */
+    public boolean getReference(
+    ) {
+        return this._reference;
+    }
+
+    /**
+     * Returns the value of field 'transient'.
+     * 
+     * @return the value of field 'Transient'.
+     */
+    public boolean getTransient(
+    ) {
+        return this._transient;
+    }
+
+    /**
+     * Returns the value of field 'type'.
+     * 
+     * @return the value of field 'Type'.
+     */
+    public java.lang.String getType(
+    ) {
+        return this._type;
+    }
+
+    /**
+     * Method hasReference.
+     * 
+     * @return true if at least one Reference has been added
+     */
+    public boolean hasReference(
+    ) {
+        return this._has_reference;
+    }
+
+    /**
+     * Method hasTransient.
+     * 
+     * @return true if at least one Transient has been added
+     */
+    public boolean hasTransient(
+    ) {
+        return this._has_transient;
+    }
+
+    /**
+     * Returns the value of field 'reference'.
+     * 
+     * @return the value of field 'Reference'.
+     */
+    public boolean isReference(
+    ) {
+        return this._reference;
+    }
+
+    /**
+     * Returns the value of field 'transient'.
+     * 
+     * @return the value of field 'Transient'.
+     */
+    public boolean isTransient(
+    ) {
+        return this._transient;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateProperty.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.Property> iterateProperty(
+    ) {
+        return this._propertyList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllProperty(
+    ) {
+        this._propertyList.clear();
+    }
+
+    /**
+     * Method removeProperty.
+     * 
+     * @param vProperty
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeProperty(
+            final org.exolab.castor.mapping.xml.Property vProperty) {
+        boolean removed = _propertyList.remove(vProperty);
+        return removed;
+    }
+
+    /**
+     * Method removePropertyAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.Property removePropertyAt(
+            final int index) {
+        java.lang.Object obj = this._propertyList.remove(index);
+        return (org.exolab.castor.mapping.xml.Property) obj;
+    }
+
+    /**
+     * Sets the value of field 'autoNaming'. The field 'autoNaming'
+     * has the following description: Allows specifying how Castor
+     * should automatically determines
+     *  the XML name of this field when no name has been specified.
+     *  In most cases the XML name is determined by using the field
+     * name,
+     *  but in some cases the user may want to use the Class name
+     * of
+     *  the field type. This attribute allows choosing between the
+     *  two approaches. If this attribute is not specified, the
+     * field
+     *  name is used as the XML name.
+     *  
+     * 
+     * @param autoNaming the value of field 'autoNaming'.
+     */
+    public void setAutoNaming(
+            final org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType autoNaming) {
+        this._autoNaming = autoNaming;
+    }
+
+    /**
+     * Sets the value of field 'classMapping'. The field
+     * 'classMapping' has the following description: The 'class'
+     * element is used to store information about mapping of a
+     * class.
+     *  
+     * 
+     * @param classMapping the value of field 'classMapping'.
+     */
+    public void setClassMapping(
+            final org.exolab.castor.mapping.xml.ClassMapping classMapping) {
+        this._classMapping = classMapping;
+    }
+
+    /**
+     * Sets the value of field 'location'. The field 'location' has
+     * the following description: Allows specifying a nested
+     * location path for this field,
+     *  the value should just be a simplified XPath like value
+     *  where names are separated by "/".
+     *  
+     * 
+     * @param location the value of field 'location'.
+     */
+    public void setLocation(
+            final java.lang.String location) {
+        this._location = location;
+    }
+
+    /**
+     * Sets the value of field 'matches'.
+     * 
+     * @param matches the value of field 'matches'.
+     */
+    public void setMatches(
+            final java.lang.String matches) {
+        this._matches = matches;
+    }
+
+    /**
+     * Sets the value of field 'name'. The field 'name' has the
+     * following description: An optional attribute used for
+     * specifying the XML name for the
+     *  field associated with the 'bind-xml' element.
+     *  
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'node'.
+     * 
+     * @param node the value of field 'node'.
+     */
+    public void setNode(
+            final org.exolab.castor.mapping.xml.types.BindXmlNodeType node) {
+        this._node = node;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vProperty
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setProperty(
+            final int index,
+            final org.exolab.castor.mapping.xml.Property vProperty)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._propertyList.size()) {
+            throw new IndexOutOfBoundsException("setProperty: Index value '" + index + "' not in range [0.." + (this._propertyList.size() - 1) + "]");
+        }
+
+        this._propertyList.set(index, vProperty);
+    }
+
+    /**
+     * 
+     * 
+     * @param vPropertyArray
+     */
+    public void setProperty(
+            final org.exolab.castor.mapping.xml.Property[] vPropertyArray) {
+        //-- copy array
+        _propertyList.clear();
+
+        for (int i = 0; i < vPropertyArray.length; i++) {
+                this._propertyList.add(vPropertyArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'QNamePrefix'.
+     * 
+     * @param QNamePrefix the value of field 'QNamePrefix'.
+     */
+    public void setQNamePrefix(
+            final java.lang.String QNamePrefix) {
+        this._QNamePrefix = QNamePrefix;
+    }
+
+    /**
+     * Sets the value of field 'reference'.
+     * 
+     * @param reference the value of field 'reference'.
+     */
+    public void setReference(
+            final boolean reference) {
+        this._reference = reference;
+        this._has_reference = true;
+    }
+
+    /**
+     * Sets the value of field 'transient'.
+     * 
+     * @param _transient
+     * @param transient the value of field 'transient'.
+     */
+    public void setTransient(
+            final boolean _transient) {
+        this._transient = _transient;
+        this._has_transient = true;
+    }
+
+    /**
+     * Sets the value of field 'type'.
+     * 
+     * @param type the value of field 'type'.
+     */
+    public void setType(
+            final java.lang.String type) {
+        this._type = type;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.exolab.castor.mapping.xml.BindXml
+     */
+    public static org.exolab.castor.mapping.xml.BindXml unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.BindXml) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.BindXml.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/PropertyType.java
@@ -0,0 +1,115 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class PropertyType.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public abstract class PropertyType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _value.
+     */
+    private java.lang.String _value;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PropertyType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'value'.
+     * 
+     * @return the value of field 'Value'.
+     */
+    public java.lang.String getValue(
+    ) {
+        return this._value;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'value'.
+     * 
+     * @param value the value of field 'value'.
+     */
+    public void setValue(
+            final java.lang.String value) {
+        this._value = value;
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/MappingRoot.java
@@ -0,0 +1,814 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class MappingRoot.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class MappingRoot implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _description.
+     */
+    private java.lang.String _description;
+
+    /**
+     * Field _includeList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.Include> _includeList;
+
+    /**
+     * Field _fieldHandlerDefList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.FieldHandlerDef> _fieldHandlerDefList;
+
+    /**
+     * The 'class' element is used to store information about
+     * mapping of a class.
+     *  
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.ClassMapping> _classMappingList;
+
+    /**
+     * Field _keyGeneratorDefList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.KeyGeneratorDef> _keyGeneratorDefList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MappingRoot() {
+        super();
+        this._includeList = new java.util.ArrayList<org.exolab.castor.mapping.xml.Include>();
+        this._fieldHandlerDefList = new java.util.ArrayList<org.exolab.castor.mapping.xml.FieldHandlerDef>();
+        this._classMappingList = new java.util.ArrayList<org.exolab.castor.mapping.xml.ClassMapping>();
+        this._keyGeneratorDefList = new java.util.ArrayList<org.exolab.castor.mapping.xml.KeyGeneratorDef>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vClassMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addClassMapping(
+            final org.exolab.castor.mapping.xml.ClassMapping vClassMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._classMappingList.add(vClassMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vClassMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addClassMapping(
+            final int index,
+            final org.exolab.castor.mapping.xml.ClassMapping vClassMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._classMappingList.add(index, vClassMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param vFieldHandlerDef
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addFieldHandlerDef(
+            final org.exolab.castor.mapping.xml.FieldHandlerDef vFieldHandlerDef)
+    throws java.lang.IndexOutOfBoundsException {
+        this._fieldHandlerDefList.add(vFieldHandlerDef);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vFieldHandlerDef
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addFieldHandlerDef(
+            final int index,
+            final org.exolab.castor.mapping.xml.FieldHandlerDef vFieldHandlerDef)
+    throws java.lang.IndexOutOfBoundsException {
+        this._fieldHandlerDefList.add(index, vFieldHandlerDef);
+    }
+
+    /**
+     * 
+     * 
+     * @param vInclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addInclude(
+            final org.exolab.castor.mapping.xml.Include vInclude)
+    throws java.lang.IndexOutOfBoundsException {
+        this._includeList.add(vInclude);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vInclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addInclude(
+            final int index,
+            final org.exolab.castor.mapping.xml.Include vInclude)
+    throws java.lang.IndexOutOfBoundsException {
+        this._includeList.add(index, vInclude);
+    }
+
+    /**
+     * 
+     * 
+     * @param vKeyGeneratorDef
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addKeyGeneratorDef(
+            final org.exolab.castor.mapping.xml.KeyGeneratorDef vKeyGeneratorDef)
+    throws java.lang.IndexOutOfBoundsException {
+        this._keyGeneratorDefList.add(vKeyGeneratorDef);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vKeyGeneratorDef
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addKeyGeneratorDef(
+            final int index,
+            final org.exolab.castor.mapping.xml.KeyGeneratorDef vKeyGeneratorDef)
+    throws java.lang.IndexOutOfBoundsException {
+        this._keyGeneratorDefList.add(index, vKeyGeneratorDef);
+    }
+
+    /**
+     * Method enumerateClassMapping.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.ClassMapping> enumerateClassMapping(
+    ) {
+        return java.util.Collections.enumeration(this._classMappingList);
+    }
+
+    /**
+     * Method enumerateFieldHandlerDef.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.FieldHandlerDef> enumerateFieldHandlerDef(
+    ) {
+        return java.util.Collections.enumeration(this._fieldHandlerDefList);
+    }
+
+    /**
+     * Method enumerateInclude.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.Include> enumerateInclude(
+    ) {
+        return java.util.Collections.enumeration(this._includeList);
+    }
+
+    /**
+     * Method enumerateKeyGeneratorDef.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.KeyGeneratorDef> enumerateKeyGeneratorDef(
+    ) {
+        return java.util.Collections.enumeration(this._keyGeneratorDefList);
+    }
+
+    /**
+     * Method getClassMapping.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.ClassMapping at the given index
+     */
+    public org.exolab.castor.mapping.xml.ClassMapping getClassMapping(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._classMappingList.size()) {
+            throw new IndexOutOfBoundsException("getClassMapping: Index value '" + index + "' not in range [0.." + (this._classMappingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.ClassMapping) _classMappingList.get(index);
+    }
+
+    /**
+     * Method getClassMapping.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.ClassMapping[] getClassMapping(
+    ) {
+        org.exolab.castor.mapping.xml.ClassMapping[] array = new org.exolab.castor.mapping.xml.ClassMapping[0];
+        return (org.exolab.castor.mapping.xml.ClassMapping[]) this._classMappingList.toArray(array);
+    }
+
+    /**
+     * Method getClassMappingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getClassMappingCount(
+    ) {
+        return this._classMappingList.size();
+    }
+
+    /**
+     * Returns the value of field 'description'.
+     * 
+     * @return the value of field 'Description'.
+     */
+    public java.lang.String getDescription(
+    ) {
+        return this._description;
+    }
+
+    /**
+     * Method getFieldHandlerDef.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.FieldHandlerDef at the given
+     * index
+     */
+    public org.exolab.castor.mapping.xml.FieldHandlerDef getFieldHandlerDef(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._fieldHandlerDefList.size()) {
+            throw new IndexOutOfBoundsException("getFieldHandlerDef: Index value '" + index + "' not in range [0.." + (this._fieldHandlerDefList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.FieldHandlerDef) _fieldHandlerDefList.get(index);
+    }
+
+    /**
+     * Method getFieldHandlerDef.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.FieldHandlerDef[] getFieldHandlerDef(
+    ) {
+        org.exolab.castor.mapping.xml.FieldHandlerDef[] array = new org.exolab.castor.mapping.xml.FieldHandlerDef[0];
+        return (org.exolab.castor.mapping.xml.FieldHandlerDef[]) this._fieldHandlerDefList.toArray(array);
+    }
+
+    /**
+     * Method getFieldHandlerDefCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getFieldHandlerDefCount(
+    ) {
+        return this._fieldHandlerDefList.size();
+    }
+
+    /**
+     * Method getInclude.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.Include at the given index
+     */
+    public org.exolab.castor.mapping.xml.Include getInclude(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._includeList.size()) {
+            throw new IndexOutOfBoundsException("getInclude: Index value '" + index + "' not in range [0.." + (this._includeList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.Include) _includeList.get(index);
+    }
+
+    /**
+     * Method getInclude.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.Include[] getInclude(
+    ) {
+        org.exolab.castor.mapping.xml.Include[] array = new org.exolab.castor.mapping.xml.Include[0];
+        return (org.exolab.castor.mapping.xml.Include[]) this._includeList.toArray(array);
+    }
+
+    /**
+     * Method getIncludeCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getIncludeCount(
+    ) {
+        return this._includeList.size();
+    }
+
+    /**
+     * Method getKeyGeneratorDef.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.KeyGeneratorDef at the given
+     * index
+     */
+    public org.exolab.castor.mapping.xml.KeyGeneratorDef getKeyGeneratorDef(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._keyGeneratorDefList.size()) {
+            throw new IndexOutOfBoundsException("getKeyGeneratorDef: Index value '" + index + "' not in range [0.." + (this._keyGeneratorDefList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.KeyGeneratorDef) _keyGeneratorDefList.get(index);
+    }
+
+    /**
+     * Method getKeyGeneratorDef.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.KeyGeneratorDef[] getKeyGeneratorDef(
+    ) {
+        org.exolab.castor.mapping.xml.KeyGeneratorDef[] array = new org.exolab.castor.mapping.xml.KeyGeneratorDef[0];
+        return (org.exolab.castor.mapping.xml.KeyGeneratorDef[]) this._keyGeneratorDefList.toArray(array);
+    }
+
+    /**
+     * Method getKeyGeneratorDefCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getKeyGeneratorDefCount(
+    ) {
+        return this._keyGeneratorDefList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateClassMapping.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.ClassMapping> iterateClassMapping(
+    ) {
+        return this._classMappingList.iterator();
+    }
+
+    /**
+     * Method iterateFieldHandlerDef.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.FieldHandlerDef> iterateFieldHandlerDef(
+    ) {
+        return this._fieldHandlerDefList.iterator();
+    }
+
+    /**
+     * Method iterateInclude.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.Include> iterateInclude(
+    ) {
+        return this._includeList.iterator();
+    }
+
+    /**
+     * Method iterateKeyGeneratorDef.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.KeyGeneratorDef> iterateKeyGeneratorDef(
+    ) {
+        return this._keyGeneratorDefList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllClassMapping(
+    ) {
+        this._classMappingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllFieldHandlerDef(
+    ) {
+        this._fieldHandlerDefList.clear();
+    }
+
+    /**
+     */
+    public void removeAllInclude(
+    ) {
+        this._includeList.clear();
+    }
+
+    /**
+     */
+    public void removeAllKeyGeneratorDef(
+    ) {
+        this._keyGeneratorDefList.clear();
+    }
+
+    /**
+     * Method removeClassMapping.
+     * 
+     * @param vClassMapping
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeClassMapping(
+            final org.exolab.castor.mapping.xml.ClassMapping vClassMapping) {
+        boolean removed = _classMappingList.remove(vClassMapping);
+        return removed;
+    }
+
+    /**
+     * Method removeClassMappingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.ClassMapping removeClassMappingAt(
+            final int index) {
+        java.lang.Object obj = this._classMappingList.remove(index);
+        return (org.exolab.castor.mapping.xml.ClassMapping) obj;
+    }
+
+    /**
+     * Method removeFieldHandlerDef.
+     * 
+     * @param vFieldHandlerDef
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeFieldHandlerDef(
+            final org.exolab.castor.mapping.xml.FieldHandlerDef vFieldHandlerDef) {
+        boolean removed = _fieldHandlerDefList.remove(vFieldHandlerDef);
+        return removed;
+    }
+
+    /**
+     * Method removeFieldHandlerDefAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.FieldHandlerDef removeFieldHandlerDefAt(
+            final int index) {
+        java.lang.Object obj = this._fieldHandlerDefList.remove(index);
+        return (org.exolab.castor.mapping.xml.FieldHandlerDef) obj;
+    }
+
+    /**
+     * Method removeInclude.
+     * 
+     * @param vInclude
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeInclude(
+            final org.exolab.castor.mapping.xml.Include vInclude) {
+        boolean removed = _includeList.remove(vInclude);
+        return removed;
+    }
+
+    /**
+     * Method removeIncludeAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.Include removeIncludeAt(
+            final int index) {
+        java.lang.Object obj = this._includeList.remove(index);
+        return (org.exolab.castor.mapping.xml.Include) obj;
+    }
+
+    /**
+     * Method removeKeyGeneratorDef.
+     * 
+     * @param vKeyGeneratorDef
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeKeyGeneratorDef(
+            final org.exolab.castor.mapping.xml.KeyGeneratorDef vKeyGeneratorDef) {
+        boolean removed = _keyGeneratorDefList.remove(vKeyGeneratorDef);
+        return removed;
+    }
+
+    /**
+     * Method removeKeyGeneratorDefAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.KeyGeneratorDef removeKeyGeneratorDefAt(
+            final int index) {
+        java.lang.Object obj = this._keyGeneratorDefList.remove(index);
+        return (org.exolab.castor.mapping.xml.KeyGeneratorDef) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vClassMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setClassMapping(
+            final int index,
+            final org.exolab.castor.mapping.xml.ClassMapping vClassMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._classMappingList.size()) {
+            throw new IndexOutOfBoundsException("setClassMapping: Index value '" + index + "' not in range [0.." + (this._classMappingList.size() - 1) + "]");
+        }
+
+        this._classMappingList.set(index, vClassMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param vClassMappingArray
+     */
+    public void setClassMapping(
+            final org.exolab.castor.mapping.xml.ClassMapping[] vClassMappingArray) {
+        //-- copy array
+        _classMappingList.clear();
+
+        for (int i = 0; i < vClassMappingArray.length; i++) {
+                this._classMappingList.add(vClassMappingArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'description'.
+     * 
+     * @param description the value of field 'description'.
+     */
+    public void setDescription(
+            final java.lang.String description) {
+        this._description = description;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vFieldHandlerDef
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setFieldHandlerDef(
+            final int index,
+            final org.exolab.castor.mapping.xml.FieldHandlerDef vFieldHandlerDef)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._fieldHandlerDefList.size()) {
+            throw new IndexOutOfBoundsException("setFieldHandlerDef: Index value '" + index + "' not in range [0.." + (this._fieldHandlerDefList.size() - 1) + "]");
+        }
+
+        this._fieldHandlerDefList.set(index, vFieldHandlerDef);
+    }
+
+    /**
+     * 
+     * 
+     * @param vFieldHandlerDefArray
+     */
+    public void setFieldHandlerDef(
+            final org.exolab.castor.mapping.xml.FieldHandlerDef[] vFieldHandlerDefArray) {
+        //-- copy array
+        _fieldHandlerDefList.clear();
+
+        for (int i = 0; i < vFieldHandlerDefArray.length; i++) {
+                this._fieldHandlerDefList.add(vFieldHandlerDefArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vInclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setInclude(
+            final int index,
+            final org.exolab.castor.mapping.xml.Include vInclude)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._includeList.size()) {
+            throw new IndexOutOfBoundsException("setInclude: Index value '" + index + "' not in range [0.." + (this._includeList.size() - 1) + "]");
+        }
+
+        this._includeList.set(index, vInclude);
+    }
+
+    /**
+     * 
+     * 
+     * @param vIncludeArray
+     */
+    public void setInclude(
+            final org.exolab.castor.mapping.xml.Include[] vIncludeArray) {
+        //-- copy array
+        _includeList.clear();
+
+        for (int i = 0; i < vIncludeArray.length; i++) {
+                this._includeList.add(vIncludeArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vKeyGeneratorDef
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setKeyGeneratorDef(
+            final int index,
+            final org.exolab.castor.mapping.xml.KeyGeneratorDef vKeyGeneratorDef)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._keyGeneratorDefList.size()) {
+            throw new IndexOutOfBoundsException("setKeyGeneratorDef: Index value '" + index + "' not in range [0.." + (this._keyGeneratorDefList.size() - 1) + "]");
+        }
+
+        this._keyGeneratorDefList.set(index, vKeyGeneratorDef);
+    }
+
+    /**
+     * 
+     * 
+     * @param vKeyGeneratorDefArray
+     */
+    public void setKeyGeneratorDef(
+            final org.exolab.castor.mapping.xml.KeyGeneratorDef[] vKeyGeneratorDefArray) {
+        //-- copy array
+        _keyGeneratorDefList.clear();
+
+        for (int i = 0; i < vKeyGeneratorDefArray.length; i++) {
+                this._keyGeneratorDefList.add(vKeyGeneratorDefArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.MappingRoot
+     */
+    public static org.exolab.castor.mapping.xml.MappingRoot unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.MappingRoot) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.MappingRoot.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/Include.java
@@ -0,0 +1,138 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class Include.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Include implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _href.
+     */
+    private java.lang.String _href;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Include() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'href'.
+     * 
+     * @return the value of field 'Href'.
+     */
+    public java.lang.String getHref(
+    ) {
+        return this._href;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'href'.
+     * 
+     * @param href the value of field 'href'.
+     */
+    public void setHref(
+            final java.lang.String href) {
+        this._href = href;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.exolab.castor.mapping.xml.Include
+     */
+    public static org.exolab.castor.mapping.xml.Include unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.Include) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.Include.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/Ldap.java
@@ -0,0 +1,138 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class Ldap.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Ldap implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Ldap() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.exolab.castor.mapping.xml.Ldap
+     */
+    public static org.exolab.castor.mapping.xml.Ldap unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.Ldap) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.Ldap.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/NamedNativeQuery.java
@@ -0,0 +1,381 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class NamedNativeQuery.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class NamedNativeQuery implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _resultClass.
+     */
+    private java.lang.String _resultClass;
+
+    /**
+     * Field _resultSetMapping.
+     */
+    private java.lang.String _resultSetMapping;
+
+    /**
+     * Field _query.
+     */
+    private java.lang.String _query;
+
+    /**
+     * Field _queryHintList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.QueryHint> _queryHintList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public NamedNativeQuery() {
+        super();
+        this._queryHintList = new java.util.ArrayList<org.exolab.castor.mapping.xml.QueryHint>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vQueryHint
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addQueryHint(
+            final org.exolab.castor.mapping.xml.QueryHint vQueryHint)
+    throws java.lang.IndexOutOfBoundsException {
+        this._queryHintList.add(vQueryHint);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vQueryHint
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addQueryHint(
+            final int index,
+            final org.exolab.castor.mapping.xml.QueryHint vQueryHint)
+    throws java.lang.IndexOutOfBoundsException {
+        this._queryHintList.add(index, vQueryHint);
+    }
+
+    /**
+     * Method enumerateQueryHint.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.QueryHint> enumerateQueryHint(
+    ) {
+        return java.util.Collections.enumeration(this._queryHintList);
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'query'.
+     * 
+     * @return the value of field 'Query'.
+     */
+    public java.lang.String getQuery(
+    ) {
+        return this._query;
+    }
+
+    /**
+     * Method getQueryHint.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.QueryHint at the given index
+     */
+    public org.exolab.castor.mapping.xml.QueryHint getQueryHint(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._queryHintList.size()) {
+            throw new IndexOutOfBoundsException("getQueryHint: Index value '" + index + "' not in range [0.." + (this._queryHintList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.QueryHint) _queryHintList.get(index);
+    }
+
+    /**
+     * Method getQueryHint.Returns the contents of the collection
+     * in an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.QueryHint[] getQueryHint(
+    ) {
+        org.exolab.castor.mapping.xml.QueryHint[] array = new org.exolab.castor.mapping.xml.QueryHint[0];
+        return (org.exolab.castor.mapping.xml.QueryHint[]) this._queryHintList.toArray(array);
+    }
+
+    /**
+     * Method getQueryHintCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getQueryHintCount(
+    ) {
+        return this._queryHintList.size();
+    }
+
+    /**
+     * Returns the value of field 'resultClass'.
+     * 
+     * @return the value of field 'ResultClass'.
+     */
+    public java.lang.String getResultClass(
+    ) {
+        return this._resultClass;
+    }
+
+    /**
+     * Returns the value of field 'resultSetMapping'.
+     * 
+     * @return the value of field 'ResultSetMapping'.
+     */
+    public java.lang.String getResultSetMapping(
+    ) {
+        return this._resultSetMapping;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateQueryHint.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.QueryHint> iterateQueryHint(
+    ) {
+        return this._queryHintList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllQueryHint(
+    ) {
+        this._queryHintList.clear();
+    }
+
+    /**
+     * Method removeQueryHint.
+     * 
+     * @param vQueryHint
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeQueryHint(
+            final org.exolab.castor.mapping.xml.QueryHint vQueryHint) {
+        boolean removed = _queryHintList.remove(vQueryHint);
+        return removed;
+    }
+
+    /**
+     * Method removeQueryHintAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.QueryHint removeQueryHintAt(
+            final int index) {
+        java.lang.Object obj = this._queryHintList.remove(index);
+        return (org.exolab.castor.mapping.xml.QueryHint) obj;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'query'.
+     * 
+     * @param query the value of field 'query'.
+     */
+    public void setQuery(
+            final java.lang.String query) {
+        this._query = query;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vQueryHint
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setQueryHint(
+            final int index,
+            final org.exolab.castor.mapping.xml.QueryHint vQueryHint)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._queryHintList.size()) {
+            throw new IndexOutOfBoundsException("setQueryHint: Index value '" + index + "' not in range [0.." + (this._queryHintList.size() - 1) + "]");
+        }
+
+        this._queryHintList.set(index, vQueryHint);
+    }
+
+    /**
+     * 
+     * 
+     * @param vQueryHintArray
+     */
+    public void setQueryHint(
+            final org.exolab.castor.mapping.xml.QueryHint[] vQueryHintArray) {
+        //-- copy array
+        _queryHintList.clear();
+
+        for (int i = 0; i < vQueryHintArray.length; i++) {
+                this._queryHintList.add(vQueryHintArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'resultClass'.
+     * 
+     * @param resultClass the value of field 'resultClass'.
+     */
+    public void setResultClass(
+            final java.lang.String resultClass) {
+        this._resultClass = resultClass;
+    }
+
+    /**
+     * Sets the value of field 'resultSetMapping'.
+     * 
+     * @param resultSetMapping the value of field 'resultSetMapping'
+     */
+    public void setResultSetMapping(
+            final java.lang.String resultSetMapping) {
+        this._resultSetMapping = resultSetMapping;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.NamedNativeQuery
+     */
+    public static org.exolab.castor.mapping.xml.NamedNativeQuery unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.NamedNativeQuery) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.NamedNativeQuery.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/FieldMapping.java
@@ -0,0 +1,930 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * The 'field' element is used to describe the property of a Java
+ * object.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class FieldMapping implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * A required attribute used to identify the name of the
+     * property. 
+     *  
+     */
+    private java.lang.String _name;
+
+    /**
+     * An optional attribute used to identify the type of the
+     * property.
+     *  
+     */
+    private java.lang.String _type;
+
+    /**
+     * Field _required.
+     */
+    private boolean _required = false;
+
+    /**
+     * keeps track of state for field: _required
+     */
+    private boolean _has_required;
+
+    /**
+     * Field _transient.
+     */
+    private boolean _transient = false;
+
+    /**
+     * keeps track of state for field: _transient
+     */
+    private boolean _has_transient;
+
+    /**
+     * Field _nillable.
+     */
+    private boolean _nillable = false;
+
+    /**
+     * keeps track of state for field: _nillable
+     */
+    private boolean _has_nillable;
+
+    /**
+     * Field _direct.
+     */
+    private boolean _direct = false;
+
+    /**
+     * keeps track of state for field: _direct
+     */
+    private boolean _has_direct;
+
+    /**
+     * Field _lazy.
+     */
+    private boolean _lazy = false;
+
+    /**
+     * keeps track of state for field: _lazy
+     */
+    private boolean _has_lazy;
+
+    /**
+     * Indicates whether the field should be treated as a
+     * container, 
+     *  i.e. only it's fields should be persisted, but not the
+     * containing 
+     *  class itself. In this case, the container attribute should
+     *  be set to true (supported in Castor XML only).
+     *  
+     */
+    private boolean _container;
+
+    /**
+     * keeps track of state for field: _container
+     */
+    private boolean _has_container;
+
+    /**
+     * Field _getMethod.
+     */
+    private java.lang.String _getMethod;
+
+    /**
+     * Field _hasMethod.
+     */
+    private java.lang.String _hasMethod;
+
+    /**
+     * Field _setMethod.
+     */
+    private java.lang.String _setMethod;
+
+    /**
+     * Field _createMethod.
+     */
+    private java.lang.String _createMethod;
+
+    /**
+     * Field _handler.
+     */
+    private java.lang.String _handler;
+
+    /**
+     * An optional attribute used to specify the type of the
+     * collection, if 
+     *  the property is multi-valued.
+     *  
+     */
+    private org.exolab.castor.mapping.xml.types.FieldMappingCollectionType _collection;
+
+    /**
+     * Field _comparator.
+     */
+    private java.lang.String _comparator;
+
+    /**
+     * Field _identity.
+     */
+    private boolean _identity = false;
+
+    /**
+     * keeps track of state for field: _identity
+     */
+    private boolean _has_identity;
+
+    /**
+     * Field _description.
+     */
+    private java.lang.String _description;
+
+    /**
+     * The 'sql' element is used to store information about the
+     * database 
+     *  column to which a Java object is mapped to.
+     *  
+     */
+    private org.exolab.castor.mapping.xml.Sql _sql;
+
+    /**
+     * The 'bind-xml' element is used for specifying XML specific
+     * databinding
+     *  properties and behavior for a specific field. 'bind-xml'
+     * may only appear
+     *  as a child of a 'field' element.
+     *  
+     */
+    private org.exolab.castor.mapping.xml.BindXml _bindXml;
+
+    /**
+     * Field _ldap.
+     */
+    private org.exolab.castor.mapping.xml.Ldap _ldap;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldMapping() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     */
+    public void deleteContainer(
+    ) {
+        this._has_container= false;
+    }
+
+    /**
+     */
+    public void deleteDirect(
+    ) {
+        this._has_direct= false;
+    }
+
+    /**
+     */
+    public void deleteIdentity(
+    ) {
+        this._has_identity= false;
+    }
+
+    /**
+     */
+    public void deleteLazy(
+    ) {
+        this._has_lazy= false;
+    }
+
+    /**
+     */
+    public void deleteNillable(
+    ) {
+        this._has_nillable= false;
+    }
+
+    /**
+     */
+    public void deleteRequired(
+    ) {
+        this._has_required= false;
+    }
+
+    /**
+     */
+    public void deleteTransient(
+    ) {
+        this._has_transient= false;
+    }
+
+    /**
+     * Returns the value of field 'bindXml'. The field 'bindXml'
+     * has the following description: The 'bind-xml' element is
+     * used for specifying XML specific databinding
+     *  properties and behavior for a specific field. 'bind-xml'
+     * may only appear
+     *  as a child of a 'field' element.
+     *  
+     * 
+     * @return the value of field 'BindXml'.
+     */
+    public org.exolab.castor.mapping.xml.BindXml getBindXml(
+    ) {
+        return this._bindXml;
+    }
+
+    /**
+     * Returns the value of field 'collection'. The field
+     * 'collection' has the following description: An optional
+     * attribute used to specify the type of the collection, if 
+     *  the property is multi-valued.
+     *  
+     * 
+     * @return the value of field 'Collection'.
+     */
+    public org.exolab.castor.mapping.xml.types.FieldMappingCollectionType getCollection(
+    ) {
+        return this._collection;
+    }
+
+    /**
+     * Returns the value of field 'comparator'.
+     * 
+     * @return the value of field 'Comparator'.
+     */
+    public java.lang.String getComparator(
+    ) {
+        return this._comparator;
+    }
+
+    /**
+     * Returns the value of field 'container'. The field
+     * 'container' has the following description: Indicates whether
+     * the field should be treated as a container, 
+     *  i.e. only it's fields should be persisted, but not the
+     * containing 
+     *  class itself. In this case, the container attribute should
+     *  be set to true (supported in Castor XML only).
+     *  
+     * 
+     * @return the value of field 'Container'.
+     */
+    public boolean getContainer(
+    ) {
+        return this._container;
+    }
+
+    /**
+     * Returns the value of field 'createMethod'.
+     * 
+     * @return the value of field 'CreateMethod'.
+     */
+    public java.lang.String getCreateMethod(
+    ) {
+        return this._createMethod;
+    }
+
+    /**
+     * Returns the value of field 'description'.
+     * 
+     * @return the value of field 'Description'.
+     */
+    public java.lang.String getDescription(
+    ) {
+        return this._description;
+    }
+
+    /**
+     * Returns the value of field 'direct'.
+     * 
+     * @return the value of field 'Direct'.
+     */
+    public boolean getDirect(
+    ) {
+        return this._direct;
+    }
+
+    /**
+     * Returns the value of field 'getMethod'.
+     * 
+     * @return the value of field 'GetMethod'.
+     */
+    public java.lang.String getGetMethod(
+    ) {
+        return this._getMethod;
+    }
+
+    /**
+     * Returns the value of field 'handler'.
+     * 
+     * @return the value of field 'Handler'.
+     */
+    public java.lang.String getHandler(
+    ) {
+        return this._handler;
+    }
+
+    /**
+     * Returns the value of field 'hasMethod'.
+     * 
+     * @return the value of field 'HasMethod'.
+     */
+    public java.lang.String getHasMethod(
+    ) {
+        return this._hasMethod;
+    }
+
+    /**
+     * Returns the value of field 'identity'.
+     * 
+     * @return the value of field 'Identity'.
+     */
+    public boolean getIdentity(
+    ) {
+        return this._identity;
+    }
+
+    /**
+     * Returns the value of field 'lazy'.
+     * 
+     * @return the value of field 'Lazy'.
+     */
+    public boolean getLazy(
+    ) {
+        return this._lazy;
+    }
+
+    /**
+     * Returns the value of field 'ldap'.
+     * 
+     * @return the value of field 'Ldap'.
+     */
+    public org.exolab.castor.mapping.xml.Ldap getLdap(
+    ) {
+        return this._ldap;
+    }
+
+    /**
+     * Returns the value of field 'name'. The field 'name' has the
+     * following description: A required attribute used to identify
+     * the name of the property. 
+     *  
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'nillable'.
+     * 
+     * @return the value of field 'Nillable'.
+     */
+    public boolean getNillable(
+    ) {
+        return this._nillable;
+    }
+
+    /**
+     * Returns the value of field 'required'.
+     * 
+     * @return the value of field 'Required'.
+     */
+    public boolean getRequired(
+    ) {
+        return this._required;
+    }
+
+    /**
+     * Returns the value of field 'setMethod'.
+     * 
+     * @return the value of field 'SetMethod'.
+     */
+    public java.lang.String getSetMethod(
+    ) {
+        return this._setMethod;
+    }
+
+    /**
+     * Returns the value of field 'sql'. The field 'sql' has the
+     * following description: The 'sql' element is used to store
+     * information about the database 
+     *  column to which a Java object is mapped to.
+     *  
+     * 
+     * @return the value of field 'Sql'.
+     */
+    public org.exolab.castor.mapping.xml.Sql getSql(
+    ) {
+        return this._sql;
+    }
+
+    /**
+     * Returns the value of field 'transient'.
+     * 
+     * @return the value of field 'Transient'.
+     */
+    public boolean getTransient(
+    ) {
+        return this._transient;
+    }
+
+    /**
+     * Returns the value of field 'type'. The field 'type' has the
+     * following description: An optional attribute used to
+     * identify the type of the property.
+     *  
+     * 
+     * @return the value of field 'Type'.
+     */
+    public java.lang.String getType(
+    ) {
+        return this._type;
+    }
+
+    /**
+     * Method hasContainer.
+     * 
+     * @return true if at least one Container has been added
+     */
+    public boolean hasContainer(
+    ) {
+        return this._has_container;
+    }
+
+    /**
+     * Method hasDirect.
+     * 
+     * @return true if at least one Direct has been added
+     */
+    public boolean hasDirect(
+    ) {
+        return this._has_direct;
+    }
+
+    /**
+     * Method hasIdentity.
+     * 
+     * @return true if at least one Identity has been added
+     */
+    public boolean hasIdentity(
+    ) {
+        return this._has_identity;
+    }
+
+    /**
+     * Method hasLazy.
+     * 
+     * @return true if at least one Lazy has been added
+     */
+    public boolean hasLazy(
+    ) {
+        return this._has_lazy;
+    }
+
+    /**
+     * Method hasNillable.
+     * 
+     * @return true if at least one Nillable has been added
+     */
+    public boolean hasNillable(
+    ) {
+        return this._has_nillable;
+    }
+
+    /**
+     * Method hasRequired.
+     * 
+     * @return true if at least one Required has been added
+     */
+    public boolean hasRequired(
+    ) {
+        return this._has_required;
+    }
+
+    /**
+     * Method hasTransient.
+     * 
+     * @return true if at least one Transient has been added
+     */
+    public boolean hasTransient(
+    ) {
+        return this._has_transient;
+    }
+
+    /**
+     * Returns the value of field 'container'. The field
+     * 'container' has the following description: Indicates whether
+     * the field should be treated as a container, 
+     *  i.e. only it's fields should be persisted, but not the
+     * containing 
+     *  class itself. In this case, the container attribute should
+     *  be set to true (supported in Castor XML only).
+     *  
+     * 
+     * @return the value of field 'Container'.
+     */
+    public boolean isContainer(
+    ) {
+        return this._container;
+    }
+
+    /**
+     * Returns the value of field 'direct'.
+     * 
+     * @return the value of field 'Direct'.
+     */
+    public boolean isDirect(
+    ) {
+        return this._direct;
+    }
+
+    /**
+     * Returns the value of field 'identity'.
+     * 
+     * @return the value of field 'Identity'.
+     */
+    public boolean isIdentity(
+    ) {
+        return this._identity;
+    }
+
+    /**
+     * Returns the value of field 'lazy'.
+     * 
+     * @return the value of field 'Lazy'.
+     */
+    public boolean isLazy(
+    ) {
+        return this._lazy;
+    }
+
+    /**
+     * Returns the value of field 'nillable'.
+     * 
+     * @return the value of field 'Nillable'.
+     */
+    public boolean isNillable(
+    ) {
+        return this._nillable;
+    }
+
+    /**
+     * Returns the value of field 'required'.
+     * 
+     * @return the value of field 'Required'.
+     */
+    public boolean isRequired(
+    ) {
+        return this._required;
+    }
+
+    /**
+     * Returns the value of field 'transient'.
+     * 
+     * @return the value of field 'Transient'.
+     */
+    public boolean isTransient(
+    ) {
+        return this._transient;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'bindXml'. The field 'bindXml' has
+     * the following description: The 'bind-xml' element is used
+     * for specifying XML specific databinding
+     *  properties and behavior for a specific field. 'bind-xml'
+     * may only appear
+     *  as a child of a 'field' element.
+     *  
+     * 
+     * @param bindXml the value of field 'bindXml'.
+     */
+    public void setBindXml(
+            final org.exolab.castor.mapping.xml.BindXml bindXml) {
+        this._bindXml = bindXml;
+    }
+
+    /**
+     * Sets the value of field 'collection'. The field 'collection'
+     * has the following description: An optional attribute used to
+     * specify the type of the collection, if 
+     *  the property is multi-valued.
+     *  
+     * 
+     * @param collection the value of field 'collection'.
+     */
+    public void setCollection(
+            final org.exolab.castor.mapping.xml.types.FieldMappingCollectionType collection) {
+        this._collection = collection;
+    }
+
+    /**
+     * Sets the value of field 'comparator'.
+     * 
+     * @param comparator the value of field 'comparator'.
+     */
+    public void setComparator(
+            final java.lang.String comparator) {
+        this._comparator = comparator;
+    }
+
+    /**
+     * Sets the value of field 'container'. The field 'container'
+     * has the following description: Indicates whether the field
+     * should be treated as a container, 
+     *  i.e. only it's fields should be persisted, but not the
+     * containing 
+     *  class itself. In this case, the container attribute should
+     *  be set to true (supported in Castor XML only).
+     *  
+     * 
+     * @param container the value of field 'container'.
+     */
+    public void setContainer(
+            final boolean container) {
+        this._container = container;
+        this._has_container = true;
+    }
+
+    /**
+     * Sets the value of field 'createMethod'.
+     * 
+     * @param createMethod the value of field 'createMethod'.
+     */
+    public void setCreateMethod(
+            final java.lang.String createMethod) {
+        this._createMethod = createMethod;
+    }
+
+    /**
+     * Sets the value of field 'description'.
+     * 
+     * @param description the value of field 'description'.
+     */
+    public void setDescription(
+            final java.lang.String description) {
+        this._description = description;
+    }
+
+    /**
+     * Sets the value of field 'direct'.
+     * 
+     * @param direct the value of field 'direct'.
+     */
+    public void setDirect(
+            final boolean direct) {
+        this._direct = direct;
+        this._has_direct = true;
+    }
+
+    /**
+     * Sets the value of field 'getMethod'.
+     * 
+     * @param getMethod the value of field 'getMethod'.
+     */
+    public void setGetMethod(
+            final java.lang.String getMethod) {
+        this._getMethod = getMethod;
+    }
+
+    /**
+     * Sets the value of field 'handler'.
+     * 
+     * @param handler the value of field 'handler'.
+     */
+    public void setHandler(
+            final java.lang.String handler) {
+        this._handler = handler;
+    }
+
+    /**
+     * Sets the value of field 'hasMethod'.
+     * 
+     * @param hasMethod the value of field 'hasMethod'.
+     */
+    public void setHasMethod(
+            final java.lang.String hasMethod) {
+        this._hasMethod = hasMethod;
+    }
+
+    /**
+     * Sets the value of field 'identity'.
+     * 
+     * @param identity the value of field 'identity'.
+     */
+    public void setIdentity(
+            final boolean identity) {
+        this._identity = identity;
+        this._has_identity = true;
+    }
+
+    /**
+     * Sets the value of field 'lazy'.
+     * 
+     * @param lazy the value of field 'lazy'.
+     */
+    public void setLazy(
+            final boolean lazy) {
+        this._lazy = lazy;
+        this._has_lazy = true;
+    }
+
+    /**
+     * Sets the value of field 'ldap'.
+     * 
+     * @param ldap the value of field 'ldap'.
+     */
+    public void setLdap(
+            final org.exolab.castor.mapping.xml.Ldap ldap) {
+        this._ldap = ldap;
+    }
+
+    /**
+     * Sets the value of field 'name'. The field 'name' has the
+     * following description: A required attribute used to identify
+     * the name of the property. 
+     *  
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'nillable'.
+     * 
+     * @param nillable the value of field 'nillable'.
+     */
+    public void setNillable(
+            final boolean nillable) {
+        this._nillable = nillable;
+        this._has_nillable = true;
+    }
+
+    /**
+     * Sets the value of field 'required'.
+     * 
+     * @param required the value of field 'required'.
+     */
+    public void setRequired(
+            final boolean required) {
+        this._required = required;
+        this._has_required = true;
+    }
+
+    /**
+     * Sets the value of field 'setMethod'.
+     * 
+     * @param setMethod the value of field 'setMethod'.
+     */
+    public void setSetMethod(
+            final java.lang.String setMethod) {
+        this._setMethod = setMethod;
+    }
+
+    /**
+     * Sets the value of field 'sql'. The field 'sql' has the
+     * following description: The 'sql' element is used to store
+     * information about the database 
+     *  column to which a Java object is mapped to.
+     *  
+     * 
+     * @param sql the value of field 'sql'.
+     */
+    public void setSql(
+            final org.exolab.castor.mapping.xml.Sql sql) {
+        this._sql = sql;
+    }
+
+    /**
+     * Sets the value of field 'transient'.
+     * 
+     * @param _transient
+     * @param transient the value of field 'transient'.
+     */
+    public void setTransient(
+            final boolean _transient) {
+        this._transient = _transient;
+        this._has_transient = true;
+    }
+
+    /**
+     * Sets the value of field 'type'. The field 'type' has the
+     * following description: An optional attribute used to
+     * identify the type of the property.
+     *  
+     * 
+     * @param type the value of field 'type'.
+     */
+    public void setType(
+            final java.lang.String type) {
+        this._type = type;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.FieldMapping
+     */
+    public static org.exolab.castor.mapping.xml.FieldMapping unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.FieldMapping) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.FieldMapping.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/Property.java
@@ -0,0 +1,110 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class Property.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Property extends PropertyType 
+implements java.io.Serializable
+{
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Property() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.exolab.castor.mapping.xml.Propert
+     */
+    public static org.exolab.castor.mapping.xml.Property unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.Property) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.Property.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/QueryHint.java
@@ -0,0 +1,164 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class QueryHint.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class QueryHint implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _value.
+     */
+    private java.lang.String _value;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public QueryHint() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'value'.
+     * 
+     * @return the value of field 'Value'.
+     */
+    public java.lang.String getValue(
+    ) {
+        return this._value;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'value'.
+     * 
+     * @param value the value of field 'value'.
+     */
+    public void setValue(
+            final java.lang.String value) {
+        this._value = value;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.QueryHint
+     */
+    public static org.exolab.castor.mapping.xml.QueryHint unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.QueryHint) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.QueryHint.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/Param.java
@@ -0,0 +1,163 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class Param.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Param implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _value.
+     */
+    private java.lang.String _value;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Param() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'value'.
+     * 
+     * @return the value of field 'Value'.
+     */
+    public java.lang.String getValue(
+    ) {
+        return this._value;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'value'.
+     * 
+     * @param value the value of field 'value'.
+     */
+    public void setValue(
+            final java.lang.String value) {
+        this._value = value;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.exolab.castor.mapping.xml.Param
+     */
+    public static org.exolab.castor.mapping.xml.Param unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.Param) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.Param.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/ClassMapping.java
@@ -0,0 +1,1073 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * The 'class' element is used to store information about mapping
+ * of a class.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class ClassMapping implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Specifies the fully qualified package name of the Java
+     * object needed to be mapped.
+     *  
+     */
+    private java.lang.String _name;
+
+    /**
+     * An optional attribute to specify the extension relationship 
+     *  between objects. Used only if mapping of the another object
+     * 
+     *  is provided.
+     *  
+     */
+    private java.lang.Object _extends;
+
+    /**
+     * An optional attribute to specify that one object depends on 
+     *  another object.
+     *  
+     */
+    private java.lang.Object _depends;
+
+    /**
+     * An optional attribute for specifying the unique
+     * identificator 
+     *  of the object within the persistence storage. 
+     *  
+     */
+    private java.util.List<java.lang.String> _identity;
+
+    /**
+     * Field _access.
+     */
+    private org.exolab.castor.mapping.xml.types.ClassMappingAccessType _access = org.exolab.castor.mapping.xml.types.ClassMappingAccessType.fromValue("shared");
+
+    /**
+     * Field _keyGenerator.
+     */
+    private java.lang.String _keyGenerator;
+
+    /**
+     * Specifies whether Castor should use reflection to establish
+     * XML data 
+     *  binding information at startup time for those fields that
+     * are not
+     *  mapped explicitly.
+     *  
+     */
+    private boolean _autoComplete = false;
+
+    /**
+     * keeps track of state for field: _autoComplete
+     */
+    private boolean _has_autoComplete;
+
+    /**
+     * Field _verifyConstructable.
+     */
+    private boolean _verifyConstructable = true;
+
+    /**
+     * keeps track of state for field: _verifyConstructable
+     */
+    private boolean _has_verifyConstructable;
+
+    /**
+     * If set to the name of a mapped field, this field will be
+     * used for check 
+     *  on object modifications during transactions (Castor JDO
+     * only).
+     *  
+     */
+    private java.lang.String _version;
+
+    /**
+     * Field _description.
+     */
+    private java.lang.String _description;
+
+    /**
+     * Field _cacheTypeMapping.
+     */
+    private org.exolab.castor.mapping.xml.CacheTypeMapping _cacheTypeMapping;
+
+    /**
+     * The 'map-to' element is used for specifying the name of the
+     * item 
+     *  that should be associated with the given Java object.
+     *  
+     */
+    private org.exolab.castor.mapping.xml.MapTo _mapTo;
+
+    /**
+     * Field _namedQueryList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.NamedQuery> _namedQueryList;
+
+    /**
+     * Field _namedNativeQueryList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.NamedNativeQuery> _namedNativeQueryList;
+
+    /**
+     * Field _classChoice.
+     */
+    private org.exolab.castor.mapping.xml.ClassChoice _classChoice;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassMapping() {
+        super();
+        this._identity = new java.util.ArrayList<java.lang.String>();
+        setAccess(org.exolab.castor.mapping.xml.types.ClassMappingAccessType.fromValue("shared"));
+        this._namedQueryList = new java.util.ArrayList<org.exolab.castor.mapping.xml.NamedQuery>();
+        this._namedNativeQueryList = new java.util.ArrayList<org.exolab.castor.mapping.xml.NamedNativeQuery>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vIdentity
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addIdentity(
+            final java.lang.String vIdentity)
+    throws java.lang.IndexOutOfBoundsException {
+        this._identity.add(vIdentity);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vIdentity
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addIdentity(
+            final int index,
+            final java.lang.String vIdentity)
+    throws java.lang.IndexOutOfBoundsException {
+        this._identity.add(index, vIdentity);
+    }
+
+    /**
+     * 
+     * 
+     * @param vNamedNativeQuery
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addNamedNativeQuery(
+            final org.exolab.castor.mapping.xml.NamedNativeQuery vNamedNativeQuery)
+    throws java.lang.IndexOutOfBoundsException {
+        this._namedNativeQueryList.add(vNamedNativeQuery);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vNamedNativeQuery
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addNamedNativeQuery(
+            final int index,
+            final org.exolab.castor.mapping.xml.NamedNativeQuery vNamedNativeQuery)
+    throws java.lang.IndexOutOfBoundsException {
+        this._namedNativeQueryList.add(index, vNamedNativeQuery);
+    }
+
+    /**
+     * 
+     * 
+     * @param vNamedQuery
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addNamedQuery(
+            final org.exolab.castor.mapping.xml.NamedQuery vNamedQuery)
+    throws java.lang.IndexOutOfBoundsException {
+        this._namedQueryList.add(vNamedQuery);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vNamedQuery
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addNamedQuery(
+            final int index,
+            final org.exolab.castor.mapping.xml.NamedQuery vNamedQuery)
+    throws java.lang.IndexOutOfBoundsException {
+        this._namedQueryList.add(index, vNamedQuery);
+    }
+
+    /**
+     */
+    public void deleteAutoComplete(
+    ) {
+        this._has_autoComplete= false;
+    }
+
+    /**
+     */
+    public void deleteVerifyConstructable(
+    ) {
+        this._has_verifyConstructable= false;
+    }
+
+    /**
+     * Method enumerateIdentity.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends java.lang.String> enumerateIdentity(
+    ) {
+        return java.util.Collections.enumeration(this._identity);
+    }
+
+    /**
+     * Method enumerateNamedNativeQuery.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.NamedNativeQuery> enumerateNamedNativeQuery(
+    ) {
+        return java.util.Collections.enumeration(this._namedNativeQueryList);
+    }
+
+    /**
+     * Method enumerateNamedQuery.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.NamedQuery> enumerateNamedQuery(
+    ) {
+        return java.util.Collections.enumeration(this._namedQueryList);
+    }
+
+    /**
+     * Returns the value of field 'access'.
+     * 
+     * @return the value of field 'Access'.
+     */
+    public org.exolab.castor.mapping.xml.types.ClassMappingAccessType getAccess(
+    ) {
+        return this._access;
+    }
+
+    /**
+     * Returns the value of field 'autoComplete'. The field
+     * 'autoComplete' has the following description: Specifies
+     * whether Castor should use reflection to establish XML data 
+     *  binding information at startup time for those fields that
+     * are not
+     *  mapped explicitly.
+     *  
+     * 
+     * @return the value of field 'AutoComplete'.
+     */
+    public boolean getAutoComplete(
+    ) {
+        return this._autoComplete;
+    }
+
+    /**
+     * Returns the value of field 'cacheTypeMapping'.
+     * 
+     * @return the value of field 'CacheTypeMapping'.
+     */
+    public org.exolab.castor.mapping.xml.CacheTypeMapping getCacheTypeMapping(
+    ) {
+        return this._cacheTypeMapping;
+    }
+
+    /**
+     * Returns the value of field 'classChoice'.
+     * 
+     * @return the value of field 'ClassChoice'.
+     */
+    public org.exolab.castor.mapping.xml.ClassChoice getClassChoice(
+    ) {
+        return this._classChoice;
+    }
+
+    /**
+     * Returns the value of field 'depends'. The field 'depends'
+     * has the following description: An optional attribute to
+     * specify that one object depends on 
+     *  another object.
+     *  
+     * 
+     * @return the value of field 'Depends'.
+     */
+    public java.lang.Object getDepends(
+    ) {
+        return this._depends;
+    }
+
+    /**
+     * Returns the value of field 'description'.
+     * 
+     * @return the value of field 'Description'.
+     */
+    public java.lang.String getDescription(
+    ) {
+        return this._description;
+    }
+
+    /**
+     * Returns the value of field 'extends'. The field 'extends'
+     * has the following description: An optional attribute to
+     * specify the extension relationship 
+     *  between objects. Used only if mapping of the another object
+     * 
+     *  is provided.
+     *  
+     * 
+     * @return the value of field 'Extends'.
+     */
+    public java.lang.Object getExtends(
+    ) {
+        return this._extends;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the java.lang.String at the given index
+     */
+    public java.lang.String getIdentity(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._identity.size()) {
+            throw new IndexOutOfBoundsException("getIdentity: Index value '" + index + "' not in range [0.." + (this._identity.size() - 1) + "]");
+        }
+
+        return (java.lang.String) _identity.get(index);
+    }
+
+    /**
+     * Method getIdentity.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public java.lang.String[] getIdentity(
+    ) {
+        java.lang.String[] array = new java.lang.String[0];
+        return (java.lang.String[]) this._identity.toArray(array);
+    }
+
+    /**
+     * Method getIdentityCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getIdentityCount(
+    ) {
+        return this._identity.size();
+    }
+
+    /**
+     * Returns the value of field 'keyGenerator'.
+     * 
+     * @return the value of field 'KeyGenerator'.
+     */
+    public java.lang.String getKeyGenerator(
+    ) {
+        return this._keyGenerator;
+    }
+
+    /**
+     * Returns the value of field 'mapTo'. The field 'mapTo' has
+     * the following description: The 'map-to' element is used for
+     * specifying the name of the item 
+     *  that should be associated with the given Java object.
+     *  
+     * 
+     * @return the value of field 'MapTo'.
+     */
+    public org.exolab.castor.mapping.xml.MapTo getMapTo(
+    ) {
+        return this._mapTo;
+    }
+
+    /**
+     * Returns the value of field 'name'. The field 'name' has the
+     * following description: Specifies the fully qualified package
+     * name of the Java object needed to be mapped.
+     *  
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method getNamedNativeQuery.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.NamedNativeQuery at the given
+     * index
+     */
+    public org.exolab.castor.mapping.xml.NamedNativeQuery getNamedNativeQuery(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._namedNativeQueryList.size()) {
+            throw new IndexOutOfBoundsException("getNamedNativeQuery: Index value '" + index + "' not in range [0.." + (this._namedNativeQueryList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.NamedNativeQuery) _namedNativeQueryList.get(index);
+    }
+
+    /**
+     * Method getNamedNativeQuery.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.NamedNativeQuery[] getNamedNativeQuery(
+    ) {
+        org.exolab.castor.mapping.xml.NamedNativeQuery[] array = new org.exolab.castor.mapping.xml.NamedNativeQuery[0];
+        return (org.exolab.castor.mapping.xml.NamedNativeQuery[]) this._namedNativeQueryList.toArray(array);
+    }
+
+    /**
+     * Method getNamedNativeQueryCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getNamedNativeQueryCount(
+    ) {
+        return this._namedNativeQueryList.size();
+    }
+
+    /**
+     * Method getNamedQuery.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.NamedQuery at the given index
+     */
+    public org.exolab.castor.mapping.xml.NamedQuery getNamedQuery(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._namedQueryList.size()) {
+            throw new IndexOutOfBoundsException("getNamedQuery: Index value '" + index + "' not in range [0.." + (this._namedQueryList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.NamedQuery) _namedQueryList.get(index);
+    }
+
+    /**
+     * Method getNamedQuery.Returns the contents of the collection
+     * in an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.NamedQuery[] getNamedQuery(
+    ) {
+        org.exolab.castor.mapping.xml.NamedQuery[] array = new org.exolab.castor.mapping.xml.NamedQuery[0];
+        return (org.exolab.castor.mapping.xml.NamedQuery[]) this._namedQueryList.toArray(array);
+    }
+
+    /**
+     * Method getNamedQueryCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getNamedQueryCount(
+    ) {
+        return this._namedQueryList.size();
+    }
+
+    /**
+     * Returns the value of field 'verifyConstructable'.
+     * 
+     * @return the value of field 'VerifyConstructable'.
+     */
+    public boolean getVerifyConstructable(
+    ) {
+        return this._verifyConstructable;
+    }
+
+    /**
+     * Returns the value of field 'version'. The field 'version'
+     * has the following description: If set to the name of a
+     * mapped field, this field will be used for check 
+     *  on object modifications during transactions (Castor JDO
+     * only).
+     *  
+     * 
+     * @return the value of field 'Version'.
+     */
+    public java.lang.String getVersion(
+    ) {
+        return this._version;
+    }
+
+    /**
+     * Method hasAutoComplete.
+     * 
+     * @return true if at least one AutoComplete has been added
+     */
+    public boolean hasAutoComplete(
+    ) {
+        return this._has_autoComplete;
+    }
+
+    /**
+     * Method hasVerifyConstructable.
+     * 
+     * @return true if at least one VerifyConstructable has been
+     * added
+     */
+    public boolean hasVerifyConstructable(
+    ) {
+        return this._has_verifyConstructable;
+    }
+
+    /**
+     * Returns the value of field 'autoComplete'. The field
+     * 'autoComplete' has the following description: Specifies
+     * whether Castor should use reflection to establish XML data 
+     *  binding information at startup time for those fields that
+     * are not
+     *  mapped explicitly.
+     *  
+     * 
+     * @return the value of field 'AutoComplete'.
+     */
+    public boolean isAutoComplete(
+    ) {
+        return this._autoComplete;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Returns the value of field 'verifyConstructable'.
+     * 
+     * @return the value of field 'VerifyConstructable'.
+     */
+    public boolean isVerifyConstructable(
+    ) {
+        return this._verifyConstructable;
+    }
+
+    /**
+     * Method iterateIdentity.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends java.lang.String> iterateIdentity(
+    ) {
+        return this._identity.iterator();
+    }
+
+    /**
+     * Method iterateNamedNativeQuery.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.NamedNativeQuery> iterateNamedNativeQuery(
+    ) {
+        return this._namedNativeQueryList.iterator();
+    }
+
+    /**
+     * Method iterateNamedQuery.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.NamedQuery> iterateNamedQuery(
+    ) {
+        return this._namedQueryList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllIdentity(
+    ) {
+        this._identity.clear();
+    }
+
+    /**
+     */
+    public void removeAllNamedNativeQuery(
+    ) {
+        this._namedNativeQueryList.clear();
+    }
+
+    /**
+     */
+    public void removeAllNamedQuery(
+    ) {
+        this._namedQueryList.clear();
+    }
+
+    /**
+     * Method removeIdentity.
+     * 
+     * @param vIdentity
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeIdentity(
+            final java.lang.String vIdentity) {
+        boolean removed = _identity.remove(vIdentity);
+        return removed;
+    }
+
+    /**
+     * Method removeIdentityAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public java.lang.String removeIdentityAt(
+            final int index) {
+        java.lang.Object obj = this._identity.remove(index);
+        return (java.lang.String) obj;
+    }
+
+    /**
+     * Method removeNamedNativeQuery.
+     * 
+     * @param vNamedNativeQuery
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeNamedNativeQuery(
+            final org.exolab.castor.mapping.xml.NamedNativeQuery vNamedNativeQuery) {
+        boolean removed = _namedNativeQueryList.remove(vNamedNativeQuery);
+        return removed;
+    }
+
+    /**
+     * Method removeNamedNativeQueryAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.NamedNativeQuery removeNamedNativeQueryAt(
+            final int index) {
+        java.lang.Object obj = this._namedNativeQueryList.remove(index);
+        return (org.exolab.castor.mapping.xml.NamedNativeQuery) obj;
+    }
+
+    /**
+     * Method removeNamedQuery.
+     * 
+     * @param vNamedQuery
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeNamedQuery(
+            final org.exolab.castor.mapping.xml.NamedQuery vNamedQuery) {
+        boolean removed = _namedQueryList.remove(vNamedQuery);
+        return removed;
+    }
+
+    /**
+     * Method removeNamedQueryAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.NamedQuery removeNamedQueryAt(
+            final int index) {
+        java.lang.Object obj = this._namedQueryList.remove(index);
+        return (org.exolab.castor.mapping.xml.NamedQuery) obj;
+    }
+
+    /**
+     * Sets the value of field 'access'.
+     * 
+     * @param access the value of field 'access'.
+     */
+    public void setAccess(
+            final org.exolab.castor.mapping.xml.types.ClassMappingAccessType access) {
+        this._access = access;
+    }
+
+    /**
+     * Sets the value of field 'autoComplete'. The field
+     * 'autoComplete' has the following description: Specifies
+     * whether Castor should use reflection to establish XML data 
+     *  binding information at startup time for those fields that
+     * are not
+     *  mapped explicitly.
+     *  
+     * 
+     * @param autoComplete the value of field 'autoComplete'.
+     */
+    public void setAutoComplete(
+            final boolean autoComplete) {
+        this._autoComplete = autoComplete;
+        this._has_autoComplete = true;
+    }
+
+    /**
+     * Sets the value of field 'cacheTypeMapping'.
+     * 
+     * @param cacheTypeMapping the value of field 'cacheTypeMapping'
+     */
+    public void setCacheTypeMapping(
+            final org.exolab.castor.mapping.xml.CacheTypeMapping cacheTypeMapping) {
+        this._cacheTypeMapping = cacheTypeMapping;
+    }
+
+    /**
+     * Sets the value of field 'classChoice'.
+     * 
+     * @param classChoice the value of field 'classChoice'.
+     */
+    public void setClassChoice(
+            final org.exolab.castor.mapping.xml.ClassChoice classChoice) {
+        this._classChoice = classChoice;
+    }
+
+    /**
+     * Sets the value of field 'depends'. The field 'depends' has
+     * the following description: An optional attribute to specify
+     * that one object depends on 
+     *  another object.
+     *  
+     * 
+     * @param depends the value of field 'depends'.
+     */
+    public void setDepends(
+            final java.lang.Object depends) {
+        this._depends = depends;
+    }
+
+    /**
+     * Sets the value of field 'description'.
+     * 
+     * @param description the value of field 'description'.
+     */
+    public void setDescription(
+            final java.lang.String description) {
+        this._description = description;
+    }
+
+    /**
+     * Sets the value of field 'extends'. The field 'extends' has
+     * the following description: An optional attribute to specify
+     * the extension relationship 
+     *  between objects. Used only if mapping of the another object
+     * 
+     *  is provided.
+     *  
+     * 
+     * @param _extends
+     * @param extends the value of field 'extends'.
+     */
+    public void setExtends(
+            final java.lang.Object _extends) {
+        this._extends = _extends;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vIdentity
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setIdentity(
+            final int index,
+            final java.lang.String vIdentity)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._identity.size()) {
+            throw new IndexOutOfBoundsException("setIdentity: Index value '" + index + "' not in range [0.." + (this._identity.size() - 1) + "]");
+        }
+
+        this._identity.set(index, vIdentity);
+    }
+
+    /**
+     * 
+     * 
+     * @param vIdentityArray
+     */
+    public void setIdentity(
+            final java.lang.String[] vIdentityArray) {
+        //-- copy array
+        _identity.clear();
+
+        for (int i = 0; i < vIdentityArray.length; i++) {
+                this._identity.add(vIdentityArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'keyGenerator'.
+     * 
+     * @param keyGenerator the value of field 'keyGenerator'.
+     */
+    public void setKeyGenerator(
+            final java.lang.String keyGenerator) {
+        this._keyGenerator = keyGenerator;
+    }
+
+    /**
+     * Sets the value of field 'mapTo'. The field 'mapTo' has the
+     * following description: The 'map-to' element is used for
+     * specifying the name of the item 
+     *  that should be associated with the given Java object.
+     *  
+     * 
+     * @param mapTo the value of field 'mapTo'.
+     */
+    public void setMapTo(
+            final org.exolab.castor.mapping.xml.MapTo mapTo) {
+        this._mapTo = mapTo;
+    }
+
+    /**
+     * Sets the value of field 'name'. The field 'name' has the
+     * following description: Specifies the fully qualified package
+     * name of the Java object needed to be mapped.
+     *  
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vNamedNativeQuery
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setNamedNativeQuery(
+            final int index,
+            final org.exolab.castor.mapping.xml.NamedNativeQuery vNamedNativeQuery)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._namedNativeQueryList.size()) {
+            throw new IndexOutOfBoundsException("setNamedNativeQuery: Index value '" + index + "' not in range [0.." + (this._namedNativeQueryList.size() - 1) + "]");
+        }
+
+        this._namedNativeQueryList.set(index, vNamedNativeQuery);
+    }
+
+    /**
+     * 
+     * 
+     * @param vNamedNativeQueryArray
+     */
+    public void setNamedNativeQuery(
+            final org.exolab.castor.mapping.xml.NamedNativeQuery[] vNamedNativeQueryArray) {
+        //-- copy array
+        _namedNativeQueryList.clear();
+
+        for (int i = 0; i < vNamedNativeQueryArray.length; i++) {
+                this._namedNativeQueryList.add(vNamedNativeQueryArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vNamedQuery
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setNamedQuery(
+            final int index,
+            final org.exolab.castor.mapping.xml.NamedQuery vNamedQuery)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._namedQueryList.size()) {
+            throw new IndexOutOfBoundsException("setNamedQuery: Index value '" + index + "' not in range [0.." + (this._namedQueryList.size() - 1) + "]");
+        }
+
+        this._namedQueryList.set(index, vNamedQuery);
+    }
+
+    /**
+     * 
+     * 
+     * @param vNamedQueryArray
+     */
+    public void setNamedQuery(
+            final org.exolab.castor.mapping.xml.NamedQuery[] vNamedQueryArray) {
+        //-- copy array
+        _namedQueryList.clear();
+
+        for (int i = 0; i < vNamedQueryArray.length; i++) {
+                this._namedQueryList.add(vNamedQueryArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'verifyConstructable'.
+     * 
+     * @param verifyConstructable the value of field
+     * 'verifyConstructable'.
+     */
+    public void setVerifyConstructable(
+            final boolean verifyConstructable) {
+        this._verifyConstructable = verifyConstructable;
+        this._has_verifyConstructable = true;
+    }
+
+    /**
+     * Sets the value of field 'version'. The field 'version' has
+     * the following description: If set to the name of a mapped
+     * field, this field will be used for check 
+     *  on object modifications during transactions (Castor JDO
+     * only).
+     *  
+     * 
+     * @param version the value of field 'version'.
+     */
+    public void setVersion(
+            final java.lang.String version) {
+        this._version = version;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.ClassMapping
+     */
+    public static org.exolab.castor.mapping.xml.ClassMapping unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.ClassMapping) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.ClassMapping.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/ClassChoice.java
@@ -0,0 +1,451 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class ClassChoice.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class ClassChoice implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The 'field' element is used to describe the property of a
+     * Java object.
+     *  
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.FieldMapping> _fieldMappingList;
+
+    /**
+     * Field _containerList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.Container> _containerList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassChoice() {
+        super();
+        this._fieldMappingList = new java.util.ArrayList<org.exolab.castor.mapping.xml.FieldMapping>();
+        this._containerList = new java.util.ArrayList<org.exolab.castor.mapping.xml.Container>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vContainer
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addContainer(
+            final org.exolab.castor.mapping.xml.Container vContainer)
+    throws java.lang.IndexOutOfBoundsException {
+        this._containerList.add(vContainer);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vContainer
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addContainer(
+            final int index,
+            final org.exolab.castor.mapping.xml.Container vContainer)
+    throws java.lang.IndexOutOfBoundsException {
+        this._containerList.add(index, vContainer);
+    }
+
+    /**
+     * 
+     * 
+     * @param vFieldMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addFieldMapping(
+            final org.exolab.castor.mapping.xml.FieldMapping vFieldMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._fieldMappingList.add(vFieldMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vFieldMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addFieldMapping(
+            final int index,
+            final org.exolab.castor.mapping.xml.FieldMapping vFieldMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        this._fieldMappingList.add(index, vFieldMapping);
+    }
+
+    /**
+     * Method enumerateContainer.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.Container> enumerateContainer(
+    ) {
+        return java.util.Collections.enumeration(this._containerList);
+    }
+
+    /**
+     * Method enumerateFieldMapping.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.FieldMapping> enumerateFieldMapping(
+    ) {
+        return java.util.Collections.enumeration(this._fieldMappingList);
+    }
+
+    /**
+     * Method getContainer.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.Container at the given index
+     */
+    public org.exolab.castor.mapping.xml.Container getContainer(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._containerList.size()) {
+            throw new IndexOutOfBoundsException("getContainer: Index value '" + index + "' not in range [0.." + (this._containerList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.Container) _containerList.get(index);
+    }
+
+    /**
+     * Method getContainer.Returns the contents of the collection
+     * in an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.Container[] getContainer(
+    ) {
+        org.exolab.castor.mapping.xml.Container[] array = new org.exolab.castor.mapping.xml.Container[0];
+        return (org.exolab.castor.mapping.xml.Container[]) this._containerList.toArray(array);
+    }
+
+    /**
+     * Method getContainerCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getContainerCount(
+    ) {
+        return this._containerList.size();
+    }
+
+    /**
+     * Method getFieldMapping.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.FieldMapping at the given index
+     */
+    public org.exolab.castor.mapping.xml.FieldMapping getFieldMapping(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._fieldMappingList.size()) {
+            throw new IndexOutOfBoundsException("getFieldMapping: Index value '" + index + "' not in range [0.." + (this._fieldMappingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.FieldMapping) _fieldMappingList.get(index);
+    }
+
+    /**
+     * Method getFieldMapping.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.FieldMapping[] getFieldMapping(
+    ) {
+        org.exolab.castor.mapping.xml.FieldMapping[] array = new org.exolab.castor.mapping.xml.FieldMapping[0];
+        return (org.exolab.castor.mapping.xml.FieldMapping[]) this._fieldMappingList.toArray(array);
+    }
+
+    /**
+     * Method getFieldMappingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getFieldMappingCount(
+    ) {
+        return this._fieldMappingList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateContainer.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.Container> iterateContainer(
+    ) {
+        return this._containerList.iterator();
+    }
+
+    /**
+     * Method iterateFieldMapping.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.FieldMapping> iterateFieldMapping(
+    ) {
+        return this._fieldMappingList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllContainer(
+    ) {
+        this._containerList.clear();
+    }
+
+    /**
+     */
+    public void removeAllFieldMapping(
+    ) {
+        this._fieldMappingList.clear();
+    }
+
+    /**
+     * Method removeContainer.
+     * 
+     * @param vContainer
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeContainer(
+            final org.exolab.castor.mapping.xml.Container vContainer) {
+        boolean removed = _containerList.remove(vContainer);
+        return removed;
+    }
+
+    /**
+     * Method removeContainerAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.Container removeContainerAt(
+            final int index) {
+        java.lang.Object obj = this._containerList.remove(index);
+        return (org.exolab.castor.mapping.xml.Container) obj;
+    }
+
+    /**
+     * Method removeFieldMapping.
+     * 
+     * @param vFieldMapping
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeFieldMapping(
+            final org.exolab.castor.mapping.xml.FieldMapping vFieldMapping) {
+        boolean removed = _fieldMappingList.remove(vFieldMapping);
+        return removed;
+    }
+
+    /**
+     * Method removeFieldMappingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.FieldMapping removeFieldMappingAt(
+            final int index) {
+        java.lang.Object obj = this._fieldMappingList.remove(index);
+        return (org.exolab.castor.mapping.xml.FieldMapping) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vContainer
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setContainer(
+            final int index,
+            final org.exolab.castor.mapping.xml.Container vContainer)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._containerList.size()) {
+            throw new IndexOutOfBoundsException("setContainer: Index value '" + index + "' not in range [0.." + (this._containerList.size() - 1) + "]");
+        }
+
+        this._containerList.set(index, vContainer);
+    }
+
+    /**
+     * 
+     * 
+     * @param vContainerArray
+     */
+    public void setContainer(
+            final org.exolab.castor.mapping.xml.Container[] vContainerArray) {
+        //-- copy array
+        _containerList.clear();
+
+        for (int i = 0; i < vContainerArray.length; i++) {
+                this._containerList.add(vContainerArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vFieldMapping
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setFieldMapping(
+            final int index,
+            final org.exolab.castor.mapping.xml.FieldMapping vFieldMapping)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._fieldMappingList.size()) {
+            throw new IndexOutOfBoundsException("setFieldMapping: Index value '" + index + "' not in range [0.." + (this._fieldMappingList.size() - 1) + "]");
+        }
+
+        this._fieldMappingList.set(index, vFieldMapping);
+    }
+
+    /**
+     * 
+     * 
+     * @param vFieldMappingArray
+     */
+    public void setFieldMapping(
+            final org.exolab.castor.mapping.xml.FieldMapping[] vFieldMappingArray) {
+        //-- copy array
+        _fieldMappingList.clear();
+
+        for (int i = 0; i < vFieldMappingArray.length; i++) {
+                this._fieldMappingList.add(vFieldMappingArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.ClassChoice
+     */
+    public static org.exolab.castor.mapping.xml.ClassChoice unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.ClassChoice) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.ClassChoice.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/Sql.java
@@ -0,0 +1,722 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * The 'sql' element is used to store information about the
+ * database 
+ *  column to which a Java object is mapped to.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Sql implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * An optional attribute used to store the name of the column
+     * in 
+     *  the database table.
+     *  
+     */
+    private java.util.List<java.lang.String> _name;
+
+    /**
+     * An optional attibute used to specify the DB-specific type of
+     * the column.
+     *  
+     */
+    private java.lang.String _type;
+
+    /**
+     * An optional attribute to specify the name of the bridge
+     * table 
+     *  containing the primary keys of the object on each side of
+     * the 
+     *  many to many relationship.
+     *  
+     */
+    private java.lang.String _manyTable;
+
+    /**
+     * An optional attribute to specidy name of the columns that
+     * holds 
+     *  the foreign key to this object. That column is in the
+     * database 
+     *  table that stores objects of the Java type of this field.
+     *  
+     */
+    private java.util.List<java.lang.String> _manyKey;
+
+    /**
+     * An optional attribute to specify cascading support; possible
+     * values are
+     *  'none', 'all', 'create', 'delete' and 'update'; it is
+     * possible to use more than one
+     *  of those values (when not using 'all' or 'none'), using
+     * whitespace as a 
+     *  delimiter (as in 'create delete').
+     *  
+     */
+    private java.lang.String _cascading;
+
+    /**
+     * Field _readOnly.
+     */
+    private boolean _readOnly = false;
+
+    /**
+     * keeps track of state for field: _readOnly
+     */
+    private boolean _has_readOnly;
+
+    /**
+     * Field _transient.
+     */
+    private boolean _transient;
+
+    /**
+     * keeps track of state for field: _transient
+     */
+    private boolean _has_transient;
+
+    /**
+     * Field _dirty.
+     */
+    private org.exolab.castor.mapping.xml.types.SqlDirtyType _dirty = org.exolab.castor.mapping.xml.types.SqlDirtyType.fromValue("check");
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Sql() {
+        super();
+        this._name = new java.util.ArrayList<java.lang.String>();
+        this._manyKey = new java.util.ArrayList<java.lang.String>();
+        setDirty(org.exolab.castor.mapping.xml.types.SqlDirtyType.fromValue("check"));
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vManyKey
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addManyKey(
+            final java.lang.String vManyKey)
+    throws java.lang.IndexOutOfBoundsException {
+        this._manyKey.add(vManyKey);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vManyKey
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addManyKey(
+            final int index,
+            final java.lang.String vManyKey)
+    throws java.lang.IndexOutOfBoundsException {
+        this._manyKey.add(index, vManyKey);
+    }
+
+    /**
+     * 
+     * 
+     * @param vName
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addName(
+            final java.lang.String vName)
+    throws java.lang.IndexOutOfBoundsException {
+        this._name.add(vName);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vName
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addName(
+            final int index,
+            final java.lang.String vName)
+    throws java.lang.IndexOutOfBoundsException {
+        this._name.add(index, vName);
+    }
+
+    /**
+     */
+    public void deleteReadOnly(
+    ) {
+        this._has_readOnly= false;
+    }
+
+    /**
+     */
+    public void deleteTransient(
+    ) {
+        this._has_transient= false;
+    }
+
+    /**
+     * Method enumerateManyKey.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends java.lang.String> enumerateManyKey(
+    ) {
+        return java.util.Collections.enumeration(this._manyKey);
+    }
+
+    /**
+     * Method enumerateName.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends java.lang.String> enumerateName(
+    ) {
+        return java.util.Collections.enumeration(this._name);
+    }
+
+    /**
+     * Returns the value of field 'cascading'. The field
+     * 'cascading' has the following description: An optional
+     * attribute to specify cascading support; possible values are
+     *  'none', 'all', 'create', 'delete' and 'update'; it is
+     * possible to use more than one
+     *  of those values (when not using 'all' or 'none'), using
+     * whitespace as a 
+     *  delimiter (as in 'create delete').
+     *  
+     * 
+     * @return the value of field 'Cascading'.
+     */
+    public java.lang.String getCascading(
+    ) {
+        return this._cascading;
+    }
+
+    /**
+     * Returns the value of field 'dirty'.
+     * 
+     * @return the value of field 'Dirty'.
+     */
+    public org.exolab.castor.mapping.xml.types.SqlDirtyType getDirty(
+    ) {
+        return this._dirty;
+    }
+
+    /**
+     * Method getManyKey.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the java.lang.String at the given index
+     */
+    public java.lang.String getManyKey(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._manyKey.size()) {
+            throw new IndexOutOfBoundsException("getManyKey: Index value '" + index + "' not in range [0.." + (this._manyKey.size() - 1) + "]");
+        }
+
+        return (java.lang.String) _manyKey.get(index);
+    }
+
+    /**
+     * Method getManyKey.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public java.lang.String[] getManyKey(
+    ) {
+        java.lang.String[] array = new java.lang.String[0];
+        return (java.lang.String[]) this._manyKey.toArray(array);
+    }
+
+    /**
+     * Method getManyKeyCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getManyKeyCount(
+    ) {
+        return this._manyKey.size();
+    }
+
+    /**
+     * Returns the value of field 'manyTable'. The field
+     * 'manyTable' has the following description: An optional
+     * attribute to specify the name of the bridge table 
+     *  containing the primary keys of the object on each side of
+     * the 
+     *  many to many relationship.
+     *  
+     * 
+     * @return the value of field 'ManyTable'.
+     */
+    public java.lang.String getManyTable(
+    ) {
+        return this._manyTable;
+    }
+
+    /**
+     * Method getName.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the java.lang.String at the given index
+     */
+    public java.lang.String getName(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._name.size()) {
+            throw new IndexOutOfBoundsException("getName: Index value '" + index + "' not in range [0.." + (this._name.size() - 1) + "]");
+        }
+
+        return (java.lang.String) _name.get(index);
+    }
+
+    /**
+     * Method getName.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public java.lang.String[] getName(
+    ) {
+        java.lang.String[] array = new java.lang.String[0];
+        return (java.lang.String[]) this._name.toArray(array);
+    }
+
+    /**
+     * Method getNameCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getNameCount(
+    ) {
+        return this._name.size();
+    }
+
+    /**
+     * Returns the value of field 'readOnly'.
+     * 
+     * @return the value of field 'ReadOnly'.
+     */
+    public boolean getReadOnly(
+    ) {
+        return this._readOnly;
+    }
+
+    /**
+     * Returns the value of field 'transient'.
+     * 
+     * @return the value of field 'Transient'.
+     */
+    public boolean getTransient(
+    ) {
+        return this._transient;
+    }
+
+    /**
+     * Returns the value of field 'type'. The field 'type' has the
+     * following description: An optional attibute used to specify
+     * the DB-specific type of the column.
+     *  
+     * 
+     * @return the value of field 'Type'.
+     */
+    public java.lang.String getType(
+    ) {
+        return this._type;
+    }
+
+    /**
+     * Method hasReadOnly.
+     * 
+     * @return true if at least one ReadOnly has been added
+     */
+    public boolean hasReadOnly(
+    ) {
+        return this._has_readOnly;
+    }
+
+    /**
+     * Method hasTransient.
+     * 
+     * @return true if at least one Transient has been added
+     */
+    public boolean hasTransient(
+    ) {
+        return this._has_transient;
+    }
+
+    /**
+     * Returns the value of field 'readOnly'.
+     * 
+     * @return the value of field 'ReadOnly'.
+     */
+    public boolean isReadOnly(
+    ) {
+        return this._readOnly;
+    }
+
+    /**
+     * Returns the value of field 'transient'.
+     * 
+     * @return the value of field 'Transient'.
+     */
+    public boolean isTransient(
+    ) {
+        return this._transient;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateManyKey.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends java.lang.String> iterateManyKey(
+    ) {
+        return this._manyKey.iterator();
+    }
+
+    /**
+     * Method iterateName.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends java.lang.String> iterateName(
+    ) {
+        return this._name.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllManyKey(
+    ) {
+        this._manyKey.clear();
+    }
+
+    /**
+     */
+    public void removeAllName(
+    ) {
+        this._name.clear();
+    }
+
+    /**
+     * Method removeManyKey.
+     * 
+     * @param vManyKey
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeManyKey(
+            final java.lang.String vManyKey) {
+        boolean removed = _manyKey.remove(vManyKey);
+        return removed;
+    }
+
+    /**
+     * Method removeManyKeyAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public java.lang.String removeManyKeyAt(
+            final int index) {
+        java.lang.Object obj = this._manyKey.remove(index);
+        return (java.lang.String) obj;
+    }
+
+    /**
+     * Method removeName.
+     * 
+     * @param vName
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeName(
+            final java.lang.String vName) {
+        boolean removed = _name.remove(vName);
+        return removed;
+    }
+
+    /**
+     * Method removeNameAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public java.lang.String removeNameAt(
+            final int index) {
+        java.lang.Object obj = this._name.remove(index);
+        return (java.lang.String) obj;
+    }
+
+    /**
+     * Sets the value of field 'cascading'. The field 'cascading'
+     * has the following description: An optional attribute to
+     * specify cascading support; possible values are
+     *  'none', 'all', 'create', 'delete' and 'update'; it is
+     * possible to use more than one
+     *  of those values (when not using 'all' or 'none'), using
+     * whitespace as a 
+     *  delimiter (as in 'create delete').
+     *  
+     * 
+     * @param cascading the value of field 'cascading'.
+     */
+    public void setCascading(
+            final java.lang.String cascading) {
+        this._cascading = cascading;
+    }
+
+    /**
+     * Sets the value of field 'dirty'.
+     * 
+     * @param dirty the value of field 'dirty'.
+     */
+    public void setDirty(
+            final org.exolab.castor.mapping.xml.types.SqlDirtyType dirty) {
+        this._dirty = dirty;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vManyKey
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setManyKey(
+            final int index,
+            final java.lang.String vManyKey)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._manyKey.size()) {
+            throw new IndexOutOfBoundsException("setManyKey: Index value '" + index + "' not in range [0.." + (this._manyKey.size() - 1) + "]");
+        }
+
+        this._manyKey.set(index, vManyKey);
+    }
+
+    /**
+     * 
+     * 
+     * @param vManyKeyArray
+     */
+    public void setManyKey(
+            final java.lang.String[] vManyKeyArray) {
+        //-- copy array
+        _manyKey.clear();
+
+        for (int i = 0; i < vManyKeyArray.length; i++) {
+                this._manyKey.add(vManyKeyArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'manyTable'. The field 'manyTable'
+     * has the following description: An optional attribute to
+     * specify the name of the bridge table 
+     *  containing the primary keys of the object on each side of
+     * the 
+     *  many to many relationship.
+     *  
+     * 
+     * @param manyTable the value of field 'manyTable'.
+     */
+    public void setManyTable(
+            final java.lang.String manyTable) {
+        this._manyTable = manyTable;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vName
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setName(
+            final int index,
+            final java.lang.String vName)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._name.size()) {
+            throw new IndexOutOfBoundsException("setName: Index value '" + index + "' not in range [0.." + (this._name.size() - 1) + "]");
+        }
+
+        this._name.set(index, vName);
+    }
+
+    /**
+     * 
+     * 
+     * @param vNameArray
+     */
+    public void setName(
+            final java.lang.String[] vNameArray) {
+        //-- copy array
+        _name.clear();
+
+        for (int i = 0; i < vNameArray.length; i++) {
+                this._name.add(vNameArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'readOnly'.
+     * 
+     * @param readOnly the value of field 'readOnly'.
+     */
+    public void setReadOnly(
+            final boolean readOnly) {
+        this._readOnly = readOnly;
+        this._has_readOnly = true;
+    }
+
+    /**
+     * Sets the value of field 'transient'.
+     * 
+     * @param _transient
+     * @param transient the value of field 'transient'.
+     */
+    public void setTransient(
+            final boolean _transient) {
+        this._transient = _transient;
+        this._has_transient = true;
+    }
+
+    /**
+     * Sets the value of field 'type'. The field 'type' has the
+     * following description: An optional attibute used to specify
+     * the DB-specific type of the column.
+     *  
+     * 
+     * @param type the value of field 'type'.
+     */
+    public void setType(
+            final java.lang.String type) {
+        this._type = type;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled org.exolab.castor.mapping.xml.Sql
+     */
+    public static org.exolab.castor.mapping.xml.Sql unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.Sql) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.Sql.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/KeyGeneratorDef.java
@@ -0,0 +1,331 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class KeyGeneratorDef.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class KeyGeneratorDef implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _alias.
+     */
+    private java.lang.String _alias;
+
+    /**
+     * Field _paramList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.Param> _paramList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public KeyGeneratorDef() {
+        super();
+        this._paramList = new java.util.ArrayList<org.exolab.castor.mapping.xml.Param>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final int index,
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(index, vParam);
+    }
+
+    /**
+     * Method enumerateParam.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.Param> enumerateParam(
+    ) {
+        return java.util.Collections.enumeration(this._paramList);
+    }
+
+    /**
+     * Returns the value of field 'alias'.
+     * 
+     * @return the value of field 'Alias'.
+     */
+    public java.lang.String getAlias(
+    ) {
+        return this._alias;
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method getParam.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.exolab.castor.mapping.xml.Param
+     * at the given index
+     */
+    public org.exolab.castor.mapping.xml.Param getParam(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("getParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.Param) _paramList.get(index);
+    }
+
+    /**
+     * Method getParam.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.Param[] getParam(
+    ) {
+        org.exolab.castor.mapping.xml.Param[] array = new org.exolab.castor.mapping.xml.Param[0];
+        return (org.exolab.castor.mapping.xml.Param[]) this._paramList.toArray(array);
+    }
+
+    /**
+     * Method getParamCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getParamCount(
+    ) {
+        return this._paramList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateParam.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.Param> iterateParam(
+    ) {
+        return this._paramList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllParam(
+    ) {
+        this._paramList.clear();
+    }
+
+    /**
+     * Method removeParam.
+     * 
+     * @param vParam
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeParam(
+            final org.exolab.castor.mapping.xml.Param vParam) {
+        boolean removed = _paramList.remove(vParam);
+        return removed;
+    }
+
+    /**
+     * Method removeParamAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.Param removeParamAt(
+            final int index) {
+        java.lang.Object obj = this._paramList.remove(index);
+        return (org.exolab.castor.mapping.xml.Param) obj;
+    }
+
+    /**
+     * Sets the value of field 'alias'.
+     * 
+     * @param alias the value of field 'alias'.
+     */
+    public void setAlias(
+            final java.lang.String alias) {
+        this._alias = alias;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setParam(
+            final int index,
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("setParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        this._paramList.set(index, vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param vParamArray
+     */
+    public void setParam(
+            final org.exolab.castor.mapping.xml.Param[] vParamArray) {
+        //-- copy array
+        _paramList.clear();
+
+        for (int i = 0; i < vParamArray.length; i++) {
+                this._paramList.add(vParamArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.KeyGeneratorDef
+     */
+    public static org.exolab.castor.mapping.xml.KeyGeneratorDef unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.KeyGeneratorDef) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.KeyGeneratorDef.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/Container.java
@@ -0,0 +1,413 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class Container.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class Container implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _type.
+     */
+    private java.lang.String _type;
+
+    /**
+     * Field _required.
+     */
+    private boolean _required = false;
+
+    /**
+     * keeps track of state for field: _required
+     */
+    private boolean _has_required;
+
+    /**
+     * Field _direct.
+     */
+    private boolean _direct = false;
+
+    /**
+     * keeps track of state for field: _direct
+     */
+    private boolean _has_direct;
+
+    /**
+     * Field _getMethod.
+     */
+    private java.lang.String _getMethod;
+
+    /**
+     * Field _setMethod.
+     */
+    private java.lang.String _setMethod;
+
+    /**
+     * Field _createMethod.
+     */
+    private java.lang.String _createMethod;
+
+    /**
+     * Field _description.
+     */
+    private java.lang.String _description;
+
+    /**
+     * The 'field' element is used to describe the property of a
+     * Java object.
+     *  
+     */
+    private org.exolab.castor.mapping.xml.FieldMapping _fieldMapping;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Container() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     */
+    public void deleteDirect(
+    ) {
+        this._has_direct= false;
+    }
+
+    /**
+     */
+    public void deleteRequired(
+    ) {
+        this._has_required= false;
+    }
+
+    /**
+     * Returns the value of field 'createMethod'.
+     * 
+     * @return the value of field 'CreateMethod'.
+     */
+    public java.lang.String getCreateMethod(
+    ) {
+        return this._createMethod;
+    }
+
+    /**
+     * Returns the value of field 'description'.
+     * 
+     * @return the value of field 'Description'.
+     */
+    public java.lang.String getDescription(
+    ) {
+        return this._description;
+    }
+
+    /**
+     * Returns the value of field 'direct'.
+     * 
+     * @return the value of field 'Direct'.
+     */
+    public boolean getDirect(
+    ) {
+        return this._direct;
+    }
+
+    /**
+     * Returns the value of field 'fieldMapping'. The field
+     * 'fieldMapping' has the following description: The 'field'
+     * element is used to describe the property of a Java object.
+     *  
+     * 
+     * @return the value of field 'FieldMapping'.
+     */
+    public org.exolab.castor.mapping.xml.FieldMapping getFieldMapping(
+    ) {
+        return this._fieldMapping;
+    }
+
+    /**
+     * Returns the value of field 'getMethod'.
+     * 
+     * @return the value of field 'GetMethod'.
+     */
+    public java.lang.String getGetMethod(
+    ) {
+        return this._getMethod;
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'required'.
+     * 
+     * @return the value of field 'Required'.
+     */
+    public boolean getRequired(
+    ) {
+        return this._required;
+    }
+
+    /**
+     * Returns the value of field 'setMethod'.
+     * 
+     * @return the value of field 'SetMethod'.
+     */
+    public java.lang.String getSetMethod(
+    ) {
+        return this._setMethod;
+    }
+
+    /**
+     * Returns the value of field 'type'.
+     * 
+     * @return the value of field 'Type'.
+     */
+    public java.lang.String getType(
+    ) {
+        return this._type;
+    }
+
+    /**
+     * Method hasDirect.
+     * 
+     * @return true if at least one Direct has been added
+     */
+    public boolean hasDirect(
+    ) {
+        return this._has_direct;
+    }
+
+    /**
+     * Method hasRequired.
+     * 
+     * @return true if at least one Required has been added
+     */
+    public boolean hasRequired(
+    ) {
+        return this._has_required;
+    }
+
+    /**
+     * Returns the value of field 'direct'.
+     * 
+     * @return the value of field 'Direct'.
+     */
+    public boolean isDirect(
+    ) {
+        return this._direct;
+    }
+
+    /**
+     * Returns the value of field 'required'.
+     * 
+     * @return the value of field 'Required'.
+     */
+    public boolean isRequired(
+    ) {
+        return this._required;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'createMethod'.
+     * 
+     * @param createMethod the value of field 'createMethod'.
+     */
+    public void setCreateMethod(
+            final java.lang.String createMethod) {
+        this._createMethod = createMethod;
+    }
+
+    /**
+     * Sets the value of field 'description'.
+     * 
+     * @param description the value of field 'description'.
+     */
+    public void setDescription(
+            final java.lang.String description) {
+        this._description = description;
+    }
+
+    /**
+     * Sets the value of field 'direct'.
+     * 
+     * @param direct the value of field 'direct'.
+     */
+    public void setDirect(
+            final boolean direct) {
+        this._direct = direct;
+        this._has_direct = true;
+    }
+
+    /**
+     * Sets the value of field 'fieldMapping'. The field
+     * 'fieldMapping' has the following description: The 'field'
+     * element is used to describe the property of a Java object.
+     *  
+     * 
+     * @param fieldMapping the value of field 'fieldMapping'.
+     */
+    public void setFieldMapping(
+            final org.exolab.castor.mapping.xml.FieldMapping fieldMapping) {
+        this._fieldMapping = fieldMapping;
+    }
+
+    /**
+     * Sets the value of field 'getMethod'.
+     * 
+     * @param getMethod the value of field 'getMethod'.
+     */
+    public void setGetMethod(
+            final java.lang.String getMethod) {
+        this._getMethod = getMethod;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'required'.
+     * 
+     * @param required the value of field 'required'.
+     */
+    public void setRequired(
+            final boolean required) {
+        this._required = required;
+        this._has_required = true;
+    }
+
+    /**
+     * Sets the value of field 'setMethod'.
+     * 
+     * @param setMethod the value of field 'setMethod'.
+     */
+    public void setSetMethod(
+            final java.lang.String setMethod) {
+        this._setMethod = setMethod;
+    }
+
+    /**
+     * Sets the value of field 'type'.
+     * 
+     * @param type the value of field 'type'.
+     */
+    public void setType(
+            final java.lang.String type) {
+        this._type = type;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.Container
+     */
+    public static org.exolab.castor.mapping.xml.Container unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.Container) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.Container.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/NamedQuery.java
@@ -0,0 +1,331 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class NamedQuery.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class NamedQuery implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _query.
+     */
+    private java.lang.String _query;
+
+    /**
+     * Field _queryHintList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.QueryHint> _queryHintList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public NamedQuery() {
+        super();
+        this._queryHintList = new java.util.ArrayList<org.exolab.castor.mapping.xml.QueryHint>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vQueryHint
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addQueryHint(
+            final org.exolab.castor.mapping.xml.QueryHint vQueryHint)
+    throws java.lang.IndexOutOfBoundsException {
+        this._queryHintList.add(vQueryHint);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vQueryHint
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addQueryHint(
+            final int index,
+            final org.exolab.castor.mapping.xml.QueryHint vQueryHint)
+    throws java.lang.IndexOutOfBoundsException {
+        this._queryHintList.add(index, vQueryHint);
+    }
+
+    /**
+     * Method enumerateQueryHint.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.QueryHint> enumerateQueryHint(
+    ) {
+        return java.util.Collections.enumeration(this._queryHintList);
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'query'.
+     * 
+     * @return the value of field 'Query'.
+     */
+    public java.lang.String getQuery(
+    ) {
+        return this._query;
+    }
+
+    /**
+     * Method getQueryHint.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.mapping.xml.QueryHint at the given index
+     */
+    public org.exolab.castor.mapping.xml.QueryHint getQueryHint(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._queryHintList.size()) {
+            throw new IndexOutOfBoundsException("getQueryHint: Index value '" + index + "' not in range [0.." + (this._queryHintList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.QueryHint) _queryHintList.get(index);
+    }
+
+    /**
+     * Method getQueryHint.Returns the contents of the collection
+     * in an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.QueryHint[] getQueryHint(
+    ) {
+        org.exolab.castor.mapping.xml.QueryHint[] array = new org.exolab.castor.mapping.xml.QueryHint[0];
+        return (org.exolab.castor.mapping.xml.QueryHint[]) this._queryHintList.toArray(array);
+    }
+
+    /**
+     * Method getQueryHintCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getQueryHintCount(
+    ) {
+        return this._queryHintList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateQueryHint.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.QueryHint> iterateQueryHint(
+    ) {
+        return this._queryHintList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllQueryHint(
+    ) {
+        this._queryHintList.clear();
+    }
+
+    /**
+     * Method removeQueryHint.
+     * 
+     * @param vQueryHint
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeQueryHint(
+            final org.exolab.castor.mapping.xml.QueryHint vQueryHint) {
+        boolean removed = _queryHintList.remove(vQueryHint);
+        return removed;
+    }
+
+    /**
+     * Method removeQueryHintAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.QueryHint removeQueryHintAt(
+            final int index) {
+        java.lang.Object obj = this._queryHintList.remove(index);
+        return (org.exolab.castor.mapping.xml.QueryHint) obj;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'query'.
+     * 
+     * @param query the value of field 'query'.
+     */
+    public void setQuery(
+            final java.lang.String query) {
+        this._query = query;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vQueryHint
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setQueryHint(
+            final int index,
+            final org.exolab.castor.mapping.xml.QueryHint vQueryHint)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._queryHintList.size()) {
+            throw new IndexOutOfBoundsException("setQueryHint: Index value '" + index + "' not in range [0.." + (this._queryHintList.size() - 1) + "]");
+        }
+
+        this._queryHintList.set(index, vQueryHint);
+    }
+
+    /**
+     * 
+     * 
+     * @param vQueryHintArray
+     */
+    public void setQueryHint(
+            final org.exolab.castor.mapping.xml.QueryHint[] vQueryHintArray) {
+        //-- copy array
+        _queryHintList.clear();
+
+        for (int i = 0; i < vQueryHintArray.length; i++) {
+                this._queryHintList.add(vQueryHintArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.NamedQuery
+     */
+    public static org.exolab.castor.mapping.xml.NamedQuery unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.NamedQuery) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.NamedQuery.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/CacheTypeMapping.java
@@ -0,0 +1,413 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml;
+
+/**
+ * Class CacheTypeMapping.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings("serial")
+public class CacheTypeMapping implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _type.
+     */
+    private java.lang.String _type = "count-limited";
+
+    /**
+     * Field _debug.
+     */
+    private boolean _debug = false;
+
+    /**
+     * keeps track of state for field: _debug
+     */
+    private boolean _has_debug;
+
+    /**
+     * Field _capacity.
+     */
+    private long _capacity;
+
+    /**
+     * keeps track of state for field: _capacity
+     */
+    private boolean _has_capacity;
+
+    /**
+     * Field _paramList.
+     */
+    private java.util.List<org.exolab.castor.mapping.xml.Param> _paramList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public CacheTypeMapping() {
+        super();
+        setType("count-limited");
+        this._paramList = new java.util.ArrayList<org.exolab.castor.mapping.xml.Param>();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addParam(
+            final int index,
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        this._paramList.add(index, vParam);
+    }
+
+    /**
+     */
+    public void deleteCapacity(
+    ) {
+        this._has_capacity= false;
+    }
+
+    /**
+     */
+    public void deleteDebug(
+    ) {
+        this._has_debug= false;
+    }
+
+    /**
+     * Method enumerateParam.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration<? extends org.exolab.castor.mapping.xml.Param> enumerateParam(
+    ) {
+        return java.util.Collections.enumeration(this._paramList);
+    }
+
+    /**
+     * Returns the value of field 'capacity'.
+     * 
+     * @return the value of field 'Capacity'.
+     */
+    public long getCapacity(
+    ) {
+        return this._capacity;
+    }
+
+    /**
+     * Returns the value of field 'debug'.
+     * 
+     * @return the value of field 'Debug'.
+     */
+    public boolean getDebug(
+    ) {
+        return this._debug;
+    }
+
+    /**
+     * Method getParam.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the org.exolab.castor.mapping.xml.Param
+     * at the given index
+     */
+    public org.exolab.castor.mapping.xml.Param getParam(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("getParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.mapping.xml.Param) _paramList.get(index);
+    }
+
+    /**
+     * Method getParam.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.mapping.xml.Param[] getParam(
+    ) {
+        org.exolab.castor.mapping.xml.Param[] array = new org.exolab.castor.mapping.xml.Param[0];
+        return (org.exolab.castor.mapping.xml.Param[]) this._paramList.toArray(array);
+    }
+
+    /**
+     * Method getParamCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getParamCount(
+    ) {
+        return this._paramList.size();
+    }
+
+    /**
+     * Returns the value of field 'type'.
+     * 
+     * @return the value of field 'Type'.
+     */
+    public java.lang.String getType(
+    ) {
+        return this._type;
+    }
+
+    /**
+     * Method hasCapacity.
+     * 
+     * @return true if at least one Capacity has been added
+     */
+    public boolean hasCapacity(
+    ) {
+        return this._has_capacity;
+    }
+
+    /**
+     * Method hasDebug.
+     * 
+     * @return true if at least one Debug has been added
+     */
+    public boolean hasDebug(
+    ) {
+        return this._has_debug;
+    }
+
+    /**
+     * Returns the value of field 'debug'.
+     * 
+     * @return the value of field 'Debug'.
+     */
+    public boolean isDebug(
+    ) {
+        return this._debug;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateParam.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator<? extends org.exolab.castor.mapping.xml.Param> iterateParam(
+    ) {
+        return this._paramList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllParam(
+    ) {
+        this._paramList.clear();
+    }
+
+    /**
+     * Method removeParam.
+     * 
+     * @param vParam
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeParam(
+            final org.exolab.castor.mapping.xml.Param vParam) {
+        boolean removed = _paramList.remove(vParam);
+        return removed;
+    }
+
+    /**
+     * Method removeParamAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.mapping.xml.Param removeParamAt(
+            final int index) {
+        java.lang.Object obj = this._paramList.remove(index);
+        return (org.exolab.castor.mapping.xml.Param) obj;
+    }
+
+    /**
+     * Sets the value of field 'capacity'.
+     * 
+     * @param capacity the value of field 'capacity'.
+     */
+    public void setCapacity(
+            final long capacity) {
+        this._capacity = capacity;
+        this._has_capacity = true;
+    }
+
+    /**
+     * Sets the value of field 'debug'.
+     * 
+     * @param debug the value of field 'debug'.
+     */
+    public void setDebug(
+            final boolean debug) {
+        this._debug = debug;
+        this._has_debug = true;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vParam
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setParam(
+            final int index,
+            final org.exolab.castor.mapping.xml.Param vParam)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._paramList.size()) {
+            throw new IndexOutOfBoundsException("setParam: Index value '" + index + "' not in range [0.." + (this._paramList.size() - 1) + "]");
+        }
+
+        this._paramList.set(index, vParam);
+    }
+
+    /**
+     * 
+     * 
+     * @param vParamArray
+     */
+    public void setParam(
+            final org.exolab.castor.mapping.xml.Param[] vParamArray) {
+        //-- copy array
+        _paramList.clear();
+
+        for (int i = 0; i < vParamArray.length; i++) {
+                this._paramList.add(vParamArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'type'.
+     * 
+     * @param type the value of field 'type'.
+     */
+    public void setType(
+            final java.lang.String type) {
+        this._type = type;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.mapping.xml.CacheTypeMapping
+     */
+    public static org.exolab.castor.mapping.xml.CacheTypeMapping unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.mapping.xml.CacheTypeMapping) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.mapping.xml.CacheTypeMapping.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/IncludeDescriptor.java
@@ -0,0 +1,213 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.Include;
+
+/**
+ * Class IncludeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class IncludeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public IncludeDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "include";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _href
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_href", "href", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Include target = (Include) object;
+                return target.getHref();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Include target = (Include) object;
+                    target.setHref( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _href
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.Include.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/FieldMappingDescriptor.java
@@ -0,0 +1,1031 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.FieldMapping;
+
+/**
+ * Class FieldMappingDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldMappingDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldMappingDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "field";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _type
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_type", "type", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getType();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setType( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _type
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _required
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_required", "required", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                if (!target.hasRequired()) { return null; }
+                return (target.getRequired() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteRequired();
+                        return;
+                    }
+                    target.setRequired( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _required
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _transient
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_transient", "transient", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                if (!target.hasTransient()) { return null; }
+                return (target.getTransient() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteTransient();
+                        return;
+                    }
+                    target.setTransient( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _transient
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _nillable
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_nillable", "nillable", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                if (!target.hasNillable()) { return null; }
+                return (target.getNillable() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteNillable();
+                        return;
+                    }
+                    target.setNillable( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _nillable
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _direct
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_direct", "direct", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                if (!target.hasDirect()) { return null; }
+                return (target.getDirect() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteDirect();
+                        return;
+                    }
+                    target.setDirect( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _direct
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _lazy
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_lazy", "lazy", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                if (!target.hasLazy()) { return null; }
+                return (target.getLazy() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteLazy();
+                        return;
+                    }
+                    target.setLazy( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _lazy
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _container
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_container", "container", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                if (!target.hasContainer()) { return null; }
+                return (target.getContainer() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteContainer();
+                        return;
+                    }
+                    target.setContainer( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _container
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _getMethod
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_getMethod", "get-method", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getGetMethod();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setGetMethod( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _getMethod
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _hasMethod
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_hasMethod", "has-method", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getHasMethod();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setHasMethod( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _hasMethod
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _setMethod
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_setMethod", "set-method", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getSetMethod();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setSetMethod( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _setMethod
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _createMethod
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_createMethod", "create-method", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getCreateMethod();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setCreateMethod( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _createMethod
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _handler
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_handler", "handler", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getHandler();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setHandler( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _handler
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _collection
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.types.FieldMappingCollectionType.class, "_collection", "collection", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getCollection();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setCollection( (org.exolab.castor.mapping.xml.types.FieldMappingCollectionType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.mapping.xml.types.FieldMappingCollectionType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("FieldMappingCollectionType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _collection
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _comparator
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_comparator", "comparator", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getComparator();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setComparator( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _comparator
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _identity
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_identity", "identity", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                if (!target.hasIdentity()) { return null; }
+                return (target.getIdentity() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteIdentity();
+                        return;
+                    }
+                    target.setIdentity( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _identity
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _description
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_description", "description", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getDescription();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setDescription( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _description
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _sql
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.Sql.class, "_sql", "sql", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getSql();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setSql( (org.exolab.castor.mapping.xml.Sql) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.mapping.xml.Sql");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _sql
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _bindXml
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.BindXml.class, "_bindXml", "bind-xml", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getBindXml();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setBindXml( (org.exolab.castor.mapping.xml.BindXml) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.mapping.xml.BindXml");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _bindXml
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _ldap
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.Ldap.class, "_ldap", "ldap", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldMapping target = (FieldMapping) object;
+                return target.getLdap();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldMapping target = (FieldMapping) object;
+                    target.setLdap( (org.exolab.castor.mapping.xml.Ldap) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.mapping.xml.Ldap");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _ldap
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.FieldMapping.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/MappingRootDescriptor.java
@@ -0,0 +1,411 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.MappingRoot;
+
+/**
+ * Class MappingRootDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class MappingRootDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MappingRootDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "mapping";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _description
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_description", "description", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MappingRoot target = (MappingRoot) object;
+                return target.getDescription();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.setDescription( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _description
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _includeList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.Include.class, "_includeList", "include", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MappingRoot target = (MappingRoot) object;
+                return target.getInclude();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.addInclude( (org.exolab.castor.mapping.xml.Include) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.removeAllInclude();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.Include");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _includeList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _fieldHandlerDefList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.FieldHandlerDef.class, "_fieldHandlerDefList", "field-handler", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MappingRoot target = (MappingRoot) object;
+                return target.getFieldHandlerDef();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.addFieldHandlerDef( (org.exolab.castor.mapping.xml.FieldHandlerDef) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.removeAllFieldHandlerDef();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.FieldHandlerDef");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _fieldHandlerDefList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _classMappingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.ClassMapping.class, "_classMappingList", "class", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MappingRoot target = (MappingRoot) object;
+                return target.getClassMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.addClassMapping( (org.exolab.castor.mapping.xml.ClassMapping) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.removeAllClassMapping();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.ClassMapping");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _classMappingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _keyGeneratorDefList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.KeyGeneratorDef.class, "_keyGeneratorDefList", "key-generator", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MappingRoot target = (MappingRoot) object;
+                return target.getKeyGeneratorDef();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.addKeyGeneratorDef( (org.exolab.castor.mapping.xml.KeyGeneratorDef) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    MappingRoot target = (MappingRoot) object;
+                    target.removeAllKeyGeneratorDef();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.KeyGeneratorDef");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _keyGeneratorDefList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.MappingRoot.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/NamedQueryDescriptor.java
@@ -0,0 +1,310 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.NamedQuery;
+
+/**
+ * Class NamedQueryDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class NamedQueryDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public NamedQueryDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "named-query";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamedQuery target = (NamedQuery) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamedQuery target = (NamedQuery) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _query
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_query", "query", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamedQuery target = (NamedQuery) object;
+                return target.getQuery();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamedQuery target = (NamedQuery) object;
+                    target.setQuery( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _query
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _queryHintList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.QueryHint.class, "_queryHintList", "query-hint", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamedQuery target = (NamedQuery) object;
+                return target.getQueryHint();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamedQuery target = (NamedQuery) object;
+                    target.addQueryHint( (org.exolab.castor.mapping.xml.QueryHint) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    NamedQuery target = (NamedQuery) object;
+                    target.removeAllQueryHint();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.QueryHint");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _queryHintList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.NamedQuery.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/ContainerDescriptor.java
@@ -0,0 +1,560 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.Container;
+
+/**
+ * Class ContainerDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ContainerDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ContainerDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "container";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _type
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_type", "type", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                return target.getType();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    target.setType( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _type
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _required
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_required", "required", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                if (!target.hasRequired()) { return null; }
+                return (target.getRequired() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteRequired();
+                        return;
+                    }
+                    target.setRequired( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _required
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _direct
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_direct", "direct", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                if (!target.hasDirect()) { return null; }
+                return (target.getDirect() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteDirect();
+                        return;
+                    }
+                    target.setDirect( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _direct
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _getMethod
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_getMethod", "get-method", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                return target.getGetMethod();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    target.setGetMethod( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _getMethod
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _setMethod
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_setMethod", "set-method", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                return target.getSetMethod();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    target.setSetMethod( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _setMethod
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _createMethod
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_createMethod", "create-method", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                return target.getCreateMethod();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    target.setCreateMethod( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _createMethod
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _description
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_description", "description", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                return target.getDescription();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    target.setDescription( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _description
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _fieldMapping
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.FieldMapping.class, "_fieldMapping", "field", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Container target = (Container) object;
+                return target.getFieldMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Container target = (Container) object;
+                    target.setFieldMapping( (org.exolab.castor.mapping.xml.FieldMapping) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.mapping.xml.FieldMapping");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _fieldMapping
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.Container.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/PropertyTypeDescriptor.java
@@ -0,0 +1,262 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.PropertyType;
+
+/**
+ * Class PropertyTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PropertyTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PropertyTypeDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "propertyType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                PropertyType target = (PropertyType) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    PropertyType target = (PropertyType) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _value
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_value", "value", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                PropertyType target = (PropertyType) object;
+                return target.getValue();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    PropertyType target = (PropertyType) object;
+                    target.setValue( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _value
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.PropertyType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/NamedNativeQueryDescriptor.java
@@ -0,0 +1,394 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.NamedNativeQuery;
+
+/**
+ * Class NamedNativeQueryDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class NamedNativeQueryDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public NamedNativeQueryDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "named-native-query";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamedNativeQuery target = (NamedNativeQuery) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamedNativeQuery target = (NamedNativeQuery) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _resultClass
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_resultClass", "result-class", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamedNativeQuery target = (NamedNativeQuery) object;
+                return target.getResultClass();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamedNativeQuery target = (NamedNativeQuery) object;
+                    target.setResultClass( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _resultClass
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _resultSetMapping
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_resultSetMapping", "result-set-mapping", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamedNativeQuery target = (NamedNativeQuery) object;
+                return target.getResultSetMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamedNativeQuery target = (NamedNativeQuery) object;
+                    target.setResultSetMapping( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _resultSetMapping
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _query
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_query", "query", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamedNativeQuery target = (NamedNativeQuery) object;
+                return target.getQuery();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamedNativeQuery target = (NamedNativeQuery) object;
+                    target.setQuery( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _query
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _queryHintList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.QueryHint.class, "_queryHintList", "query-hint", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamedNativeQuery target = (NamedNativeQuery) object;
+                return target.getQueryHint();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamedNativeQuery target = (NamedNativeQuery) object;
+                    target.addQueryHint( (org.exolab.castor.mapping.xml.QueryHint) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    NamedNativeQuery target = (NamedNativeQuery) object;
+                    target.removeAllQueryHint();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.QueryHint");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _queryHintList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.NamedNativeQuery.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/ParamDescriptor.java
@@ -0,0 +1,257 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.Param;
+
+/**
+ * Class ParamDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ParamDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ParamDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "param";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Param target = (Param) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Param target = (Param) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _value
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_value", "value", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Param target = (Param) object;
+                return target.getValue();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Param target = (Param) object;
+                    target.setValue( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _value
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.Param.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/ClassMappingDescriptor.java
@@ -0,0 +1,820 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.ClassMapping;
+
+/**
+ * Class ClassMappingDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ClassMappingDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassMappingDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "class";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        this._identity = desc;
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("ID");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.IdValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.IdValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _extends
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Object.class, "_extends", "extends", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setReference(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getExtends();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setExtends( (java.lang.Object) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.Object();
+            }
+        };
+        desc.setSchemaType("IDREF");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _extends
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.IdRefValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.IdRefValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _depends
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Object.class, "_depends", "depends", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setReference(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getDepends();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setDepends( (java.lang.Object) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.Object();
+            }
+        };
+        desc.setSchemaType("IDREF");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _depends
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.IdRefValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.IdRefValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _identity
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_identity", "identity", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getIdentity();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.addIdentity( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.removeAllIdentity();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.CollectionFieldHandler(handler, new org.exolab.castor.xml.validators.NameValidator(org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN));
+        desc.setSchemaType("list");
+        desc.setComponentType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _identity
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _access
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.types.ClassMappingAccessType.class, "_access", "access", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getAccess();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setAccess( (org.exolab.castor.mapping.xml.types.ClassMappingAccessType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.mapping.xml.types.ClassMappingAccessType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("ClassMappingAccessType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _access
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _keyGenerator
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_keyGenerator", "key-generator", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getKeyGenerator();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setKeyGenerator( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _keyGenerator
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _autoComplete
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_autoComplete", "auto-complete", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                if (!target.hasAutoComplete()) { return null; }
+                return (target.getAutoComplete() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteAutoComplete();
+                        return;
+                    }
+                    target.setAutoComplete( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _autoComplete
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _verifyConstructable
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_verifyConstructable", "verify-constructable", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                if (!target.hasVerifyConstructable()) { return null; }
+                return (target.getVerifyConstructable() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteVerifyConstructable();
+                        return;
+                    }
+                    target.setVerifyConstructable( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _verifyConstructable
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _version
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_version", "version", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getVersion();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setVersion( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _version
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _description
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_description", "description", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getDescription();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setDescription( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _description
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _cacheTypeMapping
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.CacheTypeMapping.class, "_cacheTypeMapping", "cache-type", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getCacheTypeMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setCacheTypeMapping( (org.exolab.castor.mapping.xml.CacheTypeMapping) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.mapping.xml.CacheTypeMapping");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _cacheTypeMapping
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _mapTo
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.MapTo.class, "_mapTo", "map-to", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getMapTo();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setMapTo( (org.exolab.castor.mapping.xml.MapTo) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.mapping.xml.MapTo");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _mapTo
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _namedQueryList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.NamedQuery.class, "_namedQueryList", "named-query", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getNamedQuery();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.addNamedQuery( (org.exolab.castor.mapping.xml.NamedQuery) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.removeAllNamedQuery();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.NamedQuery");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _namedQueryList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _namedNativeQueryList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.NamedNativeQuery.class, "_namedNativeQueryList", "named-native-query", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getNamedNativeQuery();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.addNamedNativeQuery( (org.exolab.castor.mapping.xml.NamedNativeQuery) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.removeAllNamedNativeQuery();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.NamedNativeQuery");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _namedNativeQueryList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _classChoice
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.ClassChoice.class, "_classChoice", "-error-if-this-is-used-", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassMapping target = (ClassMapping) object;
+                return target.getClassChoice();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassMapping target = (ClassMapping) object;
+                    target.setClassChoice( (org.exolab.castor.mapping.xml.ClassChoice) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.mapping.xml.ClassChoice();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.mapping.xml.ClassChoice");
+        desc.setHandler(handler);
+        desc.setContainer(true);
+        desc.setClassDescriptor(new org.exolab.castor.mapping.xml.descriptors.ClassChoiceDescriptor());
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _classChoice
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.ClassMapping.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/SqlDescriptor.java
@@ -0,0 +1,522 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.Sql;
+
+/**
+ * Class SqlDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class SqlDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public SqlDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "sql";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Sql target = (Sql) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Sql target = (Sql) object;
+                    target.addName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Sql target = (Sql) object;
+                    target.removeAllName();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.CollectionFieldHandler(handler, new org.exolab.castor.xml.validators.NameValidator(org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN));
+        desc.setSchemaType("list");
+        desc.setComponentType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _type
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_type", "type", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Sql target = (Sql) object;
+                return target.getType();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Sql target = (Sql) object;
+                    target.setType( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _type
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _manyTable
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_manyTable", "many-table", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Sql target = (Sql) object;
+                return target.getManyTable();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Sql target = (Sql) object;
+                    target.setManyTable( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _manyTable
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _manyKey
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_manyKey", "many-key", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Sql target = (Sql) object;
+                return target.getManyKey();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Sql target = (Sql) object;
+                    target.addManyKey( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Sql target = (Sql) object;
+                    target.removeAllManyKey();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.CollectionFieldHandler(handler, new org.exolab.castor.xml.validators.NameValidator(org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN));
+        desc.setSchemaType("list");
+        desc.setComponentType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _manyKey
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _cascading
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_cascading", "cascading", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Sql target = (Sql) object;
+                return target.getCascading();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Sql target = (Sql) object;
+                    target.setCascading( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _cascading
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _readOnly
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_readOnly", "read-only", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Sql target = (Sql) object;
+                if (!target.hasReadOnly()) { return null; }
+                return (target.getReadOnly() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Sql target = (Sql) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteReadOnly();
+                        return;
+                    }
+                    target.setReadOnly( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _readOnly
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _transient
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_transient", "transient", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Sql target = (Sql) object;
+                if (!target.hasTransient()) { return null; }
+                return (target.getTransient() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Sql target = (Sql) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteTransient();
+                        return;
+                    }
+                    target.setTransient( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _transient
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _dirty
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.types.SqlDirtyType.class, "_dirty", "dirty", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Sql target = (Sql) object;
+                return target.getDirty();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Sql target = (Sql) object;
+                    target.setDirty( (org.exolab.castor.mapping.xml.types.SqlDirtyType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.mapping.xml.types.SqlDirtyType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("SqlDirtyType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _dirty
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.Sql.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/FieldHandlerDefDescriptor.java
@@ -0,0 +1,308 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.FieldHandlerDef;
+
+/**
+ * Class FieldHandlerDefDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldHandlerDefDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldHandlerDefDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "field-handler";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        this._identity = desc;
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldHandlerDef target = (FieldHandlerDef) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldHandlerDef target = (FieldHandlerDef) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("ID");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.IdValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.IdValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _clazz
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_clazz", "class", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldHandlerDef target = (FieldHandlerDef) object;
+                return target.getClazz();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldHandlerDef target = (FieldHandlerDef) object;
+                    target.setClazz( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _clazz
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _paramList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.Param.class, "_paramList", "param", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldHandlerDef target = (FieldHandlerDef) object;
+                return target.getParam();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldHandlerDef target = (FieldHandlerDef) object;
+                    target.addParam( (org.exolab.castor.mapping.xml.Param) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    FieldHandlerDef target = (FieldHandlerDef) object;
+                    target.removeAllParam();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.Param");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _paramList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.FieldHandlerDef.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/CacheTypeMappingDescriptor.java
@@ -0,0 +1,355 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.CacheTypeMapping;
+
+/**
+ * Class CacheTypeMappingDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class CacheTypeMappingDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public CacheTypeMappingDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "cache-type";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _type
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_type", "type", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                CacheTypeMapping target = (CacheTypeMapping) object;
+                return target.getType();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    CacheTypeMapping target = (CacheTypeMapping) object;
+                    target.setType( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _type
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _debug
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_debug", "debug", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                CacheTypeMapping target = (CacheTypeMapping) object;
+                if (!target.hasDebug()) { return null; }
+                return (target.getDebug() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    CacheTypeMapping target = (CacheTypeMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteDebug();
+                        return;
+                    }
+                    target.setDebug( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _debug
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _capacity
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Long.TYPE, "_capacity", "capacity", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                CacheTypeMapping target = (CacheTypeMapping) object;
+                if (!target.hasCapacity()) { return null; }
+                return new java.lang.Long(target.getCapacity());
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    CacheTypeMapping target = (CacheTypeMapping) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteCapacity();
+                        return;
+                    }
+                    target.setCapacity( ((java.lang.Long) value).longValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("integer");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _capacity
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.LongValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.LongValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _paramList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.Param.class, "_paramList", "param", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                CacheTypeMapping target = (CacheTypeMapping) object;
+                return target.getParam();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    CacheTypeMapping target = (CacheTypeMapping) object;
+                    target.addParam( (org.exolab.castor.mapping.xml.Param) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    CacheTypeMapping target = (CacheTypeMapping) object;
+                    target.removeAllParam();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.Param");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _paramList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.CacheTypeMapping.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/MapToDescriptor.java
@@ -0,0 +1,467 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.MapTo;
+
+/**
+ * Class MapToDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class MapToDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MapToDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "map-to";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _table
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_table", "table", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MapTo target = (MapTo) object;
+                return target.getTable();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MapTo target = (MapTo) object;
+                    target.setTable( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _table
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _xml
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_xml", "xml", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MapTo target = (MapTo) object;
+                return target.getXml();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MapTo target = (MapTo) object;
+                    target.setXml( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _xml
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _nsUri
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_nsUri", "ns-uri", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MapTo target = (MapTo) object;
+                return target.getNsUri();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MapTo target = (MapTo) object;
+                    target.setNsUri( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _nsUri
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _nsPrefix
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_nsPrefix", "ns-prefix", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MapTo target = (MapTo) object;
+                return target.getNsPrefix();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MapTo target = (MapTo) object;
+                    target.setNsPrefix( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _nsPrefix
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _elementDefinition
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_elementDefinition", "element-definition", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MapTo target = (MapTo) object;
+                if (!target.hasElementDefinition()) { return null; }
+                return (target.getElementDefinition() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MapTo target = (MapTo) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteElementDefinition();
+                        return;
+                    }
+                    target.setElementDefinition( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _elementDefinition
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _ldapDn
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_ldapDn", "ldap-dn", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MapTo target = (MapTo) object;
+                return target.getLdapDn();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MapTo target = (MapTo) object;
+                    target.setLdapDn( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _ldapDn
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _ldapOc
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_ldapOc", "ldap-oc", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                MapTo target = (MapTo) object;
+                return target.getLdapOc();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    MapTo target = (MapTo) object;
+                    target.setLdapOc( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _ldapOc
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.MapTo.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/PropertyDescriptor.java
@@ -0,0 +1,165 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.Property;
+
+/**
+ * Class PropertyDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PropertyDescriptor extends org.exolab.castor.mapping.xml.descriptors.PropertyTypeDescriptor {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PropertyDescriptor() {
+        super();
+        setExtendsWithoutFlatten(new org.exolab.castor.mapping.xml.descriptors.PropertyTypeDescriptor());
+        _xmlName = "property";
+        _elementDefinition = true;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        if (_identity == null) {
+            return super.getIdentity();
+        }
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.Property.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/KeyGeneratorDefDescriptor.java
@@ -0,0 +1,306 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.KeyGeneratorDef;
+
+/**
+ * Class KeyGeneratorDefDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class KeyGeneratorDefDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public KeyGeneratorDefDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "key-generator";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        this._identity = desc;
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                KeyGeneratorDef target = (KeyGeneratorDef) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    KeyGeneratorDef target = (KeyGeneratorDef) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("ID");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.IdValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.IdValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _alias
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_alias", "alias", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                KeyGeneratorDef target = (KeyGeneratorDef) object;
+                return target.getAlias();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    KeyGeneratorDef target = (KeyGeneratorDef) object;
+                    target.setAlias( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _alias
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _paramList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.Param.class, "_paramList", "param", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                KeyGeneratorDef target = (KeyGeneratorDef) object;
+                return target.getParam();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    KeyGeneratorDef target = (KeyGeneratorDef) object;
+                    target.addParam( (org.exolab.castor.mapping.xml.Param) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    KeyGeneratorDef target = (KeyGeneratorDef) object;
+                    target.removeAllParam();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.Param");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _paramList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.KeyGeneratorDef.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/ClassChoiceDescriptor.java
@@ -0,0 +1,269 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.ClassChoice;
+
+/**
+ * Class ClassChoiceDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ClassChoiceDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassChoiceDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsChoice();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _fieldMappingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.FieldMapping.class, "_fieldMappingList", "field", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassChoice target = (ClassChoice) object;
+                return target.getFieldMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassChoice target = (ClassChoice) object;
+                    target.addFieldMapping( (org.exolab.castor.mapping.xml.FieldMapping) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ClassChoice target = (ClassChoice) object;
+                    target.removeAllFieldMapping();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.FieldMapping");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _fieldMappingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _containerList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.Container.class, "_containerList", "container", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassChoice target = (ClassChoice) object;
+                return target.getContainer();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassChoice target = (ClassChoice) object;
+                    target.addContainer( (org.exolab.castor.mapping.xml.Container) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ClassChoice target = (ClassChoice) object;
+                    target.removeAllContainer();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.Container");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _containerList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.ClassChoice.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/BindXmlDescriptor.java
@@ -0,0 +1,639 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.BindXml;
+
+/**
+ * Class BindXmlDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class BindXmlDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public BindXmlDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "bind-xml";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setSchemaType("QName");
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("QName");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_QNAME);
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _type
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_type", "type", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getType();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.setType( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _type
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _autoNaming
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType.class, "_autoNaming", "auto-naming", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getAutoNaming();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.setAutoNaming( (org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("BindXmlAutoNamingType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _autoNaming
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _location
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_location", "location", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getLocation();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.setLocation( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _location
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _matches
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_matches", "matches", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getMatches();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.setMatches( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _matches
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _reference
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_reference", "reference", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                if (!target.hasReference()) { return null; }
+                return (target.getReference() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteReference();
+                        return;
+                    }
+                    target.setReference( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _reference
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _node
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.types.BindXmlNodeType.class, "_node", "node", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getNode();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.setNode( (org.exolab.castor.mapping.xml.types.BindXmlNodeType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.mapping.xml.types.BindXmlNodeType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("BindXmlNodeType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _node
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _QNamePrefix
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_QNamePrefix", "QName-prefix", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getQNamePrefix();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.setQNamePrefix( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _QNamePrefix
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _transient
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_transient", "transient", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                if (!target.hasTransient()) { return null; }
+                return (target.getTransient() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteTransient();
+                        return;
+                    }
+                    target.setTransient( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _transient
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _classMapping
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.ClassMapping.class, "_classMapping", "class", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getClassMapping();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.setClassMapping( (org.exolab.castor.mapping.xml.ClassMapping) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.mapping.xml.ClassMapping");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://castor.exolab.org/");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _classMapping
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _propertyList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.mapping.xml.Property.class, "_propertyList", "property", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                BindXml target = (BindXml) object;
+                return target.getProperty();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.addProperty( (org.exolab.castor.mapping.xml.Property) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    BindXml target = (BindXml) object;
+                    target.removeAllProperty();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.mapping.xml.Property");
+        desc.setHandler(handler);
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _propertyList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.BindXml.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/QueryHintDescriptor.java
@@ -0,0 +1,257 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.QueryHint;
+
+/**
+ * Class QueryHintDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class QueryHintDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public QueryHintDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "query-hint";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                QueryHint target = (QueryHint) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    QueryHint target = (QueryHint) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _value
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_value", "value", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                QueryHint target = (QueryHint) object;
+                return target.getValue();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    QueryHint target = (QueryHint) object;
+                    target.setValue( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _value
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.QueryHint.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/descriptors/LdapDescriptor.java
@@ -0,0 +1,211 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.Ldap;
+
+/**
+ * Class LdapDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class LdapDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public LdapDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "ldap";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            @Override
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Ldap target = (Ldap) object;
+                return target.getName();
+            }
+            @Override
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Ldap target = (Ldap) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            @Override
+            @SuppressWarnings("unused")
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("NMTOKEN");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.NameValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.NameValidator(
+                org.exolab.castor.xml.XMLConstants.NAME_TYPE_NMTOKEN);
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.addPattern("[\\w-._:]+");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.Ldap.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/.castor.cdr
@@ -0,0 +1,6 @@
+#Sun Jan 22 02:11:58 UTC 2012
+org.exolab.castor.mapping.xml.types.SqlDirtyType=org.exolab.castor.mapping.xml.types.descriptors.SqlDirtyTypeDescriptor
+org.exolab.castor.mapping.xml.types.FieldMappingCollectionType=org.exolab.castor.mapping.xml.types.descriptors.FieldMappingCollectionTypeDescriptor
+org.exolab.castor.mapping.xml.types.ClassMappingAccessType=org.exolab.castor.mapping.xml.types.descriptors.ClassMappingAccessTypeDescriptor
+org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType=org.exolab.castor.mapping.xml.types.descriptors.BindXmlAutoNamingTypeDescriptor
+org.exolab.castor.mapping.xml.types.BindXmlNodeType=org.exolab.castor.mapping.xml.types.descriptors.BindXmlNodeTypeDescriptor
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/SqlDirtyType.java
@@ -0,0 +1,111 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types;
+
+/**
+ * Enumeration SqlDirtyType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public enum SqlDirtyType {
+
+
+      //------------------/
+     //- Enum Constants -/
+    //------------------/
+
+    /**
+     * Constant CHECK
+     */
+    CHECK("check"),
+    /**
+     * Constant IGNORE
+     */
+    IGNORE("ignore");
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field value.
+     */
+    private final java.lang.String value;
+
+    /**
+     * Field enumConstants.
+     */
+    private static final java.util.Map<java.lang.String, SqlDirtyType> enumConstants = new java.util.HashMap<java.lang.String, SqlDirtyType>();
+
+
+    static {
+        for (SqlDirtyType c: SqlDirtyType.values()) {
+            SqlDirtyType.enumConstants.put(c.value, c);
+        }
+
+    };
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private SqlDirtyType(final java.lang.String value) {
+        this.value = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method fromValue.
+     * 
+     * @param value
+     * @return the constant for this value
+     */
+    public static org.exolab.castor.mapping.xml.types.SqlDirtyType fromValue(
+            final java.lang.String value) {
+        SqlDirtyType c = SqlDirtyType.enumConstants.get(value);
+        if (c != null) {
+            return c;
+        }
+        throw new IllegalArgumentException(value);
+    }
+
+    /**
+     * 
+     * 
+     * @param value
+     */
+    public void setValue(
+            final java.lang.String value) {
+    }
+
+    /**
+     * Method toString.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String toString(
+    ) {
+        return this.value;
+    }
+
+    /**
+     * Method value.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String value(
+    ) {
+        return this.value;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/FieldMappingCollectionType.java
@@ -0,0 +1,147 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types;
+
+/**
+ * Enumeration FieldMappingCollectionType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public enum FieldMappingCollectionType {
+
+
+      //------------------/
+     //- Enum Constants -/
+    //------------------/
+
+    /**
+     * Constant ARRAY
+     */
+    ARRAY("array"),
+    /**
+     * Constant VECTOR
+     */
+    VECTOR("vector"),
+    /**
+     * Constant ARRAYLIST
+     */
+    ARRAYLIST("arraylist"),
+    /**
+     * Constant HASHTABLE
+     */
+    HASHTABLE("hashtable"),
+    /**
+     * Constant COLLECTION
+     */
+    COLLECTION("collection"),
+    /**
+     * Constant SET
+     */
+    SET("set"),
+    /**
+     * Constant MAP
+     */
+    MAP("map"),
+    /**
+     * Constant ENUMERATE
+     */
+    ENUMERATE("enumerate"),
+    /**
+     * Constant SORTEDSET
+     */
+    SORTEDSET("sortedset"),
+    /**
+     * Constant ITERATOR
+     */
+    ITERATOR("iterator"),
+    /**
+     * Constant SORTEDMAP
+     */
+    SORTEDMAP("sortedmap");
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field value.
+     */
+    private final java.lang.String value;
+
+    /**
+     * Field enumConstants.
+     */
+    private static final java.util.Map<java.lang.String, FieldMappingCollectionType> enumConstants = new java.util.HashMap<java.lang.String, FieldMappingCollectionType>();
+
+
+    static {
+        for (FieldMappingCollectionType c: FieldMappingCollectionType.values()) {
+            FieldMappingCollectionType.enumConstants.put(c.value, c);
+        }
+
+    };
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private FieldMappingCollectionType(final java.lang.String value) {
+        this.value = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method fromValue.
+     * 
+     * @param value
+     * @return the constant for this value
+     */
+    public static org.exolab.castor.mapping.xml.types.FieldMappingCollectionType fromValue(
+            final java.lang.String value) {
+        FieldMappingCollectionType c = FieldMappingCollectionType.enumConstants.get(value);
+        if (c != null) {
+            return c;
+        }
+        throw new IllegalArgumentException(value);
+    }
+
+    /**
+     * 
+     * 
+     * @param value
+     */
+    public void setValue(
+            final java.lang.String value) {
+    }
+
+    /**
+     * Method toString.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String toString(
+    ) {
+        return this.value;
+    }
+
+    /**
+     * Method value.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String value(
+    ) {
+        return this.value;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/ClassMappingAccessType.java
@@ -0,0 +1,119 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types;
+
+/**
+ * Enumeration ClassMappingAccessType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public enum ClassMappingAccessType {
+
+
+      //------------------/
+     //- Enum Constants -/
+    //------------------/
+
+    /**
+     * Constant READ_ONLY
+     */
+    READ_ONLY("read-only"),
+    /**
+     * Constant SHARED
+     */
+    SHARED("shared"),
+    /**
+     * Constant EXCLUSIVE
+     */
+    EXCLUSIVE("exclusive"),
+    /**
+     * Constant DB_LOCKED
+     */
+    DB_LOCKED("db-locked");
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field value.
+     */
+    private final java.lang.String value;
+
+    /**
+     * Field enumConstants.
+     */
+    private static final java.util.Map<java.lang.String, ClassMappingAccessType> enumConstants = new java.util.HashMap<java.lang.String, ClassMappingAccessType>();
+
+
+    static {
+        for (ClassMappingAccessType c: ClassMappingAccessType.values()) {
+            ClassMappingAccessType.enumConstants.put(c.value, c);
+        }
+
+    };
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private ClassMappingAccessType(final java.lang.String value) {
+        this.value = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method fromValue.
+     * 
+     * @param value
+     * @return the constant for this value
+     */
+    public static org.exolab.castor.mapping.xml.types.ClassMappingAccessType fromValue(
+            final java.lang.String value) {
+        ClassMappingAccessType c = ClassMappingAccessType.enumConstants.get(value);
+        if (c != null) {
+            return c;
+        }
+        throw new IllegalArgumentException(value);
+    }
+
+    /**
+     * 
+     * 
+     * @param value
+     */
+    public void setValue(
+            final java.lang.String value) {
+    }
+
+    /**
+     * Method toString.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String toString(
+    ) {
+        return this.value;
+    }
+
+    /**
+     * Method value.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String value(
+    ) {
+        return this.value;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/BindXmlAutoNamingType.java
@@ -0,0 +1,111 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types;
+
+/**
+ * Enumeration BindXmlAutoNamingType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public enum BindXmlAutoNamingType {
+
+
+      //------------------/
+     //- Enum Constants -/
+    //------------------/
+
+    /**
+     * Constant DERIVEBYCLASS
+     */
+    DERIVEBYCLASS("deriveByClass"),
+    /**
+     * Constant DERIVEBYFIELD
+     */
+    DERIVEBYFIELD("deriveByField");
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field value.
+     */
+    private final java.lang.String value;
+
+    /**
+     * Field enumConstants.
+     */
+    private static final java.util.Map<java.lang.String, BindXmlAutoNamingType> enumConstants = new java.util.HashMap<java.lang.String, BindXmlAutoNamingType>();
+
+
+    static {
+        for (BindXmlAutoNamingType c: BindXmlAutoNamingType.values()) {
+            BindXmlAutoNamingType.enumConstants.put(c.value, c);
+        }
+
+    };
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private BindXmlAutoNamingType(final java.lang.String value) {
+        this.value = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method fromValue.
+     * 
+     * @param value
+     * @return the constant for this value
+     */
+    public static org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType fromValue(
+            final java.lang.String value) {
+        BindXmlAutoNamingType c = BindXmlAutoNamingType.enumConstants.get(value);
+        if (c != null) {
+            return c;
+        }
+        throw new IllegalArgumentException(value);
+    }
+
+    /**
+     * 
+     * 
+     * @param value
+     */
+    public void setValue(
+            final java.lang.String value) {
+    }
+
+    /**
+     * Method toString.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String toString(
+    ) {
+        return this.value;
+    }
+
+    /**
+     * Method value.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String value(
+    ) {
+        return this.value;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/BindXmlNodeType.java
@@ -0,0 +1,119 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types;
+
+/**
+ * Enumeration BindXmlNodeType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public enum BindXmlNodeType {
+
+
+      //------------------/
+     //- Enum Constants -/
+    //------------------/
+
+    /**
+     * Constant ATTRIBUTE
+     */
+    ATTRIBUTE("attribute"),
+    /**
+     * Constant ELEMENT
+     */
+    ELEMENT("element"),
+    /**
+     * Constant NAMESPACE
+     */
+    NAMESPACE("namespace"),
+    /**
+     * Constant TEXT
+     */
+    TEXT("text");
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field value.
+     */
+    private final java.lang.String value;
+
+    /**
+     * Field enumConstants.
+     */
+    private static final java.util.Map<java.lang.String, BindXmlNodeType> enumConstants = new java.util.HashMap<java.lang.String, BindXmlNodeType>();
+
+
+    static {
+        for (BindXmlNodeType c: BindXmlNodeType.values()) {
+            BindXmlNodeType.enumConstants.put(c.value, c);
+        }
+
+    };
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private BindXmlNodeType(final java.lang.String value) {
+        this.value = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method fromValue.
+     * 
+     * @param value
+     * @return the constant for this value
+     */
+    public static org.exolab.castor.mapping.xml.types.BindXmlNodeType fromValue(
+            final java.lang.String value) {
+        BindXmlNodeType c = BindXmlNodeType.enumConstants.get(value);
+        if (c != null) {
+            return c;
+        }
+        throw new IllegalArgumentException(value);
+    }
+
+    /**
+     * 
+     * 
+     * @param value
+     */
+    public void setValue(
+            final java.lang.String value) {
+    }
+
+    /**
+     * Method toString.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String toString(
+    ) {
+        return this.value;
+    }
+
+    /**
+     * Method value.
+     * 
+     * @return the value of this constant
+     */
+    public java.lang.String value(
+    ) {
+        return this.value;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/descriptors/BindXmlAutoNamingTypeDescriptor.java
@@ -0,0 +1,162 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType;
+
+/**
+ * Class BindXmlAutoNamingTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class BindXmlAutoNamingTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public BindXmlAutoNamingTypeDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "BindXmlAutoNamingType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.types.BindXmlAutoNamingType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/descriptors/SqlDirtyTypeDescriptor.java
@@ -0,0 +1,162 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.types.SqlDirtyType;
+
+/**
+ * Class SqlDirtyTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class SqlDirtyTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public SqlDirtyTypeDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "SqlDirtyType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.types.SqlDirtyType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/descriptors/ClassMappingAccessTypeDescriptor.java
@@ -0,0 +1,162 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.types.ClassMappingAccessType;
+
+/**
+ * Class ClassMappingAccessTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ClassMappingAccessTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassMappingAccessTypeDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "ClassMappingAccessType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.types.ClassMappingAccessType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/descriptors/FieldMappingCollectionTypeDescriptor.java
@@ -0,0 +1,162 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.types.FieldMappingCollectionType;
+
+/**
+ * Class FieldMappingCollectionTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldMappingCollectionTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldMappingCollectionTypeDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "FieldMappingCollectionType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.types.FieldMappingCollectionType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.2/xml/src/main/java/org/exolab/castor/mapping/xml/types/descriptors/BindXmlNodeTypeDescriptor.java
@@ -0,0 +1,162 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.mapping.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.mapping.xml.types.BindXmlNodeType;
+
+/**
+ * Class BindXmlNodeTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class BindXmlNodeTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public BindXmlNodeTypeDescriptor() {
+        super();
+        _nsURI = "http://castor.exolab.org/";
+        _xmlName = "BindXmlNodeType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    @Override()
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    @Override()
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    @Override()
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.mapping.xml.types.BindXmlNodeType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    @Override()
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    @Override()
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    @Override()
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
