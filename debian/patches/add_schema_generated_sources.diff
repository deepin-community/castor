Description: add autogenerated sources to schema module
 These classes were generated with castor-maven-plugin.
 The reason why they are not generated at build time is because
 castor-maven-plugin is not available in Debian since it depends on this
 package. When castor gets accepted in the archive, castor-maven-plugin will be
 packaged and when it gets accepted in the archive, this package will re rebuilt
 with that plugin and this patch will be removed.
Author: Miguel Landaeta <miguel@miguel.cc>
Forwarded: not-needed
Last-Update: 2010-06-27

--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/.castor.cdr
@@ -0,0 +1,9 @@
+#Sat Jun 12 20:14:23 VET 2010
+org.exolab.castor.xml.schema.annotations.jdo.ManyToMany=org.exolab.castor.xml.schema.annotations.jdo.descriptors.ManyToManyDescriptor
+org.exolab.castor.xml.schema.annotations.jdo.Column=org.exolab.castor.xml.schema.annotations.jdo.descriptors.ColumnDescriptor
+org.exolab.castor.xml.schema.annotations.jdo.OneToMany=org.exolab.castor.xml.schema.annotations.jdo.descriptors.OneToManyDescriptor
+org.exolab.castor.xml.schema.annotations.jdo.OneToOne=org.exolab.castor.xml.schema.annotations.jdo.descriptors.OneToOneDescriptor
+org.exolab.castor.xml.schema.annotations.jdo.PkType=org.exolab.castor.xml.schema.annotations.jdo.descriptors.PkTypeDescriptor
+org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey=org.exolab.castor.xml.schema.annotations.jdo.descriptors.PrimaryKeyDescriptor
+org.exolab.castor.xml.schema.annotations.jdo.Table=org.exolab.castor.xml.schema.annotations.jdo.descriptors.TableDescriptor
+org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType=org.exolab.castor.xml.schema.annotations.jdo.descriptors.ReadonlyDirtyTypeDescriptor
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/OneToMany.java
@@ -0,0 +1,153 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo;
+
+/**
+ * Class OneToMany.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class OneToMany extends org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType 
+implements java.io.Serializable
+{
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name attribute specifies the name of
+     *  the column that represents this
+     *  relation.
+     *  
+     */
+    private java.lang.String _name;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public OneToMany() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'. The field 'name' has the
+     * following description: The name attribute specifies the name
+     * of
+     *  the column that represents this
+     *  relation.
+     *  
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'. The field 'name' has the
+     * following description: The name attribute specifies the name
+     * of
+     *  the column that represents this
+     *  relation.
+     *  
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyTyp
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.xml.schema.annotations.jdo.OneToMany.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/Column.java
@@ -0,0 +1,259 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo;
+
+/**
+ * Element 'column' is used to specify the column where the
+ *  property of an object will be saved.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class Column extends org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType 
+implements java.io.Serializable
+{
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Attribute 'name' is used to specify the
+     *  name of the column.
+     *  
+     */
+    private java.lang.String _name;
+
+    /**
+     * Attribute 'type' is used to specify the
+     *  JDO-type of the column.
+     *  
+     */
+    private java.lang.String _type;
+
+    /**
+     * Specifies if this field accepts NULL
+     *  values or not.
+     *  
+     */
+    private boolean _acceptNull = true;
+
+    /**
+     * keeps track of state for field: _acceptNull
+     */
+    private boolean _has_acceptNull;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Column() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     */
+    public void deleteAcceptNull(
+    ) {
+        this._has_acceptNull= false;
+    }
+
+    /**
+     * Returns the value of field 'acceptNull'. The field
+     * 'acceptNull' has the following description: Specifies if
+     * this field accepts NULL
+     *  values or not.
+     *  
+     * 
+     * @return the value of field 'AcceptNull'.
+     */
+    public boolean getAcceptNull(
+    ) {
+        return this._acceptNull;
+    }
+
+    /**
+     * Returns the value of field 'name'. The field 'name' has the
+     * following description: Attribute 'name' is used to specify
+     * the
+     *  name of the column.
+     *  
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'type'. The field 'type' has the
+     * following description: Attribute 'type' is used to specify
+     * the
+     *  JDO-type of the column.
+     *  
+     * 
+     * @return the value of field 'Type'.
+     */
+    public java.lang.String getType(
+    ) {
+        return this._type;
+    }
+
+    /**
+     * Method hasAcceptNull.
+     * 
+     * @return true if at least one AcceptNull has been added
+     */
+    public boolean hasAcceptNull(
+    ) {
+        return this._has_acceptNull;
+    }
+
+    /**
+     * Returns the value of field 'acceptNull'. The field
+     * 'acceptNull' has the following description: Specifies if
+     * this field accepts NULL
+     *  values or not.
+     *  
+     * 
+     * @return the value of field 'AcceptNull'.
+     */
+    public boolean isAcceptNull(
+    ) {
+        return this._acceptNull;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'acceptNull'. The field 'acceptNull'
+     * has the following description: Specifies if this field
+     * accepts NULL
+     *  values or not.
+     *  
+     * 
+     * @param acceptNull the value of field 'acceptNull'.
+     */
+    public void setAcceptNull(
+            final boolean acceptNull) {
+        this._acceptNull = acceptNull;
+        this._has_acceptNull = true;
+    }
+
+    /**
+     * Sets the value of field 'name'. The field 'name' has the
+     * following description: Attribute 'name' is used to specify
+     * the
+     *  name of the column.
+     *  
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'type'. The field 'type' has the
+     * following description: Attribute 'type' is used to specify
+     * the
+     *  JDO-type of the column.
+     *  
+     * 
+     * @param type the value of field 'type'.
+     */
+    public void setType(
+            final java.lang.String type) {
+        this._type = type;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyTyp
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.xml.schema.annotations.jdo.Column.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/ManyToMany.java
@@ -0,0 +1,157 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo;
+
+/**
+ * Class ManyToMany.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ManyToMany implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name attribute specifies the name of the
+     *  column that represents this relation. Note that
+     *  you do not need to specify the name for the
+     *  additional table created to realize the many to
+     *  many relation (this is done implicitly).
+     *  
+     */
+    private java.lang.String _name;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ManyToMany() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'. The field 'name' has the
+     * following description: The name attribute specifies the name
+     * of the
+     *  column that represents this relation. Note that
+     *  you do not need to specify the name for the
+     *  additional table created to realize the many to
+     *  many relation (this is done implicitly).
+     *  
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'. The field 'name' has the
+     * following description: The name attribute specifies the name
+     * of the
+     *  column that represents this relation. Note that
+     *  you do not need to specify the name for the
+     *  additional table created to realize the many to
+     *  many relation (this is done implicitly).
+     *  
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.xml.schema.annotations.jdo.ManyToMany
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.ManyToMany unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.xml.schema.annotations.jdo.ManyToMany) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.xml.schema.annotations.jdo.ManyToMany.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/PkType.java
@@ -0,0 +1,279 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo;
+
+/**
+ * Class PkType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PkType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _keyList.
+     */
+    private java.util.List _keyList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PkType() {
+        super();
+        this._keyList = new java.util.ArrayList();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vKey
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addKey(
+            final java.lang.String vKey)
+    throws java.lang.IndexOutOfBoundsException {
+        this._keyList.add(vKey);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vKey
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addKey(
+            final int index,
+            final java.lang.String vKey)
+    throws java.lang.IndexOutOfBoundsException {
+        this._keyList.add(index, vKey);
+    }
+
+    /**
+     * Method enumerateKey.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateKey(
+    ) {
+        return java.util.Collections.enumeration(this._keyList);
+    }
+
+    /**
+     * Method getKey.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the java.lang.String at the given index
+     */
+    public java.lang.String getKey(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._keyList.size()) {
+            throw new IndexOutOfBoundsException("getKey: Index value '" + index + "' not in range [0.." + (this._keyList.size() - 1) + "]");
+        }
+
+        return (java.lang.String) _keyList.get(index);
+    }
+
+    /**
+     * Method getKey.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public java.lang.String[] getKey(
+    ) {
+        java.lang.String[] array = new java.lang.String[0];
+        return (java.lang.String[]) this._keyList.toArray(array);
+    }
+
+    /**
+     * Method getKeyCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getKeyCount(
+    ) {
+        return this._keyList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateKey.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateKey(
+    ) {
+        return this._keyList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllKey(
+    ) {
+        this._keyList.clear();
+    }
+
+    /**
+     * Method removeKey.
+     * 
+     * @param vKey
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeKey(
+            final java.lang.String vKey) {
+        boolean removed = _keyList.remove(vKey);
+        return removed;
+    }
+
+    /**
+     * Method removeKeyAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public java.lang.String removeKeyAt(
+            final int index) {
+        java.lang.Object obj = this._keyList.remove(index);
+        return (java.lang.String) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vKey
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setKey(
+            final int index,
+            final java.lang.String vKey)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._keyList.size()) {
+            throw new IndexOutOfBoundsException("setKey: Index value '" + index + "' not in range [0.." + (this._keyList.size() - 1) + "]");
+        }
+
+        this._keyList.set(index, vKey);
+    }
+
+    /**
+     * 
+     * 
+     * @param vKeyArray
+     */
+    public void setKey(
+            final java.lang.String[] vKeyArray) {
+        //-- copy array
+        _keyList.clear();
+
+        for (int i = 0; i < vKeyArray.length; i++) {
+                this._keyList.add(vKeyArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.xml.schema.annotations.jdo.PkType
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.PkType unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.xml.schema.annotations.jdo.PkType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.xml.schema.annotations.jdo.PkType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/OneToOne.java
@@ -0,0 +1,153 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo;
+
+/**
+ * Class OneToOne.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class OneToOne extends org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType 
+implements java.io.Serializable
+{
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The name attribute specifies the name of
+     *  the column that represents this
+     *  relation.
+     *  
+     */
+    private java.lang.String _name;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public OneToOne() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'. The field 'name' has the
+     * following description: The name attribute specifies the name
+     * of
+     *  the column that represents this
+     *  relation.
+     *  
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'. The field 'name' has the
+     * following description: The name attribute specifies the name
+     * of
+     *  the column that represents this
+     *  relation.
+     *  
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyTyp
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.xml.schema.annotations.jdo.OneToOne.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/Table.java
@@ -0,0 +1,277 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo;
+
+/**
+ * Element 'table' is used to specify the table where the
+ *  Object will be saved.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class Table implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Attribute 'name' is used to specify the name of
+     *  the table.
+     *  
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _accessMode.
+     */
+    private org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType _accessMode = org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType.valueOf("shared");
+
+    /**
+     * Attribute 'detachable' is used to indicate that the 
+     *  domain entity generated will support Castor JDO
+     *  long transactions out of the box. 
+     *  
+     */
+    private boolean _detachable = false;
+
+    /**
+     * keeps track of state for field: _detachable
+     */
+    private boolean _has_detachable;
+
+    /**
+     * Field _primaryKey.
+     */
+    private org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey _primaryKey;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Table() {
+        super();
+        setAccessMode(org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType.valueOf("shared"));
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     */
+    public void deleteDetachable(
+    ) {
+        this._has_detachable= false;
+    }
+
+    /**
+     * Returns the value of field 'accessMode'.
+     * 
+     * @return the value of field 'AccessMode'.
+     */
+    public org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType getAccessMode(
+    ) {
+        return this._accessMode;
+    }
+
+    /**
+     * Returns the value of field 'detachable'. The field
+     * 'detachable' has the following description: Attribute
+     * 'detachable' is used to indicate that the 
+     *  domain entity generated will support Castor JDO
+     *  long transactions out of the box. 
+     *  
+     * 
+     * @return the value of field 'Detachable'.
+     */
+    public boolean getDetachable(
+    ) {
+        return this._detachable;
+    }
+
+    /**
+     * Returns the value of field 'name'. The field 'name' has the
+     * following description: Attribute 'name' is used to specify
+     * the name of
+     *  the table.
+     *  
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'primaryKey'.
+     * 
+     * @return the value of field 'PrimaryKey'.
+     */
+    public org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey getPrimaryKey(
+    ) {
+        return this._primaryKey;
+    }
+
+    /**
+     * Method hasDetachable.
+     * 
+     * @return true if at least one Detachable has been added
+     */
+    public boolean hasDetachable(
+    ) {
+        return this._has_detachable;
+    }
+
+    /**
+     * Returns the value of field 'detachable'. The field
+     * 'detachable' has the following description: Attribute
+     * 'detachable' is used to indicate that the 
+     *  domain entity generated will support Castor JDO
+     *  long transactions out of the box. 
+     *  
+     * 
+     * @return the value of field 'Detachable'.
+     */
+    public boolean isDetachable(
+    ) {
+        return this._detachable;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'accessMode'.
+     * 
+     * @param accessMode the value of field 'accessMode'.
+     */
+    public void setAccessMode(
+            final org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType accessMode) {
+        this._accessMode = accessMode;
+    }
+
+    /**
+     * Sets the value of field 'detachable'. The field 'detachable'
+     * has the following description: Attribute 'detachable' is
+     * used to indicate that the 
+     *  domain entity generated will support Castor JDO
+     *  long transactions out of the box. 
+     *  
+     * 
+     * @param detachable the value of field 'detachable'.
+     */
+    public void setDetachable(
+            final boolean detachable) {
+        this._detachable = detachable;
+        this._has_detachable = true;
+    }
+
+    /**
+     * Sets the value of field 'name'. The field 'name' has the
+     * following description: Attribute 'name' is used to specify
+     * the name of
+     *  the table.
+     *  
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'primaryKey'.
+     * 
+     * @param primaryKey the value of field 'primaryKey'.
+     */
+    public void setPrimaryKey(
+            final org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey primaryKey) {
+        this._primaryKey = primaryKey;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.xml.schema.annotations.jdo.Table
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.Table unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.xml.schema.annotations.jdo.Table) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.xml.schema.annotations.jdo.Table.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/ReadonlyDirtyType.java
@@ -0,0 +1,257 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo;
+
+/**
+ * Class ReadonlyDirtyType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ReadonlyDirtyType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Attribute 'read-only' is used to set off changing
+     *  the column. If true, no update can be performed.
+     *  
+     */
+    private boolean _readOnly = false;
+
+    /**
+     * keeps track of state for field: _readOnly
+     */
+    private boolean _has_readOnly;
+
+    /**
+     * If the value is 'true', the field will not be
+     *  checked against the database for modification.
+     *  
+     */
+    private boolean _dirty = false;
+
+    /**
+     * keeps track of state for field: _dirty
+     */
+    private boolean _has_dirty;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ReadonlyDirtyType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     */
+    public void deleteDirty(
+    ) {
+        this._has_dirty= false;
+    }
+
+    /**
+     */
+    public void deleteReadOnly(
+    ) {
+        this._has_readOnly= false;
+    }
+
+    /**
+     * Returns the value of field 'dirty'. The field 'dirty' has
+     * the following description: If the value is 'true', the field
+     * will not be
+     *  checked against the database for modification.
+     *  
+     * 
+     * @return the value of field 'Dirty'.
+     */
+    public boolean getDirty(
+    ) {
+        return this._dirty;
+    }
+
+    /**
+     * Returns the value of field 'readOnly'. The field 'readOnly'
+     * has the following description: Attribute 'read-only' is used
+     * to set off changing
+     *  the column. If true, no update can be performed.
+     *  
+     * 
+     * @return the value of field 'ReadOnly'.
+     */
+    public boolean getReadOnly(
+    ) {
+        return this._readOnly;
+    }
+
+    /**
+     * Method hasDirty.
+     * 
+     * @return true if at least one Dirty has been added
+     */
+    public boolean hasDirty(
+    ) {
+        return this._has_dirty;
+    }
+
+    /**
+     * Method hasReadOnly.
+     * 
+     * @return true if at least one ReadOnly has been added
+     */
+    public boolean hasReadOnly(
+    ) {
+        return this._has_readOnly;
+    }
+
+    /**
+     * Returns the value of field 'dirty'. The field 'dirty' has
+     * the following description: If the value is 'true', the field
+     * will not be
+     *  checked against the database for modification.
+     *  
+     * 
+     * @return the value of field 'Dirty'.
+     */
+    public boolean isDirty(
+    ) {
+        return this._dirty;
+    }
+
+    /**
+     * Returns the value of field 'readOnly'. The field 'readOnly'
+     * has the following description: Attribute 'read-only' is used
+     * to set off changing
+     *  the column. If true, no update can be performed.
+     *  
+     * 
+     * @return the value of field 'ReadOnly'.
+     */
+    public boolean isReadOnly(
+    ) {
+        return this._readOnly;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'dirty'. The field 'dirty' has the
+     * following description: If the value is 'true', the field
+     * will not be
+     *  checked against the database for modification.
+     *  
+     * 
+     * @param dirty the value of field 'dirty'.
+     */
+    public void setDirty(
+            final boolean dirty) {
+        this._dirty = dirty;
+        this._has_dirty = true;
+    }
+
+    /**
+     * Sets the value of field 'readOnly'. The field 'readOnly' has
+     * the following description: Attribute 'read-only' is used to
+     * set off changing
+     *  the column. If true, no update can be performed.
+     *  
+     * 
+     * @param readOnly the value of field 'readOnly'.
+     */
+    public void setReadOnly(
+            final boolean readOnly) {
+        this._readOnly = readOnly;
+        this._has_readOnly = true;
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyTyp
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/PrimaryKey.java
@@ -0,0 +1,110 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo;
+
+/**
+ * Class PrimaryKey.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PrimaryKey extends PkType 
+implements java.io.Serializable
+{
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PrimaryKey() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Method unmarshal.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.xml.schema.annotations.jdo.PkType
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.PkType unmarshal(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.xml.schema.annotations.jdo.PkType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/types/.castor.cdr
@@ -0,0 +1,2 @@
+#Sat Jun 12 20:14:23 VET 2010
+org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType=org.exolab.castor.xml.schema.annotations.jdo.types.descriptors.TableAccessModeTypeDescriptor
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/types/TableAccessModeType.java
@@ -0,0 +1,173 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.types;
+
+/**
+ * Class TableAccessModeType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class TableAccessModeType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The read-only type
+     */
+    public static final int READ_ONLY_TYPE = 0;
+
+    /**
+     * The instance of the read-only type
+     */
+    public static final TableAccessModeType READ_ONLY = new TableAccessModeType(READ_ONLY_TYPE, "read-only");
+
+    /**
+     * The shared type
+     */
+    public static final int SHARED_TYPE = 1;
+
+    /**
+     * The instance of the shared type
+     */
+    public static final TableAccessModeType SHARED = new TableAccessModeType(SHARED_TYPE, "shared");
+
+    /**
+     * The exclusive type
+     */
+    public static final int EXCLUSIVE_TYPE = 2;
+
+    /**
+     * The instance of the exclusive type
+     */
+    public static final TableAccessModeType EXCLUSIVE = new TableAccessModeType(EXCLUSIVE_TYPE, "exclusive");
+
+    /**
+     * The db-locked type
+     */
+    public static final int DB_LOCKED_TYPE = 3;
+
+    /**
+     * The instance of the db-locked type
+     */
+    public static final TableAccessModeType DB_LOCKED = new TableAccessModeType(DB_LOCKED_TYPE, "db-locked");
+
+    /**
+     * Field _memberTable.
+     */
+    private static java.util.Hashtable _memberTable = init();
+
+    /**
+     * Field type.
+     */
+    private final int type;
+
+    /**
+     * Field stringValue.
+     */
+    private java.lang.String stringValue = null;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private TableAccessModeType(final int type, final java.lang.String value) {
+        super();
+        this.type = type;
+        this.stringValue = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method enumerate.Returns an enumeration of all possible
+     * instances of TableAccessModeType
+     * 
+     * @return an Enumeration over all possible instances of
+     * TableAccessModeType
+     */
+    public static java.util.Enumeration enumerate(
+    ) {
+        return _memberTable.elements();
+    }
+
+    /**
+     * Method getType.Returns the type of this TableAccessModeType
+     * 
+     * @return the type of this TableAccessModeType
+     */
+    public int getType(
+    ) {
+        return this.type;
+    }
+
+    /**
+     * Method init.
+     * 
+     * @return the initialized Hashtable for the member table
+     */
+    private static java.util.Hashtable init(
+    ) {
+        java.util.Hashtable members = new java.util.Hashtable();
+        members.put("read-only", READ_ONLY);
+        members.put("shared", SHARED);
+        members.put("exclusive", EXCLUSIVE);
+        members.put("db-locked", DB_LOCKED);
+        return members;
+    }
+
+    /**
+     * Method readResolve. will be called during deserialization to
+     * replace the deserialized object with the correct constant
+     * instance.
+     * 
+     * @return this deserialized object
+     */
+    private java.lang.Object readResolve(
+    ) {
+        return valueOf(this.stringValue);
+    }
+
+    /**
+     * Method toString.Returns the String representation of this
+     * TableAccessModeType
+     * 
+     * @return the String representation of this TableAccessModeType
+     */
+    public java.lang.String toString(
+    ) {
+        return this.stringValue;
+    }
+
+    /**
+     * Method valueOf.Returns a new TableAccessModeType based on
+     * the given String value.
+     * 
+     * @param string
+     * @return the TableAccessModeType value of parameter 'string'
+     */
+    public static org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType valueOf(
+            final java.lang.String string) {
+        java.lang.Object obj = null;
+        if (string != null) {
+            obj = _memberTable.get(string);
+        }
+        if (obj == null) {
+            String err = "" + string + " is not a valid TableAccessModeType";
+            throw new IllegalArgumentException(err);
+        }
+        return (TableAccessModeType) obj;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/types/descriptors/TableAccessModeTypeDescriptor.java
@@ -0,0 +1,155 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType;
+
+/**
+ * Class TableAccessModeTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class TableAccessModeTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public TableAccessModeTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "TableAccessModeType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/descriptors/ManyToManyDescriptor.java
@@ -0,0 +1,200 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.ManyToMany;
+
+/**
+ * Class ManyToManyDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ManyToManyDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ManyToManyDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "many-to-many";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ManyToMany target = (ManyToMany) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ManyToMany target = (ManyToMany) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.ManyToMany.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/descriptors/ReadonlyDirtyTypeDescriptor.java
@@ -0,0 +1,246 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType;
+
+/**
+ * Class ReadonlyDirtyTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ReadonlyDirtyTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ReadonlyDirtyTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "readonlyDirtyType";
+        _elementDefinition = false;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _readOnly
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_readOnly", "read-only", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ReadonlyDirtyType target = (ReadonlyDirtyType) object;
+                if (!target.hasReadOnly()) { return null; }
+                return (target.getReadOnly() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ReadonlyDirtyType target = (ReadonlyDirtyType) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteReadOnly();
+                        return;
+                    }
+                    target.setReadOnly( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _readOnly
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _dirty
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_dirty", "dirty", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ReadonlyDirtyType target = (ReadonlyDirtyType) object;
+                if (!target.hasDirty()) { return null; }
+                return (target.getDirty() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ReadonlyDirtyType target = (ReadonlyDirtyType) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteDirty();
+                        return;
+                    }
+                    target.setDirty( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _dirty
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.ReadonlyDirtyType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/descriptors/TableDescriptor.java
@@ -0,0 +1,319 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.Table;
+
+/**
+ * Class TableDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class TableDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public TableDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "table";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Table target = (Table) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Table target = (Table) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _accessMode
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType.class, "_accessMode", "accessMode", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Table target = (Table) object;
+                return target.getAccessMode();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Table target = (Table) object;
+                    target.setAccessMode( (org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.xml.schema.annotations.jdo.types.TableAccessModeType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("TableAccessModeType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _accessMode
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _detachable
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_detachable", "detachable", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Table target = (Table) object;
+                if (!target.hasDetachable()) { return null; }
+                return (target.getDetachable() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Table target = (Table) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteDetachable();
+                        return;
+                    }
+                    target.setDetachable( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _detachable
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _primaryKey
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey.class, "_primaryKey", "primaryKey", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Table target = (Table) object;
+                return target.getPrimaryKey();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Table target = (Table) object;
+                    target.setPrimaryKey( (org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/binding/persistence");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _primaryKey
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.Table.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/descriptors/OneToOneDescriptor.java
@@ -0,0 +1,204 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.OneToOne;
+
+/**
+ * Class OneToOneDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class OneToOneDescriptor extends org.exolab.castor.xml.schema.annotations.jdo.descriptors.ReadonlyDirtyTypeDescriptor {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public OneToOneDescriptor() {
+        super();
+        setExtendsWithoutFlatten(new org.exolab.castor.xml.schema.annotations.jdo.descriptors.ReadonlyDirtyTypeDescriptor());
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "one-to-one";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                OneToOne target = (OneToOne) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    OneToOne target = (OneToOne) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        if (_identity == null) {
+            return super.getIdentity();
+        }
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.OneToOne.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/descriptors/OneToManyDescriptor.java
@@ -0,0 +1,204 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.OneToMany;
+
+/**
+ * Class OneToManyDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class OneToManyDescriptor extends org.exolab.castor.xml.schema.annotations.jdo.descriptors.ReadonlyDirtyTypeDescriptor {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public OneToManyDescriptor() {
+        super();
+        setExtendsWithoutFlatten(new org.exolab.castor.xml.schema.annotations.jdo.descriptors.ReadonlyDirtyTypeDescriptor());
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "one-to-many";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                OneToMany target = (OneToMany) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    OneToMany target = (OneToMany) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        if (_identity == null) {
+            return super.getIdentity();
+        }
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.OneToMany.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/descriptors/PrimaryKeyDescriptor.java
@@ -0,0 +1,159 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey;
+
+/**
+ * Class PrimaryKeyDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PrimaryKeyDescriptor extends org.exolab.castor.xml.schema.annotations.jdo.descriptors.PkTypeDescriptor {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PrimaryKeyDescriptor() {
+        super();
+        setExtendsWithoutFlatten(new org.exolab.castor.xml.schema.annotations.jdo.descriptors.PkTypeDescriptor());
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "primaryKey";
+        _elementDefinition = true;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        if (_identity == null) {
+            return super.getIdentity();
+        }
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.PrimaryKey.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/descriptors/ColumnDescriptor.java
@@ -0,0 +1,288 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.Column;
+
+/**
+ * Class ColumnDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ColumnDescriptor extends org.exolab.castor.xml.schema.annotations.jdo.descriptors.ReadonlyDirtyTypeDescriptor {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ColumnDescriptor() {
+        super();
+        setExtendsWithoutFlatten(new org.exolab.castor.xml.schema.annotations.jdo.descriptors.ReadonlyDirtyTypeDescriptor());
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "column";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Column target = (Column) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Column target = (Column) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _type
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_type", "type", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Column target = (Column) object;
+                return target.getType();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Column target = (Column) object;
+                    target.setType( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _type
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _acceptNull
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_acceptNull", "acceptNull", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Column target = (Column) object;
+                if (!target.hasAcceptNull()) { return null; }
+                return (target.getAcceptNull() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Column target = (Column) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteAcceptNull();
+                        return;
+                    }
+                    target.setAcceptNull( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _acceptNull
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        if (_identity == null) {
+            return super.getIdentity();
+        }
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.Column.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/schema/target/generated-sources/castor/org/exolab/castor/xml/schema/annotations/jdo/descriptors/PkTypeDescriptor.java
@@ -0,0 +1,216 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.xml.schema.annotations.jdo.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.xml.schema.annotations.jdo.PkType;
+
+/**
+ * Class PkTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PkTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PkTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/binding/persistence";
+        _xmlName = "pkType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _keyList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_keyList", "key", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                PkType target = (PkType) object;
+                return target.getKey();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    PkType target = (PkType) object;
+                    target.addKey( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    PkType target = (PkType) object;
+                    target.removeAllKey();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/binding/persistence");
+        desc.setRequired(true);
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _keyList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.xml.schema.annotations.jdo.PkType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
