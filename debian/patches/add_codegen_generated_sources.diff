Description: add autogenerated sources to codegen module
 These classes were generated with castor-maven-plugin.
 The reason why they are not generated at build time is because
 castor-maven-plugin is not available in Debian since it depends on this
 package. When castor gets accepted in the archive, castor-maven-plugin will be
 packaged and when it gets accepted in the archive, this package will re rebuilt
 with that plugin and this patch will be removed.
Author: Miguel Landaeta <miguel@miguel.cc>
Forwarded: not-needed
Last-Update: 2010-06-27

--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/Binding.java
@@ -0,0 +1,1714 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * The root element that contains the different binding elements.
+ *  The binding file is written from a schema point of view and
+ * follows the
+ *  structure of an XML Schema.
+ *  The root element can also be used to configure the default
+ * binding type. 
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class Binding implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _defaultBindingType.
+     */
+    private org.exolab.castor.builder.binding.xml.types.BindingType _defaultBindingType = org.exolab.castor.builder.binding.xml.types.BindingType.valueOf("element");
+
+    /**
+     * Field _includeList.
+     */
+    private java.util.List _includeList;
+
+    /**
+     * Field _packageList.
+     */
+    private java.util.List _packageList;
+
+    /**
+     * Field _namingXML.
+     */
+    private org.exolab.castor.builder.binding.xml.NamingXMLType _namingXML;
+
+    /**
+     * Field _automaticNaming.
+     */
+    private org.exolab.castor.builder.binding.xml.AutomaticNamingType _automaticNaming;
+
+    /**
+     * Field _componentBindingList.
+     */
+    private java.util.List _componentBindingList;
+
+    /**
+     * Field _elementBindingList.
+     */
+    private java.util.List _elementBindingList;
+
+    /**
+     * Field _attributeBindingList.
+     */
+    private java.util.List _attributeBindingList;
+
+    /**
+     * Field _complexTypeBindingList.
+     */
+    private java.util.List _complexTypeBindingList;
+
+    /**
+     * Field _groupBindingList.
+     */
+    private java.util.List _groupBindingList;
+
+    /**
+     * Field _enumBindingList.
+     */
+    private java.util.List _enumBindingList;
+
+    /**
+     * Field _simpleTypeBindingList.
+     */
+    private java.util.List _simpleTypeBindingList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Binding() {
+        super();
+        setDefaultBindingType(org.exolab.castor.builder.binding.xml.types.BindingType.valueOf("element"));
+        this._includeList = new java.util.ArrayList();
+        this._packageList = new java.util.ArrayList();
+        this._componentBindingList = new java.util.ArrayList();
+        this._elementBindingList = new java.util.ArrayList();
+        this._attributeBindingList = new java.util.ArrayList();
+        this._complexTypeBindingList = new java.util.ArrayList();
+        this._groupBindingList = new java.util.ArrayList();
+        this._enumBindingList = new java.util.ArrayList();
+        this._simpleTypeBindingList = new java.util.ArrayList();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vAttributeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addAttributeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vAttributeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._attributeBindingList.add(vAttributeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vAttributeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addAttributeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vAttributeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._attributeBindingList.add(index, vAttributeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vComplexTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addComplexTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComplexTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._complexTypeBindingList.add(vComplexTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vComplexTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addComplexTypeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComplexTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._complexTypeBindingList.add(index, vComplexTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vComponentBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addComponentBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComponentBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._componentBindingList.add(vComponentBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vComponentBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addComponentBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComponentBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._componentBindingList.add(index, vComponentBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vElementBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addElementBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vElementBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._elementBindingList.add(vElementBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vElementBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addElementBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vElementBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._elementBindingList.add(index, vElementBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vEnumBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addEnumBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vEnumBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._enumBindingList.add(vEnumBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vEnumBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addEnumBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vEnumBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._enumBindingList.add(index, vEnumBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vGroupBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addGroupBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vGroupBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._groupBindingList.add(vGroupBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vGroupBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addGroupBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vGroupBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._groupBindingList.add(index, vGroupBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vInclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addInclude(
+            final org.exolab.castor.builder.binding.xml.IncludeType vInclude)
+    throws java.lang.IndexOutOfBoundsException {
+        this._includeList.add(vInclude);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vInclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addInclude(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.IncludeType vInclude)
+    throws java.lang.IndexOutOfBoundsException {
+        this._includeList.add(index, vInclude);
+    }
+
+    /**
+     * 
+     * 
+     * @param vPackage
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addPackage(
+            final org.exolab.castor.builder.binding.xml.PackageType vPackage)
+    throws java.lang.IndexOutOfBoundsException {
+        this._packageList.add(vPackage);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vPackage
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addPackage(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.PackageType vPackage)
+    throws java.lang.IndexOutOfBoundsException {
+        this._packageList.add(index, vPackage);
+    }
+
+    /**
+     * 
+     * 
+     * @param vSimpleTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addSimpleTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vSimpleTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._simpleTypeBindingList.add(vSimpleTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vSimpleTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addSimpleTypeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vSimpleTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._simpleTypeBindingList.add(index, vSimpleTypeBinding);
+    }
+
+    /**
+     * Method enumerateAttributeBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateAttributeBinding(
+    ) {
+        return java.util.Collections.enumeration(this._attributeBindingList);
+    }
+
+    /**
+     * Method enumerateComplexTypeBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateComplexTypeBinding(
+    ) {
+        return java.util.Collections.enumeration(this._complexTypeBindingList);
+    }
+
+    /**
+     * Method enumerateComponentBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateComponentBinding(
+    ) {
+        return java.util.Collections.enumeration(this._componentBindingList);
+    }
+
+    /**
+     * Method enumerateElementBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateElementBinding(
+    ) {
+        return java.util.Collections.enumeration(this._elementBindingList);
+    }
+
+    /**
+     * Method enumerateEnumBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateEnumBinding(
+    ) {
+        return java.util.Collections.enumeration(this._enumBindingList);
+    }
+
+    /**
+     * Method enumerateGroupBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateGroupBinding(
+    ) {
+        return java.util.Collections.enumeration(this._groupBindingList);
+    }
+
+    /**
+     * Method enumerateInclude.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateInclude(
+    ) {
+        return java.util.Collections.enumeration(this._includeList);
+    }
+
+    /**
+     * Method enumeratePackage.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumeratePackage(
+    ) {
+        return java.util.Collections.enumeration(this._packageList);
+    }
+
+    /**
+     * Method enumerateSimpleTypeBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateSimpleTypeBinding(
+    ) {
+        return java.util.Collections.enumeration(this._simpleTypeBindingList);
+    }
+
+    /**
+     * Method getAttributeBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getAttributeBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._attributeBindingList.size()) {
+            throw new IndexOutOfBoundsException("getAttributeBinding: Index value '" + index + "' not in range [0.." + (this._attributeBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _attributeBindingList.get(index);
+    }
+
+    /**
+     * Method getAttributeBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getAttributeBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._attributeBindingList.toArray(array);
+    }
+
+    /**
+     * Method getAttributeBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getAttributeBindingCount(
+    ) {
+        return this._attributeBindingList.size();
+    }
+
+    /**
+     * Returns the value of field 'automaticNaming'.
+     * 
+     * @return the value of field 'AutomaticNaming'.
+     */
+    public org.exolab.castor.builder.binding.xml.AutomaticNamingType getAutomaticNaming(
+    ) {
+        return this._automaticNaming;
+    }
+
+    /**
+     * Method getComplexTypeBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getComplexTypeBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._complexTypeBindingList.size()) {
+            throw new IndexOutOfBoundsException("getComplexTypeBinding: Index value '" + index + "' not in range [0.." + (this._complexTypeBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _complexTypeBindingList.get(index);
+    }
+
+    /**
+     * Method getComplexTypeBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getComplexTypeBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._complexTypeBindingList.toArray(array);
+    }
+
+    /**
+     * Method getComplexTypeBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getComplexTypeBindingCount(
+    ) {
+        return this._complexTypeBindingList.size();
+    }
+
+    /**
+     * Method getComponentBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getComponentBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._componentBindingList.size()) {
+            throw new IndexOutOfBoundsException("getComponentBinding: Index value '" + index + "' not in range [0.." + (this._componentBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _componentBindingList.get(index);
+    }
+
+    /**
+     * Method getComponentBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getComponentBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._componentBindingList.toArray(array);
+    }
+
+    /**
+     * Method getComponentBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getComponentBindingCount(
+    ) {
+        return this._componentBindingList.size();
+    }
+
+    /**
+     * Returns the value of field 'defaultBindingType'.
+     * 
+     * @return the value of field 'DefaultBindingType'.
+     */
+    public org.exolab.castor.builder.binding.xml.types.BindingType getDefaultBindingType(
+    ) {
+        return this._defaultBindingType;
+    }
+
+    /**
+     * Method getElementBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getElementBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._elementBindingList.size()) {
+            throw new IndexOutOfBoundsException("getElementBinding: Index value '" + index + "' not in range [0.." + (this._elementBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _elementBindingList.get(index);
+    }
+
+    /**
+     * Method getElementBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getElementBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._elementBindingList.toArray(array);
+    }
+
+    /**
+     * Method getElementBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getElementBindingCount(
+    ) {
+        return this._elementBindingList.size();
+    }
+
+    /**
+     * Method getEnumBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getEnumBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._enumBindingList.size()) {
+            throw new IndexOutOfBoundsException("getEnumBinding: Index value '" + index + "' not in range [0.." + (this._enumBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _enumBindingList.get(index);
+    }
+
+    /**
+     * Method getEnumBinding.Returns the contents of the collection
+     * in an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getEnumBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._enumBindingList.toArray(array);
+    }
+
+    /**
+     * Method getEnumBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getEnumBindingCount(
+    ) {
+        return this._enumBindingList.size();
+    }
+
+    /**
+     * Method getGroupBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getGroupBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._groupBindingList.size()) {
+            throw new IndexOutOfBoundsException("getGroupBinding: Index value '" + index + "' not in range [0.." + (this._groupBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _groupBindingList.get(index);
+    }
+
+    /**
+     * Method getGroupBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getGroupBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._groupBindingList.toArray(array);
+    }
+
+    /**
+     * Method getGroupBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getGroupBindingCount(
+    ) {
+        return this._groupBindingList.size();
+    }
+
+    /**
+     * Method getInclude.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.IncludeType at the
+     * given index
+     */
+    public org.exolab.castor.builder.binding.xml.IncludeType getInclude(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._includeList.size()) {
+            throw new IndexOutOfBoundsException("getInclude: Index value '" + index + "' not in range [0.." + (this._includeList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.IncludeType) _includeList.get(index);
+    }
+
+    /**
+     * Method getInclude.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.IncludeType[] getInclude(
+    ) {
+        org.exolab.castor.builder.binding.xml.IncludeType[] array = new org.exolab.castor.builder.binding.xml.IncludeType[0];
+        return (org.exolab.castor.builder.binding.xml.IncludeType[]) this._includeList.toArray(array);
+    }
+
+    /**
+     * Method getIncludeCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getIncludeCount(
+    ) {
+        return this._includeList.size();
+    }
+
+    /**
+     * Returns the value of field 'namingXML'.
+     * 
+     * @return the value of field 'NamingXML'.
+     */
+    public org.exolab.castor.builder.binding.xml.NamingXMLType getNamingXML(
+    ) {
+        return this._namingXML;
+    }
+
+    /**
+     * Method getPackage.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.PackageType at the
+     * given index
+     */
+    public org.exolab.castor.builder.binding.xml.PackageType getPackage(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._packageList.size()) {
+            throw new IndexOutOfBoundsException("getPackage: Index value '" + index + "' not in range [0.." + (this._packageList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.PackageType) _packageList.get(index);
+    }
+
+    /**
+     * Method getPackage.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.PackageType[] getPackage(
+    ) {
+        org.exolab.castor.builder.binding.xml.PackageType[] array = new org.exolab.castor.builder.binding.xml.PackageType[0];
+        return (org.exolab.castor.builder.binding.xml.PackageType[]) this._packageList.toArray(array);
+    }
+
+    /**
+     * Method getPackageCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getPackageCount(
+    ) {
+        return this._packageList.size();
+    }
+
+    /**
+     * Method getSimpleTypeBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getSimpleTypeBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._simpleTypeBindingList.size()) {
+            throw new IndexOutOfBoundsException("getSimpleTypeBinding: Index value '" + index + "' not in range [0.." + (this._simpleTypeBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _simpleTypeBindingList.get(index);
+    }
+
+    /**
+     * Method getSimpleTypeBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getSimpleTypeBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._simpleTypeBindingList.toArray(array);
+    }
+
+    /**
+     * Method getSimpleTypeBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getSimpleTypeBindingCount(
+    ) {
+        return this._simpleTypeBindingList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateAttributeBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateAttributeBinding(
+    ) {
+        return this._attributeBindingList.iterator();
+    }
+
+    /**
+     * Method iterateComplexTypeBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateComplexTypeBinding(
+    ) {
+        return this._complexTypeBindingList.iterator();
+    }
+
+    /**
+     * Method iterateComponentBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateComponentBinding(
+    ) {
+        return this._componentBindingList.iterator();
+    }
+
+    /**
+     * Method iterateElementBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateElementBinding(
+    ) {
+        return this._elementBindingList.iterator();
+    }
+
+    /**
+     * Method iterateEnumBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateEnumBinding(
+    ) {
+        return this._enumBindingList.iterator();
+    }
+
+    /**
+     * Method iterateGroupBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateGroupBinding(
+    ) {
+        return this._groupBindingList.iterator();
+    }
+
+    /**
+     * Method iterateInclude.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateInclude(
+    ) {
+        return this._includeList.iterator();
+    }
+
+    /**
+     * Method iteratePackage.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iteratePackage(
+    ) {
+        return this._packageList.iterator();
+    }
+
+    /**
+     * Method iterateSimpleTypeBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateSimpleTypeBinding(
+    ) {
+        return this._simpleTypeBindingList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllAttributeBinding(
+    ) {
+        this._attributeBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllComplexTypeBinding(
+    ) {
+        this._complexTypeBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllComponentBinding(
+    ) {
+        this._componentBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllElementBinding(
+    ) {
+        this._elementBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllEnumBinding(
+    ) {
+        this._enumBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllGroupBinding(
+    ) {
+        this._groupBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllInclude(
+    ) {
+        this._includeList.clear();
+    }
+
+    /**
+     */
+    public void removeAllPackage(
+    ) {
+        this._packageList.clear();
+    }
+
+    /**
+     */
+    public void removeAllSimpleTypeBinding(
+    ) {
+        this._simpleTypeBindingList.clear();
+    }
+
+    /**
+     * Method removeAttributeBinding.
+     * 
+     * @param vAttributeBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeAttributeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vAttributeBinding) {
+        boolean removed = _attributeBindingList.remove(vAttributeBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeAttributeBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeAttributeBindingAt(
+            final int index) {
+        java.lang.Object obj = this._attributeBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeComplexTypeBinding.
+     * 
+     * @param vComplexTypeBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeComplexTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComplexTypeBinding) {
+        boolean removed = _complexTypeBindingList.remove(vComplexTypeBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeComplexTypeBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeComplexTypeBindingAt(
+            final int index) {
+        java.lang.Object obj = this._complexTypeBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeComponentBinding.
+     * 
+     * @param vComponentBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeComponentBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComponentBinding) {
+        boolean removed = _componentBindingList.remove(vComponentBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeComponentBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeComponentBindingAt(
+            final int index) {
+        java.lang.Object obj = this._componentBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeElementBinding.
+     * 
+     * @param vElementBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeElementBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vElementBinding) {
+        boolean removed = _elementBindingList.remove(vElementBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeElementBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeElementBindingAt(
+            final int index) {
+        java.lang.Object obj = this._elementBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeEnumBinding.
+     * 
+     * @param vEnumBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeEnumBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vEnumBinding) {
+        boolean removed = _enumBindingList.remove(vEnumBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeEnumBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeEnumBindingAt(
+            final int index) {
+        java.lang.Object obj = this._enumBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeGroupBinding.
+     * 
+     * @param vGroupBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeGroupBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vGroupBinding) {
+        boolean removed = _groupBindingList.remove(vGroupBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeGroupBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeGroupBindingAt(
+            final int index) {
+        java.lang.Object obj = this._groupBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeInclude.
+     * 
+     * @param vInclude
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeInclude(
+            final org.exolab.castor.builder.binding.xml.IncludeType vInclude) {
+        boolean removed = _includeList.remove(vInclude);
+        return removed;
+    }
+
+    /**
+     * Method removeIncludeAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.IncludeType removeIncludeAt(
+            final int index) {
+        java.lang.Object obj = this._includeList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.IncludeType) obj;
+    }
+
+    /**
+     * Method removePackage.
+     * 
+     * @param vPackage
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removePackage(
+            final org.exolab.castor.builder.binding.xml.PackageType vPackage) {
+        boolean removed = _packageList.remove(vPackage);
+        return removed;
+    }
+
+    /**
+     * Method removePackageAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.PackageType removePackageAt(
+            final int index) {
+        java.lang.Object obj = this._packageList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.PackageType) obj;
+    }
+
+    /**
+     * Method removeSimpleTypeBinding.
+     * 
+     * @param vSimpleTypeBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeSimpleTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vSimpleTypeBinding) {
+        boolean removed = _simpleTypeBindingList.remove(vSimpleTypeBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeSimpleTypeBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeSimpleTypeBindingAt(
+            final int index) {
+        java.lang.Object obj = this._simpleTypeBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vAttributeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setAttributeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vAttributeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._attributeBindingList.size()) {
+            throw new IndexOutOfBoundsException("setAttributeBinding: Index value '" + index + "' not in range [0.." + (this._attributeBindingList.size() - 1) + "]");
+        }
+
+        this._attributeBindingList.set(index, vAttributeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vAttributeBindingArray
+     */
+    public void setAttributeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vAttributeBindingArray) {
+        //-- copy array
+        _attributeBindingList.clear();
+
+        for (int i = 0; i < vAttributeBindingArray.length; i++) {
+                this._attributeBindingList.add(vAttributeBindingArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'automaticNaming'.
+     * 
+     * @param automaticNaming the value of field 'automaticNaming'.
+     */
+    public void setAutomaticNaming(
+            final org.exolab.castor.builder.binding.xml.AutomaticNamingType automaticNaming) {
+        this._automaticNaming = automaticNaming;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vComplexTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setComplexTypeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComplexTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._complexTypeBindingList.size()) {
+            throw new IndexOutOfBoundsException("setComplexTypeBinding: Index value '" + index + "' not in range [0.." + (this._complexTypeBindingList.size() - 1) + "]");
+        }
+
+        this._complexTypeBindingList.set(index, vComplexTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vComplexTypeBindingArray
+     */
+    public void setComplexTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vComplexTypeBindingArray) {
+        //-- copy array
+        _complexTypeBindingList.clear();
+
+        for (int i = 0; i < vComplexTypeBindingArray.length; i++) {
+                this._complexTypeBindingList.add(vComplexTypeBindingArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vComponentBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setComponentBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComponentBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._componentBindingList.size()) {
+            throw new IndexOutOfBoundsException("setComponentBinding: Index value '" + index + "' not in range [0.." + (this._componentBindingList.size() - 1) + "]");
+        }
+
+        this._componentBindingList.set(index, vComponentBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vComponentBindingArray
+     */
+    public void setComponentBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vComponentBindingArray) {
+        //-- copy array
+        _componentBindingList.clear();
+
+        for (int i = 0; i < vComponentBindingArray.length; i++) {
+                this._componentBindingList.add(vComponentBindingArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'defaultBindingType'.
+     * 
+     * @param defaultBindingType the value of field
+     * 'defaultBindingType'.
+     */
+    public void setDefaultBindingType(
+            final org.exolab.castor.builder.binding.xml.types.BindingType defaultBindingType) {
+        this._defaultBindingType = defaultBindingType;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vElementBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setElementBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vElementBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._elementBindingList.size()) {
+            throw new IndexOutOfBoundsException("setElementBinding: Index value '" + index + "' not in range [0.." + (this._elementBindingList.size() - 1) + "]");
+        }
+
+        this._elementBindingList.set(index, vElementBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vElementBindingArray
+     */
+    public void setElementBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vElementBindingArray) {
+        //-- copy array
+        _elementBindingList.clear();
+
+        for (int i = 0; i < vElementBindingArray.length; i++) {
+                this._elementBindingList.add(vElementBindingArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vEnumBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setEnumBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vEnumBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._enumBindingList.size()) {
+            throw new IndexOutOfBoundsException("setEnumBinding: Index value '" + index + "' not in range [0.." + (this._enumBindingList.size() - 1) + "]");
+        }
+
+        this._enumBindingList.set(index, vEnumBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vEnumBindingArray
+     */
+    public void setEnumBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vEnumBindingArray) {
+        //-- copy array
+        _enumBindingList.clear();
+
+        for (int i = 0; i < vEnumBindingArray.length; i++) {
+                this._enumBindingList.add(vEnumBindingArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vGroupBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setGroupBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vGroupBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._groupBindingList.size()) {
+            throw new IndexOutOfBoundsException("setGroupBinding: Index value '" + index + "' not in range [0.." + (this._groupBindingList.size() - 1) + "]");
+        }
+
+        this._groupBindingList.set(index, vGroupBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vGroupBindingArray
+     */
+    public void setGroupBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vGroupBindingArray) {
+        //-- copy array
+        _groupBindingList.clear();
+
+        for (int i = 0; i < vGroupBindingArray.length; i++) {
+                this._groupBindingList.add(vGroupBindingArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vInclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setInclude(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.IncludeType vInclude)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._includeList.size()) {
+            throw new IndexOutOfBoundsException("setInclude: Index value '" + index + "' not in range [0.." + (this._includeList.size() - 1) + "]");
+        }
+
+        this._includeList.set(index, vInclude);
+    }
+
+    /**
+     * 
+     * 
+     * @param vIncludeArray
+     */
+    public void setInclude(
+            final org.exolab.castor.builder.binding.xml.IncludeType[] vIncludeArray) {
+        //-- copy array
+        _includeList.clear();
+
+        for (int i = 0; i < vIncludeArray.length; i++) {
+                this._includeList.add(vIncludeArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'namingXML'.
+     * 
+     * @param namingXML the value of field 'namingXML'.
+     */
+    public void setNamingXML(
+            final org.exolab.castor.builder.binding.xml.NamingXMLType namingXML) {
+        this._namingXML = namingXML;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vPackage
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setPackage(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.PackageType vPackage)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._packageList.size()) {
+            throw new IndexOutOfBoundsException("setPackage: Index value '" + index + "' not in range [0.." + (this._packageList.size() - 1) + "]");
+        }
+
+        this._packageList.set(index, vPackage);
+    }
+
+    /**
+     * 
+     * 
+     * @param vPackageArray
+     */
+    public void setPackage(
+            final org.exolab.castor.builder.binding.xml.PackageType[] vPackageArray) {
+        //-- copy array
+        _packageList.clear();
+
+        for (int i = 0; i < vPackageArray.length; i++) {
+                this._packageList.add(vPackageArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vSimpleTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setSimpleTypeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vSimpleTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._simpleTypeBindingList.size()) {
+            throw new IndexOutOfBoundsException("setSimpleTypeBinding: Index value '" + index + "' not in range [0.." + (this._simpleTypeBindingList.size() - 1) + "]");
+        }
+
+        this._simpleTypeBindingList.set(index, vSimpleTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vSimpleTypeBindingArray
+     */
+    public void setSimpleTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vSimpleTypeBindingArray) {
+        //-- copy array
+        _simpleTypeBindingList.clear();
+
+        for (int i = 0; i < vSimpleTypeBindingArray.length; i++) {
+                this._simpleTypeBindingList.add(vSimpleTypeBindingArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshalBinding.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.Binding
+     */
+    public static org.exolab.castor.builder.binding.xml.Binding unmarshalBinding(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.Binding) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.Binding.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/Excludes.java
@@ -0,0 +1,281 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class Excludes.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class Excludes implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _excludeList.
+     */
+    private java.util.List _excludeList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Excludes() {
+        super();
+        this._excludeList = new java.util.ArrayList();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vExclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addExclude(
+            final org.exolab.castor.builder.binding.xml.Exclude vExclude)
+    throws java.lang.IndexOutOfBoundsException {
+        this._excludeList.add(vExclude);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vExclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addExclude(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.Exclude vExclude)
+    throws java.lang.IndexOutOfBoundsException {
+        this._excludeList.add(index, vExclude);
+    }
+
+    /**
+     * Method enumerateExclude.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateExclude(
+    ) {
+        return java.util.Collections.enumeration(this._excludeList);
+    }
+
+    /**
+     * Method getExclude.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.Exclude at the given
+     * index
+     */
+    public org.exolab.castor.builder.binding.xml.Exclude getExclude(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._excludeList.size()) {
+            throw new IndexOutOfBoundsException("getExclude: Index value '" + index + "' not in range [0.." + (this._excludeList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.Exclude) _excludeList.get(index);
+    }
+
+    /**
+     * Method getExclude.Returns the contents of the collection in
+     * an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.Exclude[] getExclude(
+    ) {
+        org.exolab.castor.builder.binding.xml.Exclude[] array = new org.exolab.castor.builder.binding.xml.Exclude[0];
+        return (org.exolab.castor.builder.binding.xml.Exclude[]) this._excludeList.toArray(array);
+    }
+
+    /**
+     * Method getExcludeCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getExcludeCount(
+    ) {
+        return this._excludeList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateExclude.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateExclude(
+    ) {
+        return this._excludeList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllExclude(
+    ) {
+        this._excludeList.clear();
+    }
+
+    /**
+     * Method removeExclude.
+     * 
+     * @param vExclude
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeExclude(
+            final org.exolab.castor.builder.binding.xml.Exclude vExclude) {
+        boolean removed = _excludeList.remove(vExclude);
+        return removed;
+    }
+
+    /**
+     * Method removeExcludeAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.Exclude removeExcludeAt(
+            final int index) {
+        java.lang.Object obj = this._excludeList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.Exclude) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vExclude
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setExclude(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.Exclude vExclude)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._excludeList.size()) {
+            throw new IndexOutOfBoundsException("setExclude: Index value '" + index + "' not in range [0.." + (this._excludeList.size() - 1) + "]");
+        }
+
+        this._excludeList.set(index, vExclude);
+    }
+
+    /**
+     * 
+     * 
+     * @param vExcludeArray
+     */
+    public void setExclude(
+            final org.exolab.castor.builder.binding.xml.Exclude[] vExcludeArray) {
+        //-- copy array
+        _excludeList.clear();
+
+        for (int i = 0; i < vExcludeArray.length; i++) {
+                this._excludeList.add(vExcludeArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshalExcludes.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.Excludes
+     */
+    public static org.exolab.castor.builder.binding.xml.Excludes unmarshalExcludes(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.Excludes) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.Excludes.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/EnumClassName.java
@@ -0,0 +1,175 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class EnumClassName.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class EnumClassName implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * internal content storage
+     */
+    private java.lang.String _content = "";
+
+    /**
+     * Field _package.
+     */
+    private java.lang.String _package;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public EnumClassName() {
+        super();
+        setContent("");
+    }
+
+    public EnumClassName(final java.lang.String defaultValue) {
+        try {
+            setContent( new java.lang.String(defaultValue));
+         } catch(Exception e) {
+            throw new RuntimeException("Unable to cast default value for simple content!");
+         } 
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'content'. The field 'content'
+     * has the following description: internal content storage
+     * 
+     * @return the value of field 'Content'.
+     */
+    public java.lang.String getContent(
+    ) {
+        return this._content;
+    }
+
+    /**
+     * Returns the value of field 'package'.
+     * 
+     * @return the value of field 'Package'.
+     */
+    public java.lang.String getPackage(
+    ) {
+        return this._package;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'content'. The field 'content' has
+     * the following description: internal content storage
+     * 
+     * @param content the value of field 'content'.
+     */
+    public void setContent(
+            final java.lang.String content) {
+        this._content = content;
+    }
+
+    /**
+     * Sets the value of field 'package'.
+     * 
+     * @param _package
+     * @param package the value of field 'package'.
+     */
+    public void setPackage(
+            final java.lang.String _package) {
+        this._package = _package;
+    }
+
+    /**
+     * Method unmarshalEnumClassName.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.EnumClassName
+     */
+    public static org.exolab.castor.builder.binding.xml.EnumClassName unmarshalEnumClassName(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.EnumClassName) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.EnumClassName.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/AutomaticNamingType.java
@@ -0,0 +1,163 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class AutomaticNamingType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class AutomaticNamingType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _forces.
+     */
+    private org.exolab.castor.builder.binding.xml.Forces _forces;
+
+    /**
+     * Field _excludes.
+     */
+    private org.exolab.castor.builder.binding.xml.Excludes _excludes;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public AutomaticNamingType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'excludes'.
+     * 
+     * @return the value of field 'Excludes'.
+     */
+    public org.exolab.castor.builder.binding.xml.Excludes getExcludes(
+    ) {
+        return this._excludes;
+    }
+
+    /**
+     * Returns the value of field 'forces'.
+     * 
+     * @return the value of field 'Forces'.
+     */
+    public org.exolab.castor.builder.binding.xml.Forces getForces(
+    ) {
+        return this._forces;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'excludes'.
+     * 
+     * @param excludes the value of field 'excludes'.
+     */
+    public void setExcludes(
+            final org.exolab.castor.builder.binding.xml.Excludes excludes) {
+        this._excludes = excludes;
+    }
+
+    /**
+     * Sets the value of field 'forces'.
+     * 
+     * @param forces the value of field 'forces'.
+     */
+    public void setForces(
+            final org.exolab.castor.builder.binding.xml.Forces forces) {
+        this._forces = forces;
+    }
+
+    /**
+     * Method unmarshalAutomaticNamingType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.AutomaticNamingType
+     */
+    public static org.exolab.castor.builder.binding.xml.AutomaticNamingType unmarshalAutomaticNamingType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.AutomaticNamingType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.AutomaticNamingType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/.castor.cdr
@@ -0,0 +1,20 @@
+#Sat Jun 12 20:25:04 VET 2010
+org.exolab.castor.builder.binding.xml.Excludes=org.exolab.castor.builder.binding.xml.descriptors.ExcludesDescriptor
+org.exolab.castor.builder.binding.xml.NamingType=org.exolab.castor.builder.binding.xml.descriptors.NamingTypeDescriptor
+org.exolab.castor.builder.binding.xml.FieldType=org.exolab.castor.builder.binding.xml.descriptors.FieldTypeDescriptor
+org.exolab.castor.builder.binding.xml.EnumClassName=org.exolab.castor.builder.binding.xml.descriptors.EnumClassNameDescriptor
+org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice=org.exolab.castor.builder.binding.xml.descriptors.ComponentBindingTypeChoiceDescriptor
+org.exolab.castor.builder.binding.xml.EnumBindingType=org.exolab.castor.builder.binding.xml.descriptors.EnumBindingTypeDescriptor
+org.exolab.castor.builder.binding.xml.ClassType=org.exolab.castor.builder.binding.xml.descriptors.ClassTypeDescriptor
+org.exolab.castor.builder.binding.xml.ComponentBindingType=org.exolab.castor.builder.binding.xml.descriptors.ComponentBindingTypeDescriptor
+org.exolab.castor.builder.binding.xml.Exclude=org.exolab.castor.builder.binding.xml.descriptors.ExcludeDescriptor
+org.exolab.castor.builder.binding.xml.NamingXMLType=org.exolab.castor.builder.binding.xml.descriptors.NamingXMLTypeDescriptor
+org.exolab.castor.builder.binding.xml.Binding=org.exolab.castor.builder.binding.xml.descriptors.BindingDescriptor
+org.exolab.castor.builder.binding.xml.ContentMemberType=org.exolab.castor.builder.binding.xml.descriptors.ContentMemberTypeDescriptor
+org.exolab.castor.builder.binding.xml.PackageTypeChoice=org.exolab.castor.builder.binding.xml.descriptors.PackageTypeChoiceDescriptor
+org.exolab.castor.builder.binding.xml.Interface=org.exolab.castor.builder.binding.xml.descriptors.InterfaceDescriptor
+org.exolab.castor.builder.binding.xml.IncludeType=org.exolab.castor.builder.binding.xml.descriptors.IncludeTypeDescriptor
+org.exolab.castor.builder.binding.xml.Forces=org.exolab.castor.builder.binding.xml.descriptors.ForcesDescriptor
+org.exolab.castor.builder.binding.xml.AutomaticNamingType=org.exolab.castor.builder.binding.xml.descriptors.AutomaticNamingTypeDescriptor
+org.exolab.castor.builder.binding.xml.PackageType=org.exolab.castor.builder.binding.xml.descriptors.PackageTypeDescriptor
+org.exolab.castor.builder.binding.xml.EnumMember=org.exolab.castor.builder.binding.xml.descriptors.EnumMemberDescriptor
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/EnumMember.java
@@ -0,0 +1,163 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class EnumMember.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class EnumMember implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _value.
+     */
+    private java.lang.String _value;
+
+    /**
+     * Field _javaName.
+     */
+    private java.lang.String _javaName;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public EnumMember() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'javaName'.
+     * 
+     * @return the value of field 'JavaName'.
+     */
+    public java.lang.String getJavaName(
+    ) {
+        return this._javaName;
+    }
+
+    /**
+     * Returns the value of field 'value'.
+     * 
+     * @return the value of field 'Value'.
+     */
+    public java.lang.String getValue(
+    ) {
+        return this._value;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'javaName'.
+     * 
+     * @param javaName the value of field 'javaName'.
+     */
+    public void setJavaName(
+            final java.lang.String javaName) {
+        this._javaName = javaName;
+    }
+
+    /**
+     * Sets the value of field 'value'.
+     * 
+     * @param value the value of field 'value'.
+     */
+    public void setValue(
+            final java.lang.String value) {
+        this._value = value;
+    }
+
+    /**
+     * Method unmarshalEnumMember.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.EnumMember
+     */
+    public static org.exolab.castor.builder.binding.xml.EnumMember unmarshalEnumMember(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.EnumMember) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.EnumMember.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/ComponentBindingTypeChoice.java
@@ -0,0 +1,239 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class ComponentBindingTypeChoice.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ComponentBindingTypeChoice implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _javaClass.
+     */
+    private org.exolab.castor.builder.binding.xml.ClassType _javaClass;
+
+    /**
+     * Field _interface.
+     */
+    private org.exolab.castor.builder.binding.xml.Interface _interface;
+
+    /**
+     * Field _member.
+     */
+    private org.exolab.castor.builder.binding.xml.FieldType _member;
+
+    /**
+     * Field _enumDef.
+     */
+    private org.exolab.castor.builder.binding.xml.EnumBindingType _enumDef;
+
+    /**
+     * Field _contentMember.
+     */
+    private org.exolab.castor.builder.binding.xml.ContentMemberType _contentMember;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ComponentBindingTypeChoice() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'contentMember'.
+     * 
+     * @return the value of field 'ContentMember'.
+     */
+    public org.exolab.castor.builder.binding.xml.ContentMemberType getContentMember(
+    ) {
+        return this._contentMember;
+    }
+
+    /**
+     * Returns the value of field 'enumDef'.
+     * 
+     * @return the value of field 'EnumDef'.
+     */
+    public org.exolab.castor.builder.binding.xml.EnumBindingType getEnumDef(
+    ) {
+        return this._enumDef;
+    }
+
+    /**
+     * Returns the value of field 'interface'.
+     * 
+     * @return the value of field 'Interface'.
+     */
+    public org.exolab.castor.builder.binding.xml.Interface getInterface(
+    ) {
+        return this._interface;
+    }
+
+    /**
+     * Returns the value of field 'javaClass'.
+     * 
+     * @return the value of field 'JavaClass'.
+     */
+    public org.exolab.castor.builder.binding.xml.ClassType getJavaClass(
+    ) {
+        return this._javaClass;
+    }
+
+    /**
+     * Returns the value of field 'member'.
+     * 
+     * @return the value of field 'Member'.
+     */
+    public org.exolab.castor.builder.binding.xml.FieldType getMember(
+    ) {
+        return this._member;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'contentMember'.
+     * 
+     * @param contentMember the value of field 'contentMember'.
+     */
+    public void setContentMember(
+            final org.exolab.castor.builder.binding.xml.ContentMemberType contentMember) {
+        this._contentMember = contentMember;
+    }
+
+    /**
+     * Sets the value of field 'enumDef'.
+     * 
+     * @param enumDef the value of field 'enumDef'.
+     */
+    public void setEnumDef(
+            final org.exolab.castor.builder.binding.xml.EnumBindingType enumDef) {
+        this._enumDef = enumDef;
+    }
+
+    /**
+     * Sets the value of field 'interface'.
+     * 
+     * @param _interface
+     * @param interface the value of field 'interface'.
+     */
+    public void setInterface(
+            final org.exolab.castor.builder.binding.xml.Interface _interface) {
+        this._interface = _interface;
+    }
+
+    /**
+     * Sets the value of field 'javaClass'.
+     * 
+     * @param javaClass the value of field 'javaClass'.
+     */
+    public void setJavaClass(
+            final org.exolab.castor.builder.binding.xml.ClassType javaClass) {
+        this._javaClass = javaClass;
+    }
+
+    /**
+     * Sets the value of field 'member'.
+     * 
+     * @param member the value of field 'member'.
+     */
+    public void setMember(
+            final org.exolab.castor.builder.binding.xml.FieldType member) {
+        this._member = member;
+    }
+
+    /**
+     * Method unmarshalComponentBindingTypeChoice.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice
+     */
+    public static org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice unmarshalComponentBindingTypeChoice(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/Exclude.java
@@ -0,0 +1,163 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class Exclude.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class Exclude implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _className.
+     */
+    private java.lang.String _className;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Exclude() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'className'.
+     * 
+     * @return the value of field 'ClassName'.
+     */
+    public java.lang.String getClassName(
+    ) {
+        return this._className;
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'className'.
+     * 
+     * @param className the value of field 'className'.
+     */
+    public void setClassName(
+            final java.lang.String className) {
+        this._className = className;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshalExclude.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.Exclude
+     */
+    public static org.exolab.castor.builder.binding.xml.Exclude unmarshalExclude(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.Exclude) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.Exclude.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/Interface.java
@@ -0,0 +1,138 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class Interface.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class Interface implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Interface() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Method unmarshalInterface.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.Interface
+     */
+    public static org.exolab.castor.builder.binding.xml.Interface unmarshalInterface(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.Interface) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.Interface.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/ContentMemberType.java
@@ -0,0 +1,168 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * This type represents the binding for the 'content' member
+ * generated
+ *  as part of a 'mixed' complex type definition. It allows the
+ * definition
+ *  of its name.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ContentMemberType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _visibility.
+     */
+    private org.exolab.castor.builder.binding.xml.types.VisibilityType _visibility;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ContentMemberType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'visibility'.
+     * 
+     * @return the value of field 'Visibility'.
+     */
+    public org.exolab.castor.builder.binding.xml.types.VisibilityType getVisibility(
+    ) {
+        return this._visibility;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'visibility'.
+     * 
+     * @param visibility the value of field 'visibility'.
+     */
+    public void setVisibility(
+            final org.exolab.castor.builder.binding.xml.types.VisibilityType visibility) {
+        this._visibility = visibility;
+    }
+
+    /**
+     * Method unmarshalContentMemberType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.ContentMemberType
+     */
+    public static org.exolab.castor.builder.binding.xml.ContentMemberType unmarshalContentMemberType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.ContentMemberType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.ContentMemberType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/NamingXMLType.java
@@ -0,0 +1,195 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * This element allows to define naming convention when naming a
+ * complexType, element or
+ *  modelGroup. Indeed the user can decide of a prefix to add to
+ * each class name as well
+ *  as a suffix. This naming style won't affect the names entered
+ * in the binding file but only 
+ *  the XML Names.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class NamingXMLType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementName.
+     */
+    private org.exolab.castor.builder.binding.xml.NamingType _elementName;
+
+    /**
+     * Field _complexTypeName.
+     */
+    private org.exolab.castor.builder.binding.xml.NamingType _complexTypeName;
+
+    /**
+     * Field _modelGroupName.
+     */
+    private org.exolab.castor.builder.binding.xml.NamingType _modelGroupName;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public NamingXMLType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'complexTypeName'.
+     * 
+     * @return the value of field 'ComplexTypeName'.
+     */
+    public org.exolab.castor.builder.binding.xml.NamingType getComplexTypeName(
+    ) {
+        return this._complexTypeName;
+    }
+
+    /**
+     * Returns the value of field 'elementName'.
+     * 
+     * @return the value of field 'ElementName'.
+     */
+    public org.exolab.castor.builder.binding.xml.NamingType getElementName(
+    ) {
+        return this._elementName;
+    }
+
+    /**
+     * Returns the value of field 'modelGroupName'.
+     * 
+     * @return the value of field 'ModelGroupName'.
+     */
+    public org.exolab.castor.builder.binding.xml.NamingType getModelGroupName(
+    ) {
+        return this._modelGroupName;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'complexTypeName'.
+     * 
+     * @param complexTypeName the value of field 'complexTypeName'.
+     */
+    public void setComplexTypeName(
+            final org.exolab.castor.builder.binding.xml.NamingType complexTypeName) {
+        this._complexTypeName = complexTypeName;
+    }
+
+    /**
+     * Sets the value of field 'elementName'.
+     * 
+     * @param elementName the value of field 'elementName'.
+     */
+    public void setElementName(
+            final org.exolab.castor.builder.binding.xml.NamingType elementName) {
+        this._elementName = elementName;
+    }
+
+    /**
+     * Sets the value of field 'modelGroupName'.
+     * 
+     * @param modelGroupName the value of field 'modelGroupName'.
+     */
+    public void setModelGroupName(
+            final org.exolab.castor.builder.binding.xml.NamingType modelGroupName) {
+        this._modelGroupName = modelGroupName;
+    }
+
+    /**
+     * Method unmarshalNamingXMLType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.NamingXMLType
+     */
+    public static org.exolab.castor.builder.binding.xml.NamingXMLType unmarshalNamingXMLType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.NamingXMLType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.NamingXMLType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/FieldType.java
@@ -0,0 +1,329 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * This type represents the binding for class member. It allows the
+ * definition
+ *  of its name and java type as well as an implementation of
+ * FieldHandler 
+ *  to help the Marshalling framework in handling that member.
+ * Defining a validator is also
+ *  possible. The names given for the validator and the
+ * fieldHandler must be fully qualified
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _javaType.
+     */
+    private java.lang.String _javaType;
+
+    /**
+     * Field _wrapper.
+     */
+    private boolean _wrapper;
+
+    /**
+     * keeps track of state for field: _wrapper
+     */
+    private boolean _has_wrapper;
+
+    /**
+     * Field _handler.
+     */
+    private java.lang.String _handler;
+
+    /**
+     * Field _collection.
+     */
+    private org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType _collection;
+
+    /**
+     * Field _visibility.
+     */
+    private org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType _visibility;
+
+    /**
+     * Field _validator.
+     */
+    private java.lang.String _validator;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     */
+    public void deleteWrapper(
+    ) {
+        this._has_wrapper= false;
+    }
+
+    /**
+     * Returns the value of field 'collection'.
+     * 
+     * @return the value of field 'Collection'.
+     */
+    public org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType getCollection(
+    ) {
+        return this._collection;
+    }
+
+    /**
+     * Returns the value of field 'handler'.
+     * 
+     * @return the value of field 'Handler'.
+     */
+    public java.lang.String getHandler(
+    ) {
+        return this._handler;
+    }
+
+    /**
+     * Returns the value of field 'javaType'.
+     * 
+     * @return the value of field 'JavaType'.
+     */
+    public java.lang.String getJavaType(
+    ) {
+        return this._javaType;
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'validator'.
+     * 
+     * @return the value of field 'Validator'.
+     */
+    public java.lang.String getValidator(
+    ) {
+        return this._validator;
+    }
+
+    /**
+     * Returns the value of field 'visibility'.
+     * 
+     * @return the value of field 'Visibility'.
+     */
+    public org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType getVisibility(
+    ) {
+        return this._visibility;
+    }
+
+    /**
+     * Returns the value of field 'wrapper'.
+     * 
+     * @return the value of field 'Wrapper'.
+     */
+    public boolean getWrapper(
+    ) {
+        return this._wrapper;
+    }
+
+    /**
+     * Method hasWrapper.
+     * 
+     * @return true if at least one Wrapper has been added
+     */
+    public boolean hasWrapper(
+    ) {
+        return this._has_wrapper;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Returns the value of field 'wrapper'.
+     * 
+     * @return the value of field 'Wrapper'.
+     */
+    public boolean isWrapper(
+    ) {
+        return this._wrapper;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'collection'.
+     * 
+     * @param collection the value of field 'collection'.
+     */
+    public void setCollection(
+            final org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType collection) {
+        this._collection = collection;
+    }
+
+    /**
+     * Sets the value of field 'handler'.
+     * 
+     * @param handler the value of field 'handler'.
+     */
+    public void setHandler(
+            final java.lang.String handler) {
+        this._handler = handler;
+    }
+
+    /**
+     * Sets the value of field 'javaType'.
+     * 
+     * @param javaType the value of field 'javaType'.
+     */
+    public void setJavaType(
+            final java.lang.String javaType) {
+        this._javaType = javaType;
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'validator'.
+     * 
+     * @param validator the value of field 'validator'.
+     */
+    public void setValidator(
+            final java.lang.String validator) {
+        this._validator = validator;
+    }
+
+    /**
+     * Sets the value of field 'visibility'.
+     * 
+     * @param visibility the value of field 'visibility'.
+     */
+    public void setVisibility(
+            final org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType visibility) {
+        this._visibility = visibility;
+    }
+
+    /**
+     * Sets the value of field 'wrapper'.
+     * 
+     * @param wrapper the value of field 'wrapper'.
+     */
+    public void setWrapper(
+            final boolean wrapper) {
+        this._wrapper = wrapper;
+        this._has_wrapper = true;
+    }
+
+    /**
+     * Method unmarshalFieldType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.FieldType
+     */
+    public static org.exolab.castor.builder.binding.xml.FieldType unmarshalFieldType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.FieldType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.FieldType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/PackageType.java
@@ -0,0 +1,168 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Mappings between a namespace and a java package can directly 
+ *  be defined in the binding file. This element allows also the
+ * mapping
+ *  between a package and a schemaLocation.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PackageType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _packageTypeChoice.
+     */
+    private org.exolab.castor.builder.binding.xml.PackageTypeChoice _packageTypeChoice;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PackageType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'packageTypeChoice'.
+     * 
+     * @return the value of field 'PackageTypeChoice'.
+     */
+    public org.exolab.castor.builder.binding.xml.PackageTypeChoice getPackageTypeChoice(
+    ) {
+        return this._packageTypeChoice;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'packageTypeChoice'.
+     * 
+     * @param packageTypeChoice the value of field
+     * 'packageTypeChoice'.
+     */
+    public void setPackageTypeChoice(
+            final org.exolab.castor.builder.binding.xml.PackageTypeChoice packageTypeChoice) {
+        this._packageTypeChoice = packageTypeChoice;
+    }
+
+    /**
+     * Method unmarshalPackageType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.PackageType
+     */
+    public static org.exolab.castor.builder.binding.xml.PackageType unmarshalPackageType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.PackageType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.PackageType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/Forces.java
@@ -0,0 +1,279 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class Forces.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class Forces implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _forceList.
+     */
+    private java.util.List _forceList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public Forces() {
+        super();
+        this._forceList = new java.util.ArrayList();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vForce
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addForce(
+            final java.lang.String vForce)
+    throws java.lang.IndexOutOfBoundsException {
+        this._forceList.add(vForce);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vForce
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addForce(
+            final int index,
+            final java.lang.String vForce)
+    throws java.lang.IndexOutOfBoundsException {
+        this._forceList.add(index, vForce);
+    }
+
+    /**
+     * Method enumerateForce.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateForce(
+    ) {
+        return java.util.Collections.enumeration(this._forceList);
+    }
+
+    /**
+     * Method getForce.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the java.lang.String at the given index
+     */
+    public java.lang.String getForce(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._forceList.size()) {
+            throw new IndexOutOfBoundsException("getForce: Index value '" + index + "' not in range [0.." + (this._forceList.size() - 1) + "]");
+        }
+
+        return (java.lang.String) _forceList.get(index);
+    }
+
+    /**
+     * Method getForce.Returns the contents of the collection in an
+     * Array.  <p>Note:  Just in case the collection contents are
+     * changing in another thread, we pass a 0-length Array of the
+     * correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public java.lang.String[] getForce(
+    ) {
+        java.lang.String[] array = new java.lang.String[0];
+        return (java.lang.String[]) this._forceList.toArray(array);
+    }
+
+    /**
+     * Method getForceCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getForceCount(
+    ) {
+        return this._forceList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateForce.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateForce(
+    ) {
+        return this._forceList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllForce(
+    ) {
+        this._forceList.clear();
+    }
+
+    /**
+     * Method removeForce.
+     * 
+     * @param vForce
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeForce(
+            final java.lang.String vForce) {
+        boolean removed = _forceList.remove(vForce);
+        return removed;
+    }
+
+    /**
+     * Method removeForceAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public java.lang.String removeForceAt(
+            final int index) {
+        java.lang.Object obj = this._forceList.remove(index);
+        return (java.lang.String) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vForce
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setForce(
+            final int index,
+            final java.lang.String vForce)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._forceList.size()) {
+            throw new IndexOutOfBoundsException("setForce: Index value '" + index + "' not in range [0.." + (this._forceList.size() - 1) + "]");
+        }
+
+        this._forceList.set(index, vForce);
+    }
+
+    /**
+     * 
+     * 
+     * @param vForceArray
+     */
+    public void setForce(
+            final java.lang.String[] vForceArray) {
+        //-- copy array
+        _forceList.clear();
+
+        for (int i = 0; i < vForceArray.length; i++) {
+                this._forceList.add(vForceArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshalForces.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.Forces
+     */
+    public static org.exolab.castor.builder.binding.xml.Forces unmarshalForces(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.Forces) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.Forces.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/EnumBindingType.java
@@ -0,0 +1,312 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * This type allows the mapping between an XML schema enumeration
+ *  and a java class that follows the type-safe enumeration
+ * paradigm.
+ *  Additionally, it allows the specify the name of the Java
+ * constant
+ *  definition for a given enumeraton value.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class EnumBindingType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _enumClassName.
+     */
+    private org.exolab.castor.builder.binding.xml.EnumClassName _enumClassName;
+
+    /**
+     * Field _enumMemberList.
+     */
+    private java.util.List _enumMemberList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public EnumBindingType() {
+        super();
+        this._enumMemberList = new java.util.ArrayList();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vEnumMember
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addEnumMember(
+            final org.exolab.castor.builder.binding.xml.EnumMember vEnumMember)
+    throws java.lang.IndexOutOfBoundsException {
+        this._enumMemberList.add(vEnumMember);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vEnumMember
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addEnumMember(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.EnumMember vEnumMember)
+    throws java.lang.IndexOutOfBoundsException {
+        this._enumMemberList.add(index, vEnumMember);
+    }
+
+    /**
+     * Method enumerateEnumMember.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateEnumMember(
+    ) {
+        return java.util.Collections.enumeration(this._enumMemberList);
+    }
+
+    /**
+     * Returns the value of field 'enumClassName'.
+     * 
+     * @return the value of field 'EnumClassName'.
+     */
+    public org.exolab.castor.builder.binding.xml.EnumClassName getEnumClassName(
+    ) {
+        return this._enumClassName;
+    }
+
+    /**
+     * Method getEnumMember.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.EnumMember at the
+     * given index
+     */
+    public org.exolab.castor.builder.binding.xml.EnumMember getEnumMember(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._enumMemberList.size()) {
+            throw new IndexOutOfBoundsException("getEnumMember: Index value '" + index + "' not in range [0.." + (this._enumMemberList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.EnumMember) _enumMemberList.get(index);
+    }
+
+    /**
+     * Method getEnumMember.Returns the contents of the collection
+     * in an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.EnumMember[] getEnumMember(
+    ) {
+        org.exolab.castor.builder.binding.xml.EnumMember[] array = new org.exolab.castor.builder.binding.xml.EnumMember[0];
+        return (org.exolab.castor.builder.binding.xml.EnumMember[]) this._enumMemberList.toArray(array);
+    }
+
+    /**
+     * Method getEnumMemberCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getEnumMemberCount(
+    ) {
+        return this._enumMemberList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateEnumMember.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateEnumMember(
+    ) {
+        return this._enumMemberList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllEnumMember(
+    ) {
+        this._enumMemberList.clear();
+    }
+
+    /**
+     * Method removeEnumMember.
+     * 
+     * @param vEnumMember
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeEnumMember(
+            final org.exolab.castor.builder.binding.xml.EnumMember vEnumMember) {
+        boolean removed = _enumMemberList.remove(vEnumMember);
+        return removed;
+    }
+
+    /**
+     * Method removeEnumMemberAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.EnumMember removeEnumMemberAt(
+            final int index) {
+        java.lang.Object obj = this._enumMemberList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.EnumMember) obj;
+    }
+
+    /**
+     * Sets the value of field 'enumClassName'.
+     * 
+     * @param enumClassName the value of field 'enumClassName'.
+     */
+    public void setEnumClassName(
+            final org.exolab.castor.builder.binding.xml.EnumClassName enumClassName) {
+        this._enumClassName = enumClassName;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vEnumMember
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setEnumMember(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.EnumMember vEnumMember)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._enumMemberList.size()) {
+            throw new IndexOutOfBoundsException("setEnumMember: Index value '" + index + "' not in range [0.." + (this._enumMemberList.size() - 1) + "]");
+        }
+
+        this._enumMemberList.set(index, vEnumMember);
+    }
+
+    /**
+     * 
+     * 
+     * @param vEnumMemberArray
+     */
+    public void setEnumMember(
+            final org.exolab.castor.builder.binding.xml.EnumMember[] vEnumMemberArray) {
+        //-- copy array
+        _enumMemberList.clear();
+
+        for (int i = 0; i < vEnumMemberArray.length; i++) {
+                this._enumMemberList.add(vEnumMemberArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshalEnumBindingType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.EnumBindingType
+     */
+    public static org.exolab.castor.builder.binding.xml.EnumBindingType unmarshalEnumBindingType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.EnumBindingType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.EnumBindingType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/ComponentBindingType.java
@@ -0,0 +1,1355 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * A binding element is defined to express the binding between an
+ * XML Schema Component
+ *  and Java class OR a java interface or a java member class. The
+ * XML Schema component can 
+ *  be an element, an attribute, a complexType or a group.
+ * Attribute cannot be mapped to 
+ *  class, the reader of a binding file will take care that class
+ * or interface are not
+ *  used for component whose xml-type is attribute.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ComponentBindingType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _componentBindingTypeChoice.
+     */
+    private org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice _componentBindingTypeChoice;
+
+    /**
+     * Field _componentBindingList.
+     */
+    private java.util.List _componentBindingList;
+
+    /**
+     * Field _elementBindingList.
+     */
+    private java.util.List _elementBindingList;
+
+    /**
+     * Field _attributeBindingList.
+     */
+    private java.util.List _attributeBindingList;
+
+    /**
+     * Field _complexTypeBindingList.
+     */
+    private java.util.List _complexTypeBindingList;
+
+    /**
+     * Field _groupBindingList.
+     */
+    private java.util.List _groupBindingList;
+
+    /**
+     * Field _enumBindingList.
+     */
+    private java.util.List _enumBindingList;
+
+    /**
+     * Field _simpleTypeBindingList.
+     */
+    private java.util.List _simpleTypeBindingList;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ComponentBindingType() {
+        super();
+        this._componentBindingList = new java.util.ArrayList();
+        this._elementBindingList = new java.util.ArrayList();
+        this._attributeBindingList = new java.util.ArrayList();
+        this._complexTypeBindingList = new java.util.ArrayList();
+        this._groupBindingList = new java.util.ArrayList();
+        this._enumBindingList = new java.util.ArrayList();
+        this._simpleTypeBindingList = new java.util.ArrayList();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vAttributeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addAttributeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vAttributeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._attributeBindingList.add(vAttributeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vAttributeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addAttributeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vAttributeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._attributeBindingList.add(index, vAttributeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vComplexTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addComplexTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComplexTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._complexTypeBindingList.add(vComplexTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vComplexTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addComplexTypeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComplexTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._complexTypeBindingList.add(index, vComplexTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vComponentBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addComponentBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComponentBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._componentBindingList.add(vComponentBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vComponentBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addComponentBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComponentBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._componentBindingList.add(index, vComponentBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vElementBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addElementBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vElementBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._elementBindingList.add(vElementBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vElementBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addElementBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vElementBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._elementBindingList.add(index, vElementBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vEnumBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addEnumBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vEnumBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._enumBindingList.add(vEnumBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vEnumBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addEnumBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vEnumBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._enumBindingList.add(index, vEnumBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vGroupBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addGroupBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vGroupBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._groupBindingList.add(vGroupBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vGroupBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addGroupBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vGroupBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._groupBindingList.add(index, vGroupBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vSimpleTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addSimpleTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vSimpleTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._simpleTypeBindingList.add(vSimpleTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vSimpleTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addSimpleTypeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vSimpleTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        this._simpleTypeBindingList.add(index, vSimpleTypeBinding);
+    }
+
+    /**
+     * Method enumerateAttributeBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateAttributeBinding(
+    ) {
+        return java.util.Collections.enumeration(this._attributeBindingList);
+    }
+
+    /**
+     * Method enumerateComplexTypeBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateComplexTypeBinding(
+    ) {
+        return java.util.Collections.enumeration(this._complexTypeBindingList);
+    }
+
+    /**
+     * Method enumerateComponentBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateComponentBinding(
+    ) {
+        return java.util.Collections.enumeration(this._componentBindingList);
+    }
+
+    /**
+     * Method enumerateElementBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateElementBinding(
+    ) {
+        return java.util.Collections.enumeration(this._elementBindingList);
+    }
+
+    /**
+     * Method enumerateEnumBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateEnumBinding(
+    ) {
+        return java.util.Collections.enumeration(this._enumBindingList);
+    }
+
+    /**
+     * Method enumerateGroupBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateGroupBinding(
+    ) {
+        return java.util.Collections.enumeration(this._groupBindingList);
+    }
+
+    /**
+     * Method enumerateSimpleTypeBinding.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateSimpleTypeBinding(
+    ) {
+        return java.util.Collections.enumeration(this._simpleTypeBindingList);
+    }
+
+    /**
+     * Method getAttributeBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getAttributeBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._attributeBindingList.size()) {
+            throw new IndexOutOfBoundsException("getAttributeBinding: Index value '" + index + "' not in range [0.." + (this._attributeBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _attributeBindingList.get(index);
+    }
+
+    /**
+     * Method getAttributeBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getAttributeBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._attributeBindingList.toArray(array);
+    }
+
+    /**
+     * Method getAttributeBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getAttributeBindingCount(
+    ) {
+        return this._attributeBindingList.size();
+    }
+
+    /**
+     * Method getComplexTypeBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getComplexTypeBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._complexTypeBindingList.size()) {
+            throw new IndexOutOfBoundsException("getComplexTypeBinding: Index value '" + index + "' not in range [0.." + (this._complexTypeBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _complexTypeBindingList.get(index);
+    }
+
+    /**
+     * Method getComplexTypeBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getComplexTypeBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._complexTypeBindingList.toArray(array);
+    }
+
+    /**
+     * Method getComplexTypeBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getComplexTypeBindingCount(
+    ) {
+        return this._complexTypeBindingList.size();
+    }
+
+    /**
+     * Method getComponentBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getComponentBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._componentBindingList.size()) {
+            throw new IndexOutOfBoundsException("getComponentBinding: Index value '" + index + "' not in range [0.." + (this._componentBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _componentBindingList.get(index);
+    }
+
+    /**
+     * Method getComponentBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getComponentBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._componentBindingList.toArray(array);
+    }
+
+    /**
+     * Method getComponentBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getComponentBindingCount(
+    ) {
+        return this._componentBindingList.size();
+    }
+
+    /**
+     * Returns the value of field 'componentBindingTypeChoice'.
+     * 
+     * @return the value of field 'ComponentBindingTypeChoice'.
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice getComponentBindingTypeChoice(
+    ) {
+        return this._componentBindingTypeChoice;
+    }
+
+    /**
+     * Method getElementBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getElementBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._elementBindingList.size()) {
+            throw new IndexOutOfBoundsException("getElementBinding: Index value '" + index + "' not in range [0.." + (this._elementBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _elementBindingList.get(index);
+    }
+
+    /**
+     * Method getElementBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getElementBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._elementBindingList.toArray(array);
+    }
+
+    /**
+     * Method getElementBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getElementBindingCount(
+    ) {
+        return this._elementBindingList.size();
+    }
+
+    /**
+     * Method getEnumBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getEnumBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._enumBindingList.size()) {
+            throw new IndexOutOfBoundsException("getEnumBinding: Index value '" + index + "' not in range [0.." + (this._enumBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _enumBindingList.get(index);
+    }
+
+    /**
+     * Method getEnumBinding.Returns the contents of the collection
+     * in an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getEnumBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._enumBindingList.toArray(array);
+    }
+
+    /**
+     * Method getEnumBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getEnumBindingCount(
+    ) {
+        return this._enumBindingList.size();
+    }
+
+    /**
+     * Method getGroupBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getGroupBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._groupBindingList.size()) {
+            throw new IndexOutOfBoundsException("getGroupBinding: Index value '" + index + "' not in range [0.." + (this._groupBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _groupBindingList.get(index);
+    }
+
+    /**
+     * Method getGroupBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getGroupBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._groupBindingList.toArray(array);
+    }
+
+    /**
+     * Method getGroupBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getGroupBindingCount(
+    ) {
+        return this._groupBindingList.size();
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Method getSimpleTypeBinding.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     * at the given index
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType getSimpleTypeBinding(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._simpleTypeBindingList.size()) {
+            throw new IndexOutOfBoundsException("getSimpleTypeBinding: Index value '" + index + "' not in range [0.." + (this._simpleTypeBindingList.size() - 1) + "]");
+        }
+
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) _simpleTypeBindingList.get(index);
+    }
+
+    /**
+     * Method getSimpleTypeBinding.Returns the contents of the
+     * collection in an Array.  <p>Note:  Just in case the
+     * collection contents are changing in another thread, we pass
+     * a 0-length Array of the correct type into the API call. 
+     * This way we <i>know</i> that the Array returned is of
+     * exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType[] getSimpleTypeBinding(
+    ) {
+        org.exolab.castor.builder.binding.xml.ComponentBindingType[] array = new org.exolab.castor.builder.binding.xml.ComponentBindingType[0];
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType[]) this._simpleTypeBindingList.toArray(array);
+    }
+
+    /**
+     * Method getSimpleTypeBindingCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getSimpleTypeBindingCount(
+    ) {
+        return this._simpleTypeBindingList.size();
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateAttributeBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateAttributeBinding(
+    ) {
+        return this._attributeBindingList.iterator();
+    }
+
+    /**
+     * Method iterateComplexTypeBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateComplexTypeBinding(
+    ) {
+        return this._complexTypeBindingList.iterator();
+    }
+
+    /**
+     * Method iterateComponentBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateComponentBinding(
+    ) {
+        return this._componentBindingList.iterator();
+    }
+
+    /**
+     * Method iterateElementBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateElementBinding(
+    ) {
+        return this._elementBindingList.iterator();
+    }
+
+    /**
+     * Method iterateEnumBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateEnumBinding(
+    ) {
+        return this._enumBindingList.iterator();
+    }
+
+    /**
+     * Method iterateGroupBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateGroupBinding(
+    ) {
+        return this._groupBindingList.iterator();
+    }
+
+    /**
+     * Method iterateSimpleTypeBinding.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateSimpleTypeBinding(
+    ) {
+        return this._simpleTypeBindingList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllAttributeBinding(
+    ) {
+        this._attributeBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllComplexTypeBinding(
+    ) {
+        this._complexTypeBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllComponentBinding(
+    ) {
+        this._componentBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllElementBinding(
+    ) {
+        this._elementBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllEnumBinding(
+    ) {
+        this._enumBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllGroupBinding(
+    ) {
+        this._groupBindingList.clear();
+    }
+
+    /**
+     */
+    public void removeAllSimpleTypeBinding(
+    ) {
+        this._simpleTypeBindingList.clear();
+    }
+
+    /**
+     * Method removeAttributeBinding.
+     * 
+     * @param vAttributeBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeAttributeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vAttributeBinding) {
+        boolean removed = _attributeBindingList.remove(vAttributeBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeAttributeBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeAttributeBindingAt(
+            final int index) {
+        java.lang.Object obj = this._attributeBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeComplexTypeBinding.
+     * 
+     * @param vComplexTypeBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeComplexTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComplexTypeBinding) {
+        boolean removed = _complexTypeBindingList.remove(vComplexTypeBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeComplexTypeBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeComplexTypeBindingAt(
+            final int index) {
+        java.lang.Object obj = this._complexTypeBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeComponentBinding.
+     * 
+     * @param vComponentBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeComponentBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComponentBinding) {
+        boolean removed = _componentBindingList.remove(vComponentBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeComponentBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeComponentBindingAt(
+            final int index) {
+        java.lang.Object obj = this._componentBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeElementBinding.
+     * 
+     * @param vElementBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeElementBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vElementBinding) {
+        boolean removed = _elementBindingList.remove(vElementBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeElementBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeElementBindingAt(
+            final int index) {
+        java.lang.Object obj = this._elementBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeEnumBinding.
+     * 
+     * @param vEnumBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeEnumBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vEnumBinding) {
+        boolean removed = _enumBindingList.remove(vEnumBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeEnumBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeEnumBindingAt(
+            final int index) {
+        java.lang.Object obj = this._enumBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeGroupBinding.
+     * 
+     * @param vGroupBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeGroupBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vGroupBinding) {
+        boolean removed = _groupBindingList.remove(vGroupBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeGroupBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeGroupBindingAt(
+            final int index) {
+        java.lang.Object obj = this._groupBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * Method removeSimpleTypeBinding.
+     * 
+     * @param vSimpleTypeBinding
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeSimpleTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vSimpleTypeBinding) {
+        boolean removed = _simpleTypeBindingList.remove(vSimpleTypeBinding);
+        return removed;
+    }
+
+    /**
+     * Method removeSimpleTypeBindingAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public org.exolab.castor.builder.binding.xml.ComponentBindingType removeSimpleTypeBindingAt(
+            final int index) {
+        java.lang.Object obj = this._simpleTypeBindingList.remove(index);
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) obj;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vAttributeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setAttributeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vAttributeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._attributeBindingList.size()) {
+            throw new IndexOutOfBoundsException("setAttributeBinding: Index value '" + index + "' not in range [0.." + (this._attributeBindingList.size() - 1) + "]");
+        }
+
+        this._attributeBindingList.set(index, vAttributeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vAttributeBindingArray
+     */
+    public void setAttributeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vAttributeBindingArray) {
+        //-- copy array
+        _attributeBindingList.clear();
+
+        for (int i = 0; i < vAttributeBindingArray.length; i++) {
+                this._attributeBindingList.add(vAttributeBindingArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vComplexTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setComplexTypeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComplexTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._complexTypeBindingList.size()) {
+            throw new IndexOutOfBoundsException("setComplexTypeBinding: Index value '" + index + "' not in range [0.." + (this._complexTypeBindingList.size() - 1) + "]");
+        }
+
+        this._complexTypeBindingList.set(index, vComplexTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vComplexTypeBindingArray
+     */
+    public void setComplexTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vComplexTypeBindingArray) {
+        //-- copy array
+        _complexTypeBindingList.clear();
+
+        for (int i = 0; i < vComplexTypeBindingArray.length; i++) {
+                this._complexTypeBindingList.add(vComplexTypeBindingArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vComponentBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setComponentBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vComponentBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._componentBindingList.size()) {
+            throw new IndexOutOfBoundsException("setComponentBinding: Index value '" + index + "' not in range [0.." + (this._componentBindingList.size() - 1) + "]");
+        }
+
+        this._componentBindingList.set(index, vComponentBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vComponentBindingArray
+     */
+    public void setComponentBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vComponentBindingArray) {
+        //-- copy array
+        _componentBindingList.clear();
+
+        for (int i = 0; i < vComponentBindingArray.length; i++) {
+                this._componentBindingList.add(vComponentBindingArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'componentBindingTypeChoice'.
+     * 
+     * @param componentBindingTypeChoice the value of field
+     * 'componentBindingTypeChoice'.
+     */
+    public void setComponentBindingTypeChoice(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice componentBindingTypeChoice) {
+        this._componentBindingTypeChoice = componentBindingTypeChoice;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vElementBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setElementBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vElementBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._elementBindingList.size()) {
+            throw new IndexOutOfBoundsException("setElementBinding: Index value '" + index + "' not in range [0.." + (this._elementBindingList.size() - 1) + "]");
+        }
+
+        this._elementBindingList.set(index, vElementBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vElementBindingArray
+     */
+    public void setElementBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vElementBindingArray) {
+        //-- copy array
+        _elementBindingList.clear();
+
+        for (int i = 0; i < vElementBindingArray.length; i++) {
+                this._elementBindingList.add(vElementBindingArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vEnumBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setEnumBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vEnumBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._enumBindingList.size()) {
+            throw new IndexOutOfBoundsException("setEnumBinding: Index value '" + index + "' not in range [0.." + (this._enumBindingList.size() - 1) + "]");
+        }
+
+        this._enumBindingList.set(index, vEnumBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vEnumBindingArray
+     */
+    public void setEnumBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vEnumBindingArray) {
+        //-- copy array
+        _enumBindingList.clear();
+
+        for (int i = 0; i < vEnumBindingArray.length; i++) {
+                this._enumBindingList.add(vEnumBindingArray[i]);
+        }
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vGroupBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setGroupBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vGroupBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._groupBindingList.size()) {
+            throw new IndexOutOfBoundsException("setGroupBinding: Index value '" + index + "' not in range [0.." + (this._groupBindingList.size() - 1) + "]");
+        }
+
+        this._groupBindingList.set(index, vGroupBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vGroupBindingArray
+     */
+    public void setGroupBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vGroupBindingArray) {
+        //-- copy array
+        _groupBindingList.clear();
+
+        for (int i = 0; i < vGroupBindingArray.length; i++) {
+                this._groupBindingList.add(vGroupBindingArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vSimpleTypeBinding
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setSimpleTypeBinding(
+            final int index,
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType vSimpleTypeBinding)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._simpleTypeBindingList.size()) {
+            throw new IndexOutOfBoundsException("setSimpleTypeBinding: Index value '" + index + "' not in range [0.." + (this._simpleTypeBindingList.size() - 1) + "]");
+        }
+
+        this._simpleTypeBindingList.set(index, vSimpleTypeBinding);
+    }
+
+    /**
+     * 
+     * 
+     * @param vSimpleTypeBindingArray
+     */
+    public void setSimpleTypeBinding(
+            final org.exolab.castor.builder.binding.xml.ComponentBindingType[] vSimpleTypeBindingArray) {
+        //-- copy array
+        _simpleTypeBindingList.clear();
+
+        for (int i = 0; i < vSimpleTypeBindingArray.length; i++) {
+                this._simpleTypeBindingList.add(vSimpleTypeBindingArray[i]);
+        }
+    }
+
+    /**
+     * Method unmarshalComponentBindingType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.ComponentBindingType
+     */
+    public static org.exolab.castor.builder.binding.xml.ComponentBindingType unmarshalComponentBindingType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.ComponentBindingType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/ClassType.java
@@ -0,0 +1,599 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * This type gathers the needed information to generate a Java
+ * Class
+ *  from a binding file. Options such as generating the equals
+ * method,
+ *  using wrapper classes for primitives or using bound properties
+ * can
+ *  be defined via that element. When defined locally the options
+ * override
+ *  the values defined in the castor.properties file.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ClassType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _package.
+     */
+    private java.lang.String _package;
+
+    /**
+     * Field _name.
+     */
+    private java.lang.String _name;
+
+    /**
+     * Field _final.
+     */
+    private boolean _final;
+
+    /**
+     * keeps track of state for field: _final
+     */
+    private boolean _has_final;
+
+    /**
+     * Field _abstract.
+     */
+    private boolean _abstract;
+
+    /**
+     * keeps track of state for field: _abstract
+     */
+    private boolean _has_abstract;
+
+    /**
+     * Field _equals.
+     */
+    private boolean _equals;
+
+    /**
+     * keeps track of state for field: _equals
+     */
+    private boolean _has_equals;
+
+    /**
+     * Field _bound.
+     */
+    private boolean _bound;
+
+    /**
+     * keeps track of state for field: _bound
+     */
+    private boolean _has_bound;
+
+    /**
+     * Field _implementsList.
+     */
+    private java.util.List _implementsList;
+
+    /**
+     * Field _extends.
+     */
+    private java.lang.String _extends;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassType() {
+        super();
+        this._implementsList = new java.util.ArrayList();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * 
+     * 
+     * @param vImplements
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addImplements(
+            final java.lang.String vImplements)
+    throws java.lang.IndexOutOfBoundsException {
+        this._implementsList.add(vImplements);
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vImplements
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void addImplements(
+            final int index,
+            final java.lang.String vImplements)
+    throws java.lang.IndexOutOfBoundsException {
+        this._implementsList.add(index, vImplements);
+    }
+
+    /**
+     */
+    public void deleteAbstract(
+    ) {
+        this._has_abstract= false;
+    }
+
+    /**
+     */
+    public void deleteBound(
+    ) {
+        this._has_bound= false;
+    }
+
+    /**
+     */
+    public void deleteEquals(
+    ) {
+        this._has_equals= false;
+    }
+
+    /**
+     */
+    public void deleteFinal(
+    ) {
+        this._has_final= false;
+    }
+
+    /**
+     * Method enumerateImplements.
+     * 
+     * @return an Enumeration over all possible elements of this
+     * collection
+     */
+    public java.util.Enumeration enumerateImplements(
+    ) {
+        return java.util.Collections.enumeration(this._implementsList);
+    }
+
+    /**
+     * Returns the value of field 'abstract'.
+     * 
+     * @return the value of field 'Abstract'.
+     */
+    public boolean getAbstract(
+    ) {
+        return this._abstract;
+    }
+
+    /**
+     * Returns the value of field 'bound'.
+     * 
+     * @return the value of field 'Bound'.
+     */
+    public boolean getBound(
+    ) {
+        return this._bound;
+    }
+
+    /**
+     * Returns the value of field 'equals'.
+     * 
+     * @return the value of field 'Equals'.
+     */
+    public boolean getEquals(
+    ) {
+        return this._equals;
+    }
+
+    /**
+     * Returns the value of field 'extends'.
+     * 
+     * @return the value of field 'Extends'.
+     */
+    public java.lang.String getExtends(
+    ) {
+        return this._extends;
+    }
+
+    /**
+     * Returns the value of field 'final'.
+     * 
+     * @return the value of field 'Final'.
+     */
+    public boolean getFinal(
+    ) {
+        return this._final;
+    }
+
+    /**
+     * Method getImplements.
+     * 
+     * @param index
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     * @return the value of the java.lang.String at the given index
+     */
+    public java.lang.String getImplements(
+            final int index)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._implementsList.size()) {
+            throw new IndexOutOfBoundsException("getImplements: Index value '" + index + "' not in range [0.." + (this._implementsList.size() - 1) + "]");
+        }
+
+        return (java.lang.String) _implementsList.get(index);
+    }
+
+    /**
+     * Method getImplements.Returns the contents of the collection
+     * in an Array.  <p>Note:  Just in case the collection contents
+     * are changing in another thread, we pass a 0-length Array of
+     * the correct type into the API call.  This way we <i>know</i>
+     * that the Array returned is of exactly the correct length.
+     * 
+     * @return this collection as an Array
+     */
+    public java.lang.String[] getImplements(
+    ) {
+        java.lang.String[] array = new java.lang.String[0];
+        return (java.lang.String[]) this._implementsList.toArray(array);
+    }
+
+    /**
+     * Method getImplementsCount.
+     * 
+     * @return the size of this collection
+     */
+    public int getImplementsCount(
+    ) {
+        return this._implementsList.size();
+    }
+
+    /**
+     * Returns the value of field 'name'.
+     * 
+     * @return the value of field 'Name'.
+     */
+    public java.lang.String getName(
+    ) {
+        return this._name;
+    }
+
+    /**
+     * Returns the value of field 'package'.
+     * 
+     * @return the value of field 'Package'.
+     */
+    public java.lang.String getPackage(
+    ) {
+        return this._package;
+    }
+
+    /**
+     * Method hasAbstract.
+     * 
+     * @return true if at least one Abstract has been added
+     */
+    public boolean hasAbstract(
+    ) {
+        return this._has_abstract;
+    }
+
+    /**
+     * Method hasBound.
+     * 
+     * @return true if at least one Bound has been added
+     */
+    public boolean hasBound(
+    ) {
+        return this._has_bound;
+    }
+
+    /**
+     * Method hasEquals.
+     * 
+     * @return true if at least one Equals has been added
+     */
+    public boolean hasEquals(
+    ) {
+        return this._has_equals;
+    }
+
+    /**
+     * Method hasFinal.
+     * 
+     * @return true if at least one Final has been added
+     */
+    public boolean hasFinal(
+    ) {
+        return this._has_final;
+    }
+
+    /**
+     * Returns the value of field 'abstract'.
+     * 
+     * @return the value of field 'Abstract'.
+     */
+    public boolean isAbstract(
+    ) {
+        return this._abstract;
+    }
+
+    /**
+     * Returns the value of field 'bound'.
+     * 
+     * @return the value of field 'Bound'.
+     */
+    public boolean isBound(
+    ) {
+        return this._bound;
+    }
+
+    /**
+     * Returns the value of field 'equals'.
+     * 
+     * @return the value of field 'Equals'.
+     */
+    public boolean isEquals(
+    ) {
+        return this._equals;
+    }
+
+    /**
+     * Returns the value of field 'final'.
+     * 
+     * @return the value of field 'Final'.
+     */
+    public boolean isFinal(
+    ) {
+        return this._final;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Method iterateImplements.
+     * 
+     * @return an Iterator over all possible elements in this
+     * collection
+     */
+    public java.util.Iterator iterateImplements(
+    ) {
+        return this._implementsList.iterator();
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     */
+    public void removeAllImplements(
+    ) {
+        this._implementsList.clear();
+    }
+
+    /**
+     * Method removeImplements.
+     * 
+     * @param vImplements
+     * @return true if the object was removed from the collection.
+     */
+    public boolean removeImplements(
+            final java.lang.String vImplements) {
+        boolean removed = _implementsList.remove(vImplements);
+        return removed;
+    }
+
+    /**
+     * Method removeImplementsAt.
+     * 
+     * @param index
+     * @return the element removed from the collection
+     */
+    public java.lang.String removeImplementsAt(
+            final int index) {
+        java.lang.Object obj = this._implementsList.remove(index);
+        return (java.lang.String) obj;
+    }
+
+    /**
+     * Sets the value of field 'abstract'.
+     * 
+     * @param _abstract
+     * @param abstract the value of field 'abstract'.
+     */
+    public void setAbstract(
+            final boolean _abstract) {
+        this._abstract = _abstract;
+        this._has_abstract = true;
+    }
+
+    /**
+     * Sets the value of field 'bound'.
+     * 
+     * @param bound the value of field 'bound'.
+     */
+    public void setBound(
+            final boolean bound) {
+        this._bound = bound;
+        this._has_bound = true;
+    }
+
+    /**
+     * Sets the value of field 'equals'.
+     * 
+     * @param equals the value of field 'equals'.
+     */
+    public void setEquals(
+            final boolean equals) {
+        this._equals = equals;
+        this._has_equals = true;
+    }
+
+    /**
+     * Sets the value of field 'extends'.
+     * 
+     * @param _extends
+     * @param extends the value of field 'extends'.
+     */
+    public void setExtends(
+            final java.lang.String _extends) {
+        this._extends = _extends;
+    }
+
+    /**
+     * Sets the value of field 'final'.
+     * 
+     * @param _final
+     * @param final the value of field 'final'.
+     */
+    public void setFinal(
+            final boolean _final) {
+        this._final = _final;
+        this._has_final = true;
+    }
+
+    /**
+     * 
+     * 
+     * @param index
+     * @param vImplements
+     * @throws java.lang.IndexOutOfBoundsException if the index
+     * given is outside the bounds of the collection
+     */
+    public void setImplements(
+            final int index,
+            final java.lang.String vImplements)
+    throws java.lang.IndexOutOfBoundsException {
+        // check bounds for index
+        if (index < 0 || index >= this._implementsList.size()) {
+            throw new IndexOutOfBoundsException("setImplements: Index value '" + index + "' not in range [0.." + (this._implementsList.size() - 1) + "]");
+        }
+
+        this._implementsList.set(index, vImplements);
+    }
+
+    /**
+     * 
+     * 
+     * @param vImplementsArray
+     */
+    public void setImplements(
+            final java.lang.String[] vImplementsArray) {
+        //-- copy array
+        _implementsList.clear();
+
+        for (int i = 0; i < vImplementsArray.length; i++) {
+                this._implementsList.add(vImplementsArray[i]);
+        }
+    }
+
+    /**
+     * Sets the value of field 'name'.
+     * 
+     * @param name the value of field 'name'.
+     */
+    public void setName(
+            final java.lang.String name) {
+        this._name = name;
+    }
+
+    /**
+     * Sets the value of field 'package'.
+     * 
+     * @param _package
+     * @param package the value of field 'package'.
+     */
+    public void setPackage(
+            final java.lang.String _package) {
+        this._package = _package;
+    }
+
+    /**
+     * Method unmarshalClassType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.ClassType
+     */
+    public static org.exolab.castor.builder.binding.xml.ClassType unmarshalClassType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.ClassType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.ClassType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/PackageTypeChoice.java
@@ -0,0 +1,163 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class PackageTypeChoice.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PackageTypeChoice implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _namespace.
+     */
+    private java.lang.String _namespace;
+
+    /**
+     * Field _schemaLocation.
+     */
+    private java.lang.String _schemaLocation;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PackageTypeChoice() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'namespace'.
+     * 
+     * @return the value of field 'Namespace'.
+     */
+    public java.lang.String getNamespace(
+    ) {
+        return this._namespace;
+    }
+
+    /**
+     * Returns the value of field 'schemaLocation'.
+     * 
+     * @return the value of field 'SchemaLocation'.
+     */
+    public java.lang.String getSchemaLocation(
+    ) {
+        return this._schemaLocation;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'namespace'.
+     * 
+     * @param namespace the value of field 'namespace'.
+     */
+    public void setNamespace(
+            final java.lang.String namespace) {
+        this._namespace = namespace;
+    }
+
+    /**
+     * Sets the value of field 'schemaLocation'.
+     * 
+     * @param schemaLocation the value of field 'schemaLocation'.
+     */
+    public void setSchemaLocation(
+            final java.lang.String schemaLocation) {
+        this._schemaLocation = schemaLocation;
+    }
+
+    /**
+     * Method unmarshalPackageTypeChoice.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.PackageTypeChoice
+     */
+    public static org.exolab.castor.builder.binding.xml.PackageTypeChoice unmarshalPackageTypeChoice(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.PackageTypeChoice) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.PackageTypeChoice.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/NamingType.java
@@ -0,0 +1,163 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * Class NamingType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class NamingType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _prefix.
+     */
+    private java.lang.String _prefix;
+
+    /**
+     * Field _suffix.
+     */
+    private java.lang.String _suffix;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public NamingType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'prefix'.
+     * 
+     * @return the value of field 'Prefix'.
+     */
+    public java.lang.String getPrefix(
+    ) {
+        return this._prefix;
+    }
+
+    /**
+     * Returns the value of field 'suffix'.
+     * 
+     * @return the value of field 'Suffix'.
+     */
+    public java.lang.String getSuffix(
+    ) {
+        return this._suffix;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'prefix'.
+     * 
+     * @param prefix the value of field 'prefix'.
+     */
+    public void setPrefix(
+            final java.lang.String prefix) {
+        this._prefix = prefix;
+    }
+
+    /**
+     * Sets the value of field 'suffix'.
+     * 
+     * @param suffix the value of field 'suffix'.
+     */
+    public void setSuffix(
+            final java.lang.String suffix) {
+        this._suffix = suffix;
+    }
+
+    /**
+     * Method unmarshalNamingType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.NamingType
+     */
+    public static org.exolab.castor.builder.binding.xml.NamingType unmarshalNamingType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.NamingType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.NamingType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/IncludeType.java
@@ -0,0 +1,141 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml;
+
+/**
+ * A binding file can include other binding files by specifying the
+ * location 
+ *  (URI) of the binding files to include.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class IncludeType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _URI.
+     */
+    private java.lang.String _URI;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public IncludeType() {
+        super();
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Returns the value of field 'URI'.
+     * 
+     * @return the value of field 'URI'.
+     */
+    public java.lang.String getURI(
+    ) {
+        return this._URI;
+    }
+
+    /**
+     * Method isValid.
+     * 
+     * @return true if this object is valid according to the schema
+     */
+    public boolean isValid(
+    ) {
+        try {
+            validate();
+        } catch (org.exolab.castor.xml.ValidationException vex) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * 
+     * 
+     * @param out
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void marshal(
+            final java.io.Writer out)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, out);
+    }
+
+    /**
+     * 
+     * 
+     * @param handler
+     * @throws java.io.IOException if an IOException occurs during
+     * marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     */
+    public void marshal(
+            final org.xml.sax.ContentHandler handler)
+    throws java.io.IOException, org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Marshaller.marshal(this, handler);
+    }
+
+    /**
+     * Sets the value of field 'URI'.
+     * 
+     * @param URI the value of field 'URI'.
+     */
+    public void setURI(
+            final java.lang.String URI) {
+        this._URI = URI;
+    }
+
+    /**
+     * Method unmarshalIncludeType.
+     * 
+     * @param reader
+     * @throws org.exolab.castor.xml.MarshalException if object is
+     * null or if any SAXException is thrown during marshaling
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     * @return the unmarshaled
+     * org.exolab.castor.builder.binding.xml.IncludeType
+     */
+    public static org.exolab.castor.builder.binding.xml.IncludeType unmarshalIncludeType(
+            final java.io.Reader reader)
+    throws org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
+        return (org.exolab.castor.builder.binding.xml.IncludeType) org.exolab.castor.xml.Unmarshaller.unmarshal(org.exolab.castor.builder.binding.xml.IncludeType.class, reader);
+    }
+
+    /**
+     * 
+     * 
+     * @throws org.exolab.castor.xml.ValidationException if this
+     * object is an invalid instance according to the schema
+     */
+    public void validate(
+    )
+    throws org.exolab.castor.xml.ValidationException {
+        org.exolab.castor.xml.Validator validator = new org.exolab.castor.xml.Validator();
+        validator.validate(this);
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/BindingType.java
@@ -0,0 +1,155 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.types;
+
+/**
+ * List of the allowed values for the binding type from an XML
+ * schema
+ *  to a java class. The type can either be 'element' or
+ * 'complexType'.
+ *  
+ * 
+ * @version $Revision$ $Date$
+ */
+public class BindingType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The element type
+     */
+    public static final int ELEMENT_TYPE = 0;
+
+    /**
+     * The instance of the element type
+     */
+    public static final BindingType ELEMENT = new BindingType(ELEMENT_TYPE, "element");
+
+    /**
+     * The type type
+     */
+    public static final int TYPE_TYPE = 1;
+
+    /**
+     * The instance of the type type
+     */
+    public static final BindingType TYPE = new BindingType(TYPE_TYPE, "type");
+
+    /**
+     * Field _memberTable.
+     */
+    private static java.util.Hashtable _memberTable = init();
+
+    /**
+     * Field type.
+     */
+    private final int type;
+
+    /**
+     * Field stringValue.
+     */
+    private java.lang.String stringValue = null;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private BindingType(final int type, final java.lang.String value) {
+        super();
+        this.type = type;
+        this.stringValue = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method enumerate.Returns an enumeration of all possible
+     * instances of BindingType
+     * 
+     * @return an Enumeration over all possible instances of
+     * BindingType
+     */
+    public static java.util.Enumeration enumerate(
+    ) {
+        return _memberTable.elements();
+    }
+
+    /**
+     * Method getType.Returns the type of this BindingType
+     * 
+     * @return the type of this BindingType
+     */
+    public int getType(
+    ) {
+        return this.type;
+    }
+
+    /**
+     * Method init.
+     * 
+     * @return the initialized Hashtable for the member table
+     */
+    private static java.util.Hashtable init(
+    ) {
+        java.util.Hashtable members = new java.util.Hashtable();
+        members.put("element", ELEMENT);
+        members.put("type", TYPE);
+        return members;
+    }
+
+    /**
+     * Method readResolve. will be called during deserialization to
+     * replace the deserialized object with the correct constant
+     * instance.
+     * 
+     * @return this deserialized object
+     */
+    private java.lang.Object readResolve(
+    ) {
+        return valueOf(this.stringValue);
+    }
+
+    /**
+     * Method toString.Returns the String representation of this
+     * BindingType
+     * 
+     * @return the String representation of this BindingType
+     */
+    public java.lang.String toString(
+    ) {
+        return this.stringValue;
+    }
+
+    /**
+     * Method valueOf.Returns a new BindingType based on the given
+     * String value.
+     * 
+     * @param string
+     * @return the BindingType value of parameter 'string'
+     */
+    public static org.exolab.castor.builder.binding.xml.types.BindingType valueOf(
+            final java.lang.String string) {
+        java.lang.Object obj = null;
+        if (string != null) {
+            obj = _memberTable.get(string);
+        }
+        if (obj == null) {
+            String err = "" + string + " is not a valid BindingType";
+            throw new IllegalArgumentException(err);
+        }
+        return (BindingType) obj;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/VisibilityType.java
@@ -0,0 +1,162 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.types;
+
+/**
+ * Class VisibilityType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class VisibilityType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The public type
+     */
+    public static final int PUBLIC_TYPE = 0;
+
+    /**
+     * The instance of the public type
+     */
+    public static final VisibilityType PUBLIC = new VisibilityType(PUBLIC_TYPE, "public");
+
+    /**
+     * The protected type
+     */
+    public static final int PROTECTED_TYPE = 1;
+
+    /**
+     * The instance of the protected type
+     */
+    public static final VisibilityType PROTECTED = new VisibilityType(PROTECTED_TYPE, "protected");
+
+    /**
+     * The private type
+     */
+    public static final int PRIVATE_TYPE = 2;
+
+    /**
+     * The instance of the private type
+     */
+    public static final VisibilityType PRIVATE = new VisibilityType(PRIVATE_TYPE, "private");
+
+    /**
+     * Field _memberTable.
+     */
+    private static java.util.Hashtable _memberTable = init();
+
+    /**
+     * Field type.
+     */
+    private final int type;
+
+    /**
+     * Field stringValue.
+     */
+    private java.lang.String stringValue = null;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private VisibilityType(final int type, final java.lang.String value) {
+        super();
+        this.type = type;
+        this.stringValue = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method enumerate.Returns an enumeration of all possible
+     * instances of VisibilityType
+     * 
+     * @return an Enumeration over all possible instances of
+     * VisibilityType
+     */
+    public static java.util.Enumeration enumerate(
+    ) {
+        return _memberTable.elements();
+    }
+
+    /**
+     * Method getType.Returns the type of this VisibilityType
+     * 
+     * @return the type of this VisibilityType
+     */
+    public int getType(
+    ) {
+        return this.type;
+    }
+
+    /**
+     * Method init.
+     * 
+     * @return the initialized Hashtable for the member table
+     */
+    private static java.util.Hashtable init(
+    ) {
+        java.util.Hashtable members = new java.util.Hashtable();
+        members.put("public", PUBLIC);
+        members.put("protected", PROTECTED);
+        members.put("private", PRIVATE);
+        return members;
+    }
+
+    /**
+     * Method readResolve. will be called during deserialization to
+     * replace the deserialized object with the correct constant
+     * instance.
+     * 
+     * @return this deserialized object
+     */
+    private java.lang.Object readResolve(
+    ) {
+        return valueOf(this.stringValue);
+    }
+
+    /**
+     * Method toString.Returns the String representation of this
+     * VisibilityType
+     * 
+     * @return the String representation of this VisibilityType
+     */
+    public java.lang.String toString(
+    ) {
+        return this.stringValue;
+    }
+
+    /**
+     * Method valueOf.Returns a new VisibilityType based on the
+     * given String value.
+     * 
+     * @param string
+     * @return the VisibilityType value of parameter 'string'
+     */
+    public static org.exolab.castor.builder.binding.xml.types.VisibilityType valueOf(
+            final java.lang.String string) {
+        java.lang.Object obj = null;
+        if (string != null) {
+            obj = _memberTable.get(string);
+        }
+        if (obj == null) {
+            String err = "" + string + " is not a valid VisibilityType";
+            throw new IllegalArgumentException(err);
+        }
+        return (VisibilityType) obj;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/.castor.cdr
@@ -0,0 +1,5 @@
+#Sat Jun 12 20:25:04 VET 2010
+org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType=org.exolab.castor.builder.binding.xml.types.descriptors.FieldTypeVisibilityTypeDescriptor
+org.exolab.castor.builder.binding.xml.types.VisibilityType=org.exolab.castor.builder.binding.xml.types.descriptors.VisibilityTypeDescriptor
+org.exolab.castor.builder.binding.xml.types.BindingType=org.exolab.castor.builder.binding.xml.types.descriptors.BindingTypeDescriptor
+org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType=org.exolab.castor.builder.binding.xml.types.descriptors.FieldTypeCollectionTypeDescriptor
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/FieldTypeCollectionType.java
@@ -0,0 +1,231 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.types;
+
+/**
+ * Class FieldTypeCollectionType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldTypeCollectionType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The array type
+     */
+    public static final int ARRAY_TYPE = 0;
+
+    /**
+     * The instance of the array type
+     */
+    public static final FieldTypeCollectionType ARRAY = new FieldTypeCollectionType(ARRAY_TYPE, "array");
+
+    /**
+     * The vector type
+     */
+    public static final int VECTOR_TYPE = 1;
+
+    /**
+     * The instance of the vector type
+     */
+    public static final FieldTypeCollectionType VECTOR = new FieldTypeCollectionType(VECTOR_TYPE, "vector");
+
+    /**
+     * The arraylist type
+     */
+    public static final int ARRAYLIST_TYPE = 2;
+
+    /**
+     * The instance of the arraylist type
+     */
+    public static final FieldTypeCollectionType ARRAYLIST = new FieldTypeCollectionType(ARRAYLIST_TYPE, "arraylist");
+
+    /**
+     * The hashtable type
+     */
+    public static final int HASHTABLE_TYPE = 3;
+
+    /**
+     * The instance of the hashtable type
+     */
+    public static final FieldTypeCollectionType HASHTABLE = new FieldTypeCollectionType(HASHTABLE_TYPE, "hashtable");
+
+    /**
+     * The collection type
+     */
+    public static final int COLLECTION_TYPE = 4;
+
+    /**
+     * The instance of the collection type
+     */
+    public static final FieldTypeCollectionType COLLECTION = new FieldTypeCollectionType(COLLECTION_TYPE, "collection");
+
+    /**
+     * The odmg type
+     */
+    public static final int ODMG_TYPE = 5;
+
+    /**
+     * The instance of the odmg type
+     */
+    public static final FieldTypeCollectionType ODMG = new FieldTypeCollectionType(ODMG_TYPE, "odmg");
+
+    /**
+     * The set type
+     */
+    public static final int SET_TYPE = 6;
+
+    /**
+     * The instance of the set type
+     */
+    public static final FieldTypeCollectionType SET = new FieldTypeCollectionType(SET_TYPE, "set");
+
+    /**
+     * The map type
+     */
+    public static final int MAP_TYPE = 7;
+
+    /**
+     * The instance of the map type
+     */
+    public static final FieldTypeCollectionType MAP = new FieldTypeCollectionType(MAP_TYPE, "map");
+
+    /**
+     * The sortedset type
+     */
+    public static final int SORTEDSET_TYPE = 8;
+
+    /**
+     * The instance of the sortedset type
+     */
+    public static final FieldTypeCollectionType SORTEDSET = new FieldTypeCollectionType(SORTEDSET_TYPE, "sortedset");
+
+    /**
+     * Field _memberTable.
+     */
+    private static java.util.Hashtable _memberTable = init();
+
+    /**
+     * Field type.
+     */
+    private final int type;
+
+    /**
+     * Field stringValue.
+     */
+    private java.lang.String stringValue = null;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private FieldTypeCollectionType(final int type, final java.lang.String value) {
+        super();
+        this.type = type;
+        this.stringValue = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method enumerate.Returns an enumeration of all possible
+     * instances of FieldTypeCollectionType
+     * 
+     * @return an Enumeration over all possible instances of
+     * FieldTypeCollectionType
+     */
+    public static java.util.Enumeration enumerate(
+    ) {
+        return _memberTable.elements();
+    }
+
+    /**
+     * Method getType.Returns the type of this
+     * FieldTypeCollectionType
+     * 
+     * @return the type of this FieldTypeCollectionType
+     */
+    public int getType(
+    ) {
+        return this.type;
+    }
+
+    /**
+     * Method init.
+     * 
+     * @return the initialized Hashtable for the member table
+     */
+    private static java.util.Hashtable init(
+    ) {
+        java.util.Hashtable members = new java.util.Hashtable();
+        members.put("array", ARRAY);
+        members.put("vector", VECTOR);
+        members.put("arraylist", ARRAYLIST);
+        members.put("hashtable", HASHTABLE);
+        members.put("collection", COLLECTION);
+        members.put("odmg", ODMG);
+        members.put("set", SET);
+        members.put("map", MAP);
+        members.put("sortedset", SORTEDSET);
+        return members;
+    }
+
+    /**
+     * Method readResolve. will be called during deserialization to
+     * replace the deserialized object with the correct constant
+     * instance.
+     * 
+     * @return this deserialized object
+     */
+    private java.lang.Object readResolve(
+    ) {
+        return valueOf(this.stringValue);
+    }
+
+    /**
+     * Method toString.Returns the String representation of this
+     * FieldTypeCollectionType
+     * 
+     * @return the String representation of this
+     * FieldTypeCollectionType
+     */
+    public java.lang.String toString(
+    ) {
+        return this.stringValue;
+    }
+
+    /**
+     * Method valueOf.Returns a new FieldTypeCollectionType based
+     * on the given String value.
+     * 
+     * @param string
+     * @return the FieldTypeCollectionType value of parameter
+     * 'string'
+     */
+    public static org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType valueOf(
+            final java.lang.String string) {
+        java.lang.Object obj = null;
+        if (string != null) {
+            obj = _memberTable.get(string);
+        }
+        if (obj == null) {
+            String err = "" + string + " is not a valid FieldTypeCollectionType";
+            throw new IllegalArgumentException(err);
+        }
+        return (FieldTypeCollectionType) obj;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/FieldTypeVisibilityType.java
@@ -0,0 +1,165 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.types;
+
+/**
+ * Class FieldTypeVisibilityType.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldTypeVisibilityType implements java.io.Serializable {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * The public type
+     */
+    public static final int PUBLIC_TYPE = 0;
+
+    /**
+     * The instance of the public type
+     */
+    public static final FieldTypeVisibilityType PUBLIC = new FieldTypeVisibilityType(PUBLIC_TYPE, "public");
+
+    /**
+     * The protected type
+     */
+    public static final int PROTECTED_TYPE = 1;
+
+    /**
+     * The instance of the protected type
+     */
+    public static final FieldTypeVisibilityType PROTECTED = new FieldTypeVisibilityType(PROTECTED_TYPE, "protected");
+
+    /**
+     * The private type
+     */
+    public static final int PRIVATE_TYPE = 2;
+
+    /**
+     * The instance of the private type
+     */
+    public static final FieldTypeVisibilityType PRIVATE = new FieldTypeVisibilityType(PRIVATE_TYPE, "private");
+
+    /**
+     * Field _memberTable.
+     */
+    private static java.util.Hashtable _memberTable = init();
+
+    /**
+     * Field type.
+     */
+    private final int type;
+
+    /**
+     * Field stringValue.
+     */
+    private java.lang.String stringValue = null;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    private FieldTypeVisibilityType(final int type, final java.lang.String value) {
+        super();
+        this.type = type;
+        this.stringValue = value;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method enumerate.Returns an enumeration of all possible
+     * instances of FieldTypeVisibilityType
+     * 
+     * @return an Enumeration over all possible instances of
+     * FieldTypeVisibilityType
+     */
+    public static java.util.Enumeration enumerate(
+    ) {
+        return _memberTable.elements();
+    }
+
+    /**
+     * Method getType.Returns the type of this
+     * FieldTypeVisibilityType
+     * 
+     * @return the type of this FieldTypeVisibilityType
+     */
+    public int getType(
+    ) {
+        return this.type;
+    }
+
+    /**
+     * Method init.
+     * 
+     * @return the initialized Hashtable for the member table
+     */
+    private static java.util.Hashtable init(
+    ) {
+        java.util.Hashtable members = new java.util.Hashtable();
+        members.put("public", PUBLIC);
+        members.put("protected", PROTECTED);
+        members.put("private", PRIVATE);
+        return members;
+    }
+
+    /**
+     * Method readResolve. will be called during deserialization to
+     * replace the deserialized object with the correct constant
+     * instance.
+     * 
+     * @return this deserialized object
+     */
+    private java.lang.Object readResolve(
+    ) {
+        return valueOf(this.stringValue);
+    }
+
+    /**
+     * Method toString.Returns the String representation of this
+     * FieldTypeVisibilityType
+     * 
+     * @return the String representation of this
+     * FieldTypeVisibilityType
+     */
+    public java.lang.String toString(
+    ) {
+        return this.stringValue;
+    }
+
+    /**
+     * Method valueOf.Returns a new FieldTypeVisibilityType based
+     * on the given String value.
+     * 
+     * @param string
+     * @return the FieldTypeVisibilityType value of parameter
+     * 'string'
+     */
+    public static org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType valueOf(
+            final java.lang.String string) {
+        java.lang.Object obj = null;
+        if (string != null) {
+            obj = _memberTable.get(string);
+        }
+        if (obj == null) {
+            String err = "" + string + " is not a valid FieldTypeVisibilityType";
+            throw new IllegalArgumentException(err);
+        }
+        return (FieldTypeVisibilityType) obj;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/descriptors/FieldTypeVisibilityTypeDescriptor.java
@@ -0,0 +1,155 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType;
+
+/**
+ * Class FieldTypeVisibilityTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldTypeVisibilityTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldTypeVisibilityTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "FieldTypeVisibilityType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/descriptors/VisibilityTypeDescriptor.java
@@ -0,0 +1,155 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.types.VisibilityType;
+
+/**
+ * Class VisibilityTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class VisibilityTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public VisibilityTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "VisibilityType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.types.VisibilityType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/descriptors/BindingTypeDescriptor.java
@@ -0,0 +1,155 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.types.BindingType;
+
+/**
+ * Class BindingTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class BindingTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public BindingTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "BindingType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.types.BindingType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/types/descriptors/FieldTypeCollectionTypeDescriptor.java
@@ -0,0 +1,155 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.types.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType;
+
+/**
+ * Class FieldTypeCollectionTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldTypeCollectionTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldTypeCollectionTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "FieldTypeCollectionType";
+        _elementDefinition = false;
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/EnumMemberDescriptor.java
@@ -0,0 +1,249 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.EnumMember;
+
+/**
+ * Class EnumMemberDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class EnumMemberDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public EnumMemberDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "enumMember";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _value
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_value", "value", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                EnumMember target = (EnumMember) object;
+                return target.getValue();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    EnumMember target = (EnumMember) object;
+                    target.setValue( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _value
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _javaName
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_javaName", "javaName", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                EnumMember target = (EnumMember) object;
+                return target.getJavaName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    EnumMember target = (EnumMember) object;
+                    target.setJavaName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _javaName
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.EnumMember.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/BindingDescriptor.java
@@ -0,0 +1,675 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.Binding;
+
+/**
+ * Class BindingDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class BindingDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public BindingDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "binding";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _defaultBindingType
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.types.BindingType.class, "_defaultBindingType", "defaultBindingType", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getDefaultBindingType();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.setDefaultBindingType( (org.exolab.castor.builder.binding.xml.types.BindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.builder.binding.xml.types.BindingType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("BindingType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _defaultBindingType
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _includeList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.IncludeType.class, "_includeList", "include", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getInclude();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addInclude( (org.exolab.castor.builder.binding.xml.IncludeType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllInclude();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.IncludeType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.IncludeType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _includeList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _packageList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.PackageType.class, "_packageList", "package", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getPackage();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addPackage( (org.exolab.castor.builder.binding.xml.PackageType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllPackage();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.PackageType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.PackageType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _packageList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _namingXML
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.NamingXMLType.class, "_namingXML", "namingXML", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getNamingXML();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.setNamingXML( (org.exolab.castor.builder.binding.xml.NamingXMLType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.NamingXMLType();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.NamingXMLType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _namingXML
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _automaticNaming
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.AutomaticNamingType.class, "_automaticNaming", "automaticNaming", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getAutomaticNaming();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.setAutomaticNaming( (org.exolab.castor.builder.binding.xml.AutomaticNamingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.AutomaticNamingType();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.AutomaticNamingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _automaticNaming
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _componentBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_componentBindingList", "componentBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getComponentBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addComponentBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllComponentBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _componentBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _elementBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_elementBindingList", "elementBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getElementBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addElementBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllElementBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _elementBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _attributeBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_attributeBindingList", "attributeBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getAttributeBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addAttributeBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllAttributeBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _attributeBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _complexTypeBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_complexTypeBindingList", "complexTypeBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getComplexTypeBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addComplexTypeBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllComplexTypeBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _complexTypeBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _groupBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_groupBindingList", "groupBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getGroupBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addGroupBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllGroupBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _groupBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _enumBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_enumBindingList", "enumBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getEnumBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addEnumBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllEnumBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _enumBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _simpleTypeBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_simpleTypeBindingList", "simpleTypeBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Binding target = (Binding) object;
+                return target.getSimpleTypeBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Binding target = (Binding) object;
+                    target.addSimpleTypeBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Binding target = (Binding) object;
+                    target.removeAllSimpleTypeBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _simpleTypeBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.Binding.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/EnumBindingTypeDescriptor.java
@@ -0,0 +1,245 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.EnumBindingType;
+
+/**
+ * Class EnumBindingTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class EnumBindingTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public EnumBindingTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "enumBindingType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _enumClassName
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.EnumClassName.class, "_enumClassName", "enumClassName", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                EnumBindingType target = (EnumBindingType) object;
+                return target.getEnumClassName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    EnumBindingType target = (EnumBindingType) object;
+                    target.setEnumClassName( (org.exolab.castor.builder.binding.xml.EnumClassName) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.EnumClassName();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.EnumClassName");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _enumClassName
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _enumMemberList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.EnumMember.class, "_enumMemberList", "enumMember", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                EnumBindingType target = (EnumBindingType) object;
+                return target.getEnumMember();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    EnumBindingType target = (EnumBindingType) object;
+                    target.addEnumMember( (org.exolab.castor.builder.binding.xml.EnumMember) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    EnumBindingType target = (EnumBindingType) object;
+                    target.removeAllEnumMember();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.EnumMember();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.EnumMember");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _enumMemberList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.EnumBindingType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/NamingTypeDescriptor.java
@@ -0,0 +1,245 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.NamingType;
+
+/**
+ * Class NamingTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class NamingTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public NamingTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "namingType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _prefix
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_prefix", "prefix", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamingType target = (NamingType) object;
+                return target.getPrefix();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamingType target = (NamingType) object;
+                    target.setPrefix( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _prefix
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _suffix
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_suffix", "suffix", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamingType target = (NamingType) object;
+                return target.getSuffix();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamingType target = (NamingType) object;
+                    target.setSuffix( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _suffix
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.NamingType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/PackageTypeChoiceDescriptor.java
@@ -0,0 +1,248 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.PackageTypeChoice;
+
+/**
+ * Class PackageTypeChoiceDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PackageTypeChoiceDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PackageTypeChoiceDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsChoice();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _namespace
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_namespace", "namespace", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                PackageTypeChoice target = (PackageTypeChoice) object;
+                return target.getNamespace();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    PackageTypeChoice target = (PackageTypeChoice) object;
+                    target.setNamespace( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _namespace
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _schemaLocation
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_schemaLocation", "schemaLocation", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                PackageTypeChoice target = (PackageTypeChoice) object;
+                return target.getSchemaLocation();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    PackageTypeChoice target = (PackageTypeChoice) object;
+                    target.setSchemaLocation( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _schemaLocation
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.PackageTypeChoice.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/ExcludesDescriptor.java
@@ -0,0 +1,211 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.Excludes;
+
+/**
+ * Class ExcludesDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ExcludesDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ExcludesDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "excludes";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _excludeList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.Exclude.class, "_excludeList", "exclude", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Excludes target = (Excludes) object;
+                return target.getExclude();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Excludes target = (Excludes) object;
+                    target.addExclude( (org.exolab.castor.builder.binding.xml.Exclude) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Excludes target = (Excludes) object;
+                    target.removeAllExclude();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.Exclude();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.Exclude");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _excludeList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.Excludes.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/EnumClassNameDescriptor.java
@@ -0,0 +1,237 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.EnumClassName;
+
+/**
+ * Class EnumClassNameDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class EnumClassNameDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public EnumClassNameDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "enumClassName";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- _content
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_content", "PCDATA", org.exolab.castor.xml.NodeType.Text);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                EnumClassName target = (EnumClassName) object;
+                return target.getContent();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    EnumClassName target = (EnumClassName) object;
+                    target.setContent( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _content
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize attribute descriptors
+
+        //-- _package
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_package", "package", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                EnumClassName target = (EnumClassName) object;
+                return target.getPackage();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    EnumClassName target = (EnumClassName) object;
+                    target.setPackage( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _package
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.EnumClassName.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/AutomaticNamingTypeDescriptor.java
@@ -0,0 +1,235 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.AutomaticNamingType;
+
+/**
+ * Class AutomaticNamingTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class AutomaticNamingTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public AutomaticNamingTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "automaticNamingType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _forces
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.Forces.class, "_forces", "forces", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                AutomaticNamingType target = (AutomaticNamingType) object;
+                return target.getForces();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    AutomaticNamingType target = (AutomaticNamingType) object;
+                    target.setForces( (org.exolab.castor.builder.binding.xml.Forces) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.Forces();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.Forces");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _forces
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _excludes
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.Excludes.class, "_excludes", "excludes", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                AutomaticNamingType target = (AutomaticNamingType) object;
+                return target.getExcludes();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    AutomaticNamingType target = (AutomaticNamingType) object;
+                    target.setExcludes( (org.exolab.castor.builder.binding.xml.Excludes) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.Excludes();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.Excludes");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _excludes
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.AutomaticNamingType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/ForcesDescriptor.java
@@ -0,0 +1,216 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.Forces;
+
+/**
+ * Class ForcesDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ForcesDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ForcesDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "forces";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _forceList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_forceList", "force", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Forces target = (Forces) object;
+                return target.getForce();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Forces target = (Forces) object;
+                    target.addForce( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    Forces target = (Forces) object;
+                    target.removeAllForce();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _forceList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.Forces.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/ExcludeDescriptor.java
@@ -0,0 +1,247 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.Exclude;
+
+/**
+ * Class ExcludeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ExcludeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ExcludeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "exclude";
+        _elementDefinition = true;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Exclude target = (Exclude) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Exclude target = (Exclude) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _className
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_className", "class-name", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Exclude target = (Exclude) object;
+                return target.getClassName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Exclude target = (Exclude) object;
+                    target.setClassName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _className
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.Exclude.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/ComponentBindingTypeChoiceDescriptor.java
@@ -0,0 +1,349 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice;
+
+/**
+ * Class ComponentBindingTypeChoiceDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ComponentBindingTypeChoiceDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ComponentBindingTypeChoiceDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsChoice();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _javaClass
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ClassType.class, "_javaClass", "java-class", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                return target.getJavaClass();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                    target.setJavaClass( (org.exolab.castor.builder.binding.xml.ClassType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ClassType();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.ClassType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _javaClass
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _interface
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.Interface.class, "_interface", "interface", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                return target.getInterface();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                    target.setInterface( (org.exolab.castor.builder.binding.xml.Interface) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.Interface();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.Interface");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _interface
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _member
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.FieldType.class, "_member", "member", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                return target.getMember();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                    target.setMember( (org.exolab.castor.builder.binding.xml.FieldType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.FieldType();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.FieldType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _member
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _enumDef
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.EnumBindingType.class, "_enumDef", "enum-def", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                return target.getEnumDef();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                    target.setEnumDef( (org.exolab.castor.builder.binding.xml.EnumBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.EnumBindingType();
+            }
+        };
+        desc.setSchemaType("enumBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _enumDef
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _contentMember
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ContentMemberType.class, "_contentMember", "contentMember", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                return target.getContentMember();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingTypeChoice target = (ComponentBindingTypeChoice) object;
+                    target.setContentMember( (org.exolab.castor.builder.binding.xml.ContentMemberType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ContentMemberType();
+            }
+        };
+        desc.setSchemaType("contentMemberType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _contentMember
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/ContentMemberTypeDescriptor.java
@@ -0,0 +1,235 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.ContentMemberType;
+
+/**
+ * Class ContentMemberTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ContentMemberTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ContentMemberTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "contentMemberType";
+        _elementDefinition = false;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ContentMemberType target = (ContentMemberType) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ContentMemberType target = (ContentMemberType) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _visibility
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.types.VisibilityType.class, "_visibility", "visibility", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ContentMemberType target = (ContentMemberType) object;
+                return target.getVisibility();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ContentMemberType target = (ContentMemberType) object;
+                    target.setVisibility( (org.exolab.castor.builder.binding.xml.types.VisibilityType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.builder.binding.xml.types.VisibilityType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("VisibilityType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _visibility
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.ContentMemberType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/PackageTypeDescriptor.java
@@ -0,0 +1,246 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.PackageType;
+
+/**
+ * Class PackageTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class PackageTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public PackageTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "packageType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                PackageType target = (PackageType) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    PackageType target = (PackageType) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _packageTypeChoice
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.PackageTypeChoice.class, "_packageTypeChoice", "-error-if-this-is-used-", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                PackageType target = (PackageType) object;
+                return target.getPackageTypeChoice();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    PackageType target = (PackageType) object;
+                    target.setPackageTypeChoice( (org.exolab.castor.builder.binding.xml.PackageTypeChoice) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.PackageTypeChoice();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.PackageTypeChoice");
+        desc.setHandler(handler);
+        desc.setContainer(true);
+        desc.setClassDescriptor(new org.exolab.castor.builder.binding.xml.descriptors.PackageTypeChoiceDescriptor());
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _packageTypeChoice
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.PackageType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/InterfaceDescriptor.java
@@ -0,0 +1,202 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.Interface;
+
+/**
+ * Class InterfaceDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class InterfaceDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public InterfaceDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "interface";
+        _elementDefinition = true;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                Interface target = (Interface) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    Interface target = (Interface) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.Interface.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/NamingXMLTypeDescriptor.java
@@ -0,0 +1,270 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.NamingXMLType;
+
+/**
+ * Class NamingXMLTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class NamingXMLTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public NamingXMLTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "namingXMLType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- initialize element descriptors
+
+        //-- _elementName
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.NamingType.class, "_elementName", "elementName", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamingXMLType target = (NamingXMLType) object;
+                return target.getElementName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamingXMLType target = (NamingXMLType) object;
+                    target.setElementName( (org.exolab.castor.builder.binding.xml.NamingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.NamingType();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.NamingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _elementName
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _complexTypeName
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.NamingType.class, "_complexTypeName", "complexTypeName", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamingXMLType target = (NamingXMLType) object;
+                return target.getComplexTypeName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamingXMLType target = (NamingXMLType) object;
+                    target.setComplexTypeName( (org.exolab.castor.builder.binding.xml.NamingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.NamingType();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.NamingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _complexTypeName
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _modelGroupName
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.NamingType.class, "_modelGroupName", "modelGroupName", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                NamingXMLType target = (NamingXMLType) object;
+                return target.getModelGroupName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    NamingXMLType target = (NamingXMLType) object;
+                    target.setModelGroupName( (org.exolab.castor.builder.binding.xml.NamingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.NamingType();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.NamingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _modelGroupName
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.NamingXMLType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/ClassTypeDescriptor.java
@@ -0,0 +1,499 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.ClassType;
+
+/**
+ * Class ClassTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ClassTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ClassTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "classType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _package
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_package", "package", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassType target = (ClassType) object;
+                return target.getPackage();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassType target = (ClassType) object;
+                    target.setPackage( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _package
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassType target = (ClassType) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassType target = (ClassType) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _final
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_final", "final", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassType target = (ClassType) object;
+                if (!target.hasFinal()) { return null; }
+                return (target.getFinal() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassType target = (ClassType) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteFinal();
+                        return;
+                    }
+                    target.setFinal( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _final
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _abstract
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_abstract", "abstract", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassType target = (ClassType) object;
+                if (!target.hasAbstract()) { return null; }
+                return (target.getAbstract() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassType target = (ClassType) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteAbstract();
+                        return;
+                    }
+                    target.setAbstract( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _abstract
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _equals
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_equals", "equals", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassType target = (ClassType) object;
+                if (!target.hasEquals()) { return null; }
+                return (target.getEquals() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassType target = (ClassType) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteEquals();
+                        return;
+                    }
+                    target.setEquals( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _equals
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _bound
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_bound", "bound", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassType target = (ClassType) object;
+                if (!target.hasBound()) { return null; }
+                return (target.getBound() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassType target = (ClassType) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteBound();
+                        return;
+                    }
+                    target.setBound( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _bound
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _implementsList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_implementsList", "implements", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassType target = (ClassType) object;
+                return target.getImplements();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassType target = (ClassType) object;
+                    target.addImplements( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ClassType target = (ClassType) object;
+                    target.removeAllImplements();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _implementsList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _extends
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_extends", "extends", org.exolab.castor.xml.NodeType.Element);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ClassType target = (ClassType) object;
+                return target.getExtends();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ClassType target = (ClassType) object;
+                    target.setExtends( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _extends
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.ClassType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/IncludeTypeDescriptor.java
@@ -0,0 +1,197 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.IncludeType;
+
+/**
+ * Class IncludeTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class IncludeTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public IncludeTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "includeType";
+        _elementDefinition = false;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _URI
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_URI", "URI", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                IncludeType target = (IncludeType) object;
+                return target.getURI();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    IncludeType target = (IncludeType) object;
+                    target.setURI( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new java.lang.String();
+            }
+        };
+        desc.setSchemaType("anyURI");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _URI
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.IncludeType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/FieldTypeDescriptor.java
@@ -0,0 +1,426 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.FieldType;
+
+/**
+ * Class FieldTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class FieldTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public FieldTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "fieldType";
+        _elementDefinition = false;
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldType target = (FieldType) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldType target = (FieldType) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _javaType
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_javaType", "java-type", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldType target = (FieldType) object;
+                return target.getJavaType();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldType target = (FieldType) object;
+                    target.setJavaType( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _javaType
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _wrapper
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.Boolean.TYPE, "_wrapper", "wrapper", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldType target = (FieldType) object;
+                if (!target.hasWrapper()) { return null; }
+                return (target.getWrapper() ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE);
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldType target = (FieldType) object;
+                    // if null, use delete method for optional primitives 
+                    if (value == null) {
+                        target.deleteWrapper();
+                        return;
+                    }
+                    target.setWrapper( ((java.lang.Boolean) value).booleanValue());
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("boolean");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _wrapper
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.BooleanValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.BooleanValidator();
+            fieldValidator.setValidator(typeValidator);
+        }
+        desc.setValidator(fieldValidator);
+        //-- _handler
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_handler", "handler", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldType target = (FieldType) object;
+                return target.getHandler();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldType target = (FieldType) object;
+                    target.setHandler( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _handler
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- _collection
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType.class, "_collection", "collection", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldType target = (FieldType) object;
+                return target.getCollection();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldType target = (FieldType) object;
+                    target.setCollection( (org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.builder.binding.xml.types.FieldTypeCollectionType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("FieldTypeCollectionType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _collection
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _visibility
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType.class, "_visibility", "visibility", org.exolab.castor.xml.NodeType.Attribute);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldType target = (FieldType) object;
+                return target.getVisibility();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldType target = (FieldType) object;
+                    target.setVisibility( (org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        handler = new org.exolab.castor.xml.handlers.EnumFieldHandler(org.exolab.castor.builder.binding.xml.types.FieldTypeVisibilityType.class, handler);
+        desc.setImmutable(true);
+        desc.setSchemaType("FieldTypeVisibilityType");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _visibility
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _validator
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_validator", "validator", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                FieldType target = (FieldType) object;
+                return target.getValidator();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    FieldType target = (FieldType) object;
+                    target.setValidator( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _validator
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.FieldType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
--- /dev/null
+++ castor-1.3.1/codegen/target/generated-sources/castor/org/exolab/castor/builder/binding/xml/descriptors/ComponentBindingTypeDescriptor.java
@@ -0,0 +1,559 @@
+/*
+ * This class was automatically generated with 
+ * <a href="http://www.castor.org">Castor 1.3.0.1</a>, using an XML
+ * Schema.
+ * $Id$
+ */
+
+package org.exolab.castor.builder.binding.xml.descriptors;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import org.exolab.castor.builder.binding.xml.ComponentBindingType;
+
+/**
+ * Class ComponentBindingTypeDescriptor.
+ * 
+ * @version $Revision$ $Date$
+ */
+public class ComponentBindingTypeDescriptor extends org.exolab.castor.xml.util.XMLClassDescriptorImpl {
+
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field _elementDefinition.
+     */
+    private boolean _elementDefinition;
+
+    /**
+     * Field _nsPrefix.
+     */
+    private java.lang.String _nsPrefix;
+
+    /**
+     * Field _nsURI.
+     */
+    private java.lang.String _nsURI;
+
+    /**
+     * Field _xmlName.
+     */
+    private java.lang.String _xmlName;
+
+    /**
+     * Field _identity.
+     */
+    private org.exolab.castor.xml.XMLFieldDescriptor _identity;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ComponentBindingTypeDescriptor() {
+        super();
+        _nsURI = "http://www.castor.org/SourceGenerator/Binding";
+        _xmlName = "componentBindingType";
+        _elementDefinition = false;
+
+        //-- set grouping compositor
+        setCompositorAsSequence();
+        org.exolab.castor.xml.util.XMLFieldDescriptorImpl  desc           = null;
+        org.exolab.castor.mapping.FieldHandler             handler        = null;
+        org.exolab.castor.xml.FieldValidator               fieldValidator = null;
+        //-- initialize attribute descriptors
+
+        //-- _name
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(java.lang.String.class, "_name", "name", org.exolab.castor.xml.NodeType.Attribute);
+        desc.setImmutable(true);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getName();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.setName( (java.lang.String) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return null;
+            }
+        };
+        desc.setSchemaType("string");
+        desc.setHandler(handler);
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+
+        //-- validation code for: _name
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+            org.exolab.castor.xml.validators.StringValidator typeValidator;
+            typeValidator = new org.exolab.castor.xml.validators.StringValidator();
+            fieldValidator.setValidator(typeValidator);
+            typeValidator.setWhiteSpace("preserve");
+        }
+        desc.setValidator(fieldValidator);
+        //-- initialize element descriptors
+
+        //-- _componentBindingTypeChoice
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice.class, "_componentBindingTypeChoice", "-error-if-this-is-used-", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getComponentBindingTypeChoice();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.setComponentBindingTypeChoice( (org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice();
+            }
+        };
+        desc.setSchemaType("org.exolab.castor.builder.binding.xml.ComponentBindingTypeChoice");
+        desc.setHandler(handler);
+        desc.setContainer(true);
+        desc.setClassDescriptor(new org.exolab.castor.builder.binding.xml.descriptors.ComponentBindingTypeChoiceDescriptor());
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setRequired(true);
+        desc.setMultivalued(false);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _componentBindingTypeChoice
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(1);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _componentBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_componentBindingList", "componentBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getComponentBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.addComponentBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.removeAllComponentBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _componentBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _elementBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_elementBindingList", "elementBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getElementBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.addElementBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.removeAllElementBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _elementBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _attributeBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_attributeBindingList", "attributeBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getAttributeBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.addAttributeBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.removeAllAttributeBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _attributeBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _complexTypeBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_complexTypeBindingList", "complexTypeBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getComplexTypeBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.addComplexTypeBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.removeAllComplexTypeBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _complexTypeBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _groupBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_groupBindingList", "groupBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getGroupBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.addGroupBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.removeAllGroupBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _groupBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _enumBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_enumBindingList", "enumBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getEnumBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.addEnumBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.removeAllEnumBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _enumBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+        //-- _simpleTypeBindingList
+        desc = new org.exolab.castor.xml.util.XMLFieldDescriptorImpl(org.exolab.castor.builder.binding.xml.ComponentBindingType.class, "_simpleTypeBindingList", "simpleTypeBinding", org.exolab.castor.xml.NodeType.Element);
+        handler = new org.exolab.castor.xml.XMLFieldHandler() {
+            public java.lang.Object getValue( java.lang.Object object ) 
+                throws IllegalStateException
+            {
+                ComponentBindingType target = (ComponentBindingType) object;
+                return target.getSimpleTypeBinding();
+            }
+            public void setValue( java.lang.Object object, java.lang.Object value) 
+                throws IllegalStateException, IllegalArgumentException
+            {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.addSimpleTypeBinding( (org.exolab.castor.builder.binding.xml.ComponentBindingType) value);
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException {
+                try {
+                    ComponentBindingType target = (ComponentBindingType) object;
+                    target.removeAllSimpleTypeBinding();
+                } catch (java.lang.Exception ex) {
+                    throw new IllegalStateException(ex.toString());
+                }
+            }
+            public java.lang.Object newInstance(java.lang.Object parent) {
+                return new org.exolab.castor.builder.binding.xml.ComponentBindingType();
+            }
+        };
+        desc.setSchemaType("list");
+        desc.setComponentType("org.exolab.castor.builder.binding.xml.ComponentBindingType");
+        desc.setHandler(handler);
+        desc.setNameSpaceURI("http://www.castor.org/SourceGenerator/Binding");
+        desc.setMultivalued(true);
+        addFieldDescriptor(desc);
+        addSequenceElement(desc);
+
+        //-- validation code for: _simpleTypeBindingList
+        fieldValidator = new org.exolab.castor.xml.FieldValidator();
+        fieldValidator.setMinOccurs(0);
+        { //-- local scope
+        }
+        desc.setValidator(fieldValidator);
+    }
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method getAccessMode.
+     * 
+     * @return the access mode specified for this class.
+     */
+    public org.exolab.castor.mapping.AccessMode getAccessMode(
+    ) {
+        return null;
+    }
+
+    /**
+     * Method getIdentity.
+     * 
+     * @return the identity field, null if this class has no
+     * identity.
+     */
+    public org.exolab.castor.mapping.FieldDescriptor getIdentity(
+    ) {
+        return _identity;
+    }
+
+    /**
+     * Method getJavaClass.
+     * 
+     * @return the Java class represented by this descriptor.
+     */
+    public java.lang.Class getJavaClass(
+    ) {
+        return org.exolab.castor.builder.binding.xml.ComponentBindingType.class;
+    }
+
+    /**
+     * Method getNameSpacePrefix.
+     * 
+     * @return the namespace prefix to use when marshaling as XML.
+     */
+    public java.lang.String getNameSpacePrefix(
+    ) {
+        return _nsPrefix;
+    }
+
+    /**
+     * Method getNameSpaceURI.
+     * 
+     * @return the namespace URI used when marshaling and
+     * unmarshaling as XML.
+     */
+    public java.lang.String getNameSpaceURI(
+    ) {
+        return _nsURI;
+    }
+
+    /**
+     * Method getValidator.
+     * 
+     * @return a specific validator for the class described by this
+     * ClassDescriptor.
+     */
+    public org.exolab.castor.xml.TypeValidator getValidator(
+    ) {
+        return this;
+    }
+
+    /**
+     * Method getXMLName.
+     * 
+     * @return the XML Name for the Class being described.
+     */
+    public java.lang.String getXMLName(
+    ) {
+        return _xmlName;
+    }
+
+    /**
+     * Method isElementDefinition.
+     * 
+     * @return true if XML schema definition of this Class is that
+     * of a global
+     * element or element with anonymous type definition.
+     */
+    public boolean isElementDefinition(
+    ) {
+        return _elementDefinition;
+    }
+
+}
